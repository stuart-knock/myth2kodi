#!/usr/bin/env bash

# **** WELCOME! ****
#
#myth2kodi is a modified version of mythicalLibrarian by Adam Outler
#
# mythicalLibrarian Author: Adam Outler
# email: adamoutler gmail.com
# mythicalLibrarian Originally Written: 2009ish
# https://github.com/adamoutler/mythicallibrarian
# http://forum.kodi.tv/showthread.php?pid=470402
#
# myth2kodi Author: Stuart A. Knock
# myth2kodi Originally Written: 2015-2016ish
# https://github.com/stuart-knock/myth2kodi
# http://forum.kodi.tv/showthread.php?tid=301925
#
#Software the way it should be: Free and Open Source
#

#Intention:
#  This program automates the mapping of MythTV recordings to a Kodi library.
#  It is designed to be a user job in MythTV. It can also be run manually from
#  a command line. It must have access to your MythTV recordings. The program
#  generates file names compatible with Kodi, then moves or links recordings
#  based on user settings. Comskip and NFO files are also generated from your
#  MythTV database, as required, so that Kodi can make use of them.
#
#Installation:
#  There is an install.sh script that supports local and system installs.
#  If you would prefer manual installation it is fairly straight-forward.
#  The myth2kodi file should be placed in the users path, see the binpath
#  variable in user settings (Default: /usr/local/bin). Some of the
#  functionality of this script is provided in other files, these will also
#  need to be placed in $binpath along with this script. They are:
#  mythdb_access -- Uses MythTV python bindings to access database information.
#  m2k_notify -- A script for sending notifications to Gnome Desktop.
#  bashlogging -- A set of bash functions that provide the logging mechanism
#                 used throughout myth2kodi.
#
#Usage:
#  To function on your system, some of the variables specified in the
#  USER SETTINGS section below may need to be modified from their defaults.
#  For example, to avoid permission issues, myth2kodi should be run as the
#  same user running MythTV (see USER SETTING, Librarian), or at the very
#  least a user permitted to read and write the recording files generated
#  by MythTV.
#  The MythTV user job should be called as follows:
#    $binpath/myth2kodi "%DIR%/%FILE%"
#  where "$binpath" is replaced by the full explicit path from USER SETTINGS.
#  At the command line, the script can be called with the following form:
#    myth2kodi "Input File" "show name" "episode name" "season-number" "episode-number"
#  for example:
#    myth2kodi "/home/myth/recordings/2308320472023429837.mpg" "South Park" "Here Comes the Neighborhood"
#  for additional functionality type:
#    myth2kodi --help
#
#Output-target:
#  If an error occurs and the file cannot be moved, then no change will occur to
#  the original file. If the MoveDir is full or not available, such as when
#  running a NAS and the computer is disconnected from the network, the
#  AlternateMoveDir will be used. If both of these dirs fail, the show will be
#  SymLinked in the FailSafeDir. You may elect to run the user job at a later
#  time when the issue has been resolved. Output dir and link type will depend
#  on user settings. The file name is preset to the most acceptable standard:
#    Show Title - SxxExx (Episode Title).ext
#
#Symlinking:
#  In MOVE mode, with SYMLINKing Enabled, myth2kodi will create a symbolic
#  link to the new file (in your Kodi library directory) with the same name and
#  location of the original file (The MythTV recordings directory). In LINK mode,
#  myth2kodi will not move the recording file, LINK mode creates a new symbolic
#  link to the original file. Both approaches enable Kodi to access the recording
#  while still allowing MythTV to keep track of it. In MOVE mode, with
#  SYMLINKing Disabled, after a successful move, myth2kodi will delete the
#  recording from MythTV's database -- MythTV can no longer track/control
#  recordings processed in this mode, and myth2kodi cannot undo them.
#
#
#Hardlinking:
#  Hardlinking leaves the original file as-is and creates the kodi-friendly
#  link as a hardlink instead of as a symlink. When using Kodis internal NFS
#  client, the scrapper 'sees' the original mythtv file name, not the name of
#  the symlink. If you can't mount your NFS share at the OS level, hardlinks
#  get around this issue. Hardlinks cannot cross partitions/filesystems, so if
#  you have more than one mythtv storage disk/partition, set
#  TargetPathIsInputPath='Enabled' for reliability.
#
#Output-Files:
#  myth2kodi will create several files in its working folder. This is a
#  list of the files and their functions:
#    +created.tracking keeps track of created comskip.txt and NFO files so they
#      can be deleted in the future if their video file is deleted.
#    +doover.sh is designed to keep track of failed jobs. It is designed to be
#      executable. #Commented commands are those which are determined to be
#      questionable. This file can be made executable and run after a problem is
#      corrected which caused the problem. Questionable commands are those which
#      will require you to add an episode title and set the myth2kodi
#      Database=Disabled setting. Questionable files do not have sufficient
#      guide data.
#    +markupstart.txt and markupstop.txt are files which contain information
#      from the last comskip generation. Deletion will cause no adverse effects.
#    +myth2kodi.log keeps track of operations and can be used to determine problems.
#    +shn.txt, sid.txt, and working.xml are used each time to determine the name
#      and show id of the last show identified.
#    +DailyReport directory is used to log the files which were moved that day.
#      It can be used as a "program guide" of sorts to keep track of what has
#      been added to your library.
#
#Logging:
#  Log files can be generated to show information for troubleshooting. You can
#  find the log file in myth2kodi's working folder (see USER SETTING, m2kdir).
#  For configuration options, see, the "Logging settings" section of
#  USER SETTINGS below. The default location of the main log file is:
#    /home/$Librarian/.myth2kodi/myth2kodi.log
#
#Database-external:
#  This program will make 3 calls to TheTVDB for every episode. The first one is
#  to obtain the series ID and verify the show name is correct. The second is to
#  check if the internally managed database is up-to-date. The third call will
#  only be made if the internal database is not up-to-date. The third call will
#  download a larger file which contains all information about the show which is
#  known on TheTVDB.
#
#Database-internal:
#  While myth2kodi maintains and requires its own external file/folder
#  database in the working directory, there is also support for integration with
#  MythTV's internal database. MythTV Database is required for movies to be
#  recognized and handled by myth2kodi. Also, in the event that the
#  integrated fuzzy logic cannot make a determination of the correct show name,
#  myth2kodi will pull the original air date from the MythTV database
#  and attempt to make an exact match to TheTVDB.com supplied data. In addition,
#  the type of program is extracted from the mythtv database and a determination
#  is made weather or not there is sufficient information available to identify
#  the show based upon guide data. In order to make myth2kodi work to
#  its full potential, all settings must be filled out correctly under the
#  database section of the user settings. Currently, the only guide data
#  supported is schedulesdirect through mythtv. When updating myth2kodi
#  it is best to delete all database folders to ensure proper data formatting.
#
#Dependencies:
#  "curl" -- downloads webpages and sends commands to Kodi;
#  "jq" -- parses json files, used for tvmaze data.
#  "agrep" -- provides fuzzy string matching;
#  "libnotify-bin" -- allows GNOME desktop notifications;
#  "mythbackend" -- Access the MythTV database.
#
#  These should all be available through the package manager for your Linux
#  distribution. For example:
#    "apt-get install curl"
#  or
#    "zypper install curl"
#
#  Logging in myth2kodi relies on a script called:
#    "bashlogging"
#  if you downloaded a release, then, this should be included in the tarball.
#  Otherwise it can be found at:
#    https://github.com/stuart-knock/bash-tools
#
#Gnome Notifications:
#  In order for myth2kodi to send notifications to the GNOME desktop, it
#  must have no-password sudo access. It uses this access strictly to send
#  complete, moving and failure status notifications. Because this program is
#  launched by the user $Librarian under normal circumstances, $Librarian must
#  temporarily become your user name in order to send a notification to your
#  desktop. This requires the use of a separate script, and for $Librarian to
#  have a sudoers group with no password option. Notifications are an optional
#  feature and will only work on the MythTV backend computer. The m2k_notify
#  script should be located in $binpath.
#
#KODI Notifications:
#   If enabled, myth2kodi will send a http requests to any specified KODI
#   servers to display library updates, to update the library and to clean out
#   the library. In order for this to work KODI you must ensure that the
#   setting in KODI under System->Network->Services->Allow control of KODI via
#   HTTP and Allow programs on other systems to control KODI are enabled.
#
#Show Name Translation:
#  The user may elect to create a file in the myth2kodi working folder which
#  will then translate any recorded show name into the desired show name.
#  This is useful for adding a year to distinguish between a new series and an
#  older series and/or typos in your guide data. By default it should be called
#  "showTranslations" and it will be in your $m2kdir folder. Correct show titles
#  can be determined by manually searching www.TheTVDB.com. The showTranslations
#  file is not needed by most SchedulesDirect users and the file should only be
#  created if it is needed. However, it is almost essential when using digital
#  free to air guide data, such as SydFTA (See USER SETTING, "GuideDataType").
#  An example file, "showTranslations.SydFTA", should be bundled with this script.
#  The format of showTranslations is (NB: no "#" or space at the start of a
#  line, only one space either side of "=", and no trailing space or any other
#  characters):
#    Filename: $m2kdir/showTranslations
#      My Guide Show Title = www.TheTVDB.com Show Title
#      Battlestar Gallactica = Battlestar Gallactica (2003)
#      The Office = The Office (US)
#      Millionaire = Who Wants To Be A Millionaire
#      Aqua teen Hungerforce = Aqua Teen Hunger Force
##############################################################################


##############################################################################
########################## BEGIN USER SETTINGS ###############################
##############################################################################

#Specify the name of the user running mythbackend, myth2kodi should always be
#run by that user. Default: 'mythtv'
Librarian='mythtv'                           #<------THIS VALUE MUST BE SET-------


############################ Processing settings #############################

# There are 4 modes for the processing of a recording:
#   'MOVE' -- Move the recording. And, by default: create a symlink at RECORDING_PATH;
#   'LINK' -- Do not move, just create a symbolic 'LINK'; and
#   'COPY' -- Copy the recording to the target location.
#   'HARDLINK' -- Do not move, create a hard link.
#NOTE: The 'COPY' mode is primarily meant for supporting the copying of MythTV
#      recording files to removable media with nice human readable file names.
#      It is not yet intended or tested as a mode for generating a local Kodi
#      library. See, 'example_copy_to_removable_media_myth2kodi.conf' for an
#      example of temporarily enabling 'COPY' mode for this purpose.
#Options: ['MOVE'(DEFAULT)|'LINK'|'COPY'|'HARDLINK']
PROCESS_RECORDING_MODE='MOVE'

#A modifier switch, relevant for PROCESS_RECORDING_MODE='MOVE'. With this
#setting 'Enabled' a link is created from the original MythTV recording file
#location to the file just moved into your Kodi library. This enables MythTV
#to continue tracking and maintain control of the recording.
#Options: ['Enabled'(DEFAULT)|'Disabled']
#WARNING: 'Disabled' Mode removes MythTV-DB entry, SO CANNOT BE UNDONE.
SYMLINK='Enabled'

#If TargetPathIsInputPath is Enabled, original dir will override MoveDir. This
#is useful for multiple recording dirs. TargetPathIsInputPath will separate
#generic shows from episodes and movies. Options: ['Enabled'|'Disabled'(DEFAULT)]
TargetPathIsInputPath='Disabled'

#ShowStopper prevents generic shows from being processed. Generic shows are
#those recordings that have not been identified as either a movie or an episode
#of a tv-series (more specifically, continuing shows with entries in TheTVDB).
#This typically means news or sporting events.
#Options: ['Enabled'(DEFAULT)|'Disabled']
ShowStopper='Enabled'

#DIR_TRACKING_CLEANUP will check for and remove the folders created by myth2kodi
#Options: ['Enabled'(DEFAULT)|'Disabled']
DIR_TRACKING_CLEANUP='Enabled'

#FailSafe mode will enable symlinks to be formed in FailSafeDir if the move or
#symlink operation fails. Options: Enabled|Disabled
FailSafeMode='Disabled'

#The following four settings can Enable or Disable the mechanisms used used for
#identifying an episode. By default they are all 'Enabled' and should generally
#be left that way. Identification is done by comparing the data extracted from
#your MythTV-DB and provided at the command line against data downloaded from
#TheTVBD and TVmaze.

#MATCH_SEASON_EPISODE can be used to enable/disable attempting episode identification
#based on the season and episode numbers. The mechanism is an exact match against
#the "season" and "episode" field from the Guide data in MythTV-DB against the
#"airedSeason" and "airedEpisodeNumber"(TheTVDB) & "season" and "number"(tvmaze)
#fields for the series.
#Options: ['Enabled'(DEFAULT)|'Disabled']
MATCH_SEASON_EPISODE='Enabled'

#MATCH_SUBTITLE can be used to enable/disable attempting episode identification
#based on the episode title. The mechanism first tries an exact match using grep,
#failing that it then uses agrep to "fuzzy" match the "subtitle" field from the
#Guide data in MythTV-DB against the "episodeName"(TheTVDB) and "name"(tvmaze)
#fields for the series.
#Options: ['Enabled'(DEFAULT)|'Disabled']
MATCH_SUBTITLE='Enabled'

#MATCH_ORIGINALAIRDATE can be used to enable/disable attempting episode identification
#based on the original airdate for the episode. The mechanism tries an exact match
#of the "originalairdate" field from the Guide data in MythTV-DB against the
#"firstAired"(TheTVDB) and "airdate"(tvmaze) fields for the series.
#Options: ['Enabled'(DEFAULT)|'Disabled']
MATCH_ORIGINALAIRDATE='Enabled'

#MATCH_PLOT can be used to enable/disable attempting episode identification
#based on the episode plot. The mechanism uses agrep to fuzzy match the
#"description" field from the Guide data in MythTV-DB against the overview(TheTVDB)
#and summary(tvmaze) data for the series.
#Options: ['Enabled'(DEFAULT)|'Disabled']
MATCH_PLOT='Enabled'

#StorageGroupFallback can enable/disable a bit of code that, if Guide Data
#identified the input file as a show or episode, but no episode or series
#information was found, then it checks if the MythTV-DB's storagegroup is
#movie[s] or film[s] and uses this to reset the recording type as Movie.
#To function it requires that you have created a MythTV storagegroup called
#something like 'Movies' and selected that storagegroup when making the rule
#for the recording. This works for my setup SAK.
#Options: ['Enabled'|'Disabled'(DEFAULT)]
StorageGroupFallback='Disabled'

#CommercialMarkup will generate comskip files for recordings when they are moved.
#Options: ['Enabled'(DEFAULT)|'Disabled']
CommercialMarkup='Enabled'

#CommercialMarkupCleanup if 'Enabled', when m2k_maintenance() is run, removes
#comskip & NFO files if the associated .mpg file cannot be found.
#Options: ['Enabled'(DEFAULT)|'Disabled']
CommercialMarkupCleanup='Enabled'

#Whether to track files and directories created by myth2kodi. This should always
#be 'Enabled' when performing ordinary processing to make MythTV recordings
#available to a Kodi library. It exists so we do not mess-up the tracking of
#myth2kodi's modifications to our Kodi library when we want to use myth2kodi
#with PROCESS_RECORDING_MODE='COPY' to put nicely named copies of our MythTV
#recordings on a removable media. See, 'example_copy_to_removable_media_myth2kodi.conf'.
#It's also automatically set to 'Disabled' if you process a non-MyhtTV recording.
#Options: ['Enabled'(DEFAULT)|'Disabled']
TRACKING='Enabled'

#A string to append to the "ShowFileName" before the suffix. Useful if you want
#to easily distinguish between recordings moved by myth2kodi and other media.
#For example, setting SHOW_FILE_NAME_APPEND=' - MYTH2KODI' will produce a
#processed recording name like 'TITLE S01E01 (SUBTITLE) - MYTH2KODI.mpg'
#rather than the default which is like 'TITLE S01E01 (SUBTITLE).mpg'.
#Default: ''
SHOW_FILE_NAME_APPEND=''

# GROUP_BY_RECGROUP can be used to enable/disable grouping of processed
# recordings by MythTV's recgroup property. When 'Enabled' the resulting target
# path is of the form: "$MoveDir/<recgroup>/ShowName/Season ..."; as opposed to
# the default('Disabled'): "$MoveDir/ShowName/Season ..."
#Options: ['Enabled'|'Disabled'(DEFAULT)]
GROUP_BY_RECGROUP='Disabled'

#There are some checks in the script that prevent reprocessing a recording that
#we have already processed. Enabling this option skips those checks.
#Options: ['Enabled'|'Disabled'(DEFAULT)]
FORCE_PROCESS='Disabled'

#The default version of agrep varies between distributions, with different
#versions recognising different flags/options. While myth2kodi tries to use an
#option set that works across as many variants as possible it can still have
#difficulty with the default agrep of some distributions. If agrep produces
#error messages when running myth2kodi, you can set an explicit path to a
#different version of agrep using this user-setting. For example, tre-agrep
#should work and is available as an alternative on most distributions.
M2K_AGREP="$(command -v agrep)"

############################# Directory Settings #############################

#myth2kodi working directory: Default: "$HOME/.myth2kodi"
#NOTE: This is the one parameter that cannot be set in 'myth2kodi.conf' and
#      must be set in the script -- as it is used to find 'myth2kodi.conf'.
m2kdir="$HOME/.myth2kodi"

#TODO: make this to just be used for essential sudo stuff, at the moment, I think,
#      this is only Notify... then require caller add the location they choose to
#      be in there path... recommend a default of /home/$Librarian/bin, see other related TODOs...
#The path which contains myth2kodi and associated scripts default=/usr/local/bin
#NOTE: While this can be set in myth2kodi.conf, it doesn't make much sense to
#      do so as the script should know where it is.
binpath='/usr/local/bin'

#The directory where myth2kodi writes its temporary files, Default='/tmp'
#Typically, /tmp is tmpfs and so avoids unnecessary writes to disk. If you're
#on Linux and /tmp is not tmpfs but you would rather avoid writing to disk then
#/dev/shm is guaranteed to be tmpfs. Alternatively, if you're short on RAM but
#do not mind some extra disk writes then use "$m2kdir". NOTE: When running with
#LOGLEVEL>=3, there are a number of temporary files that are not automatically
#deleted, they will, however, be cleared as part of: myth2kodi --maintenance
M2K_TMPDIR='/tmp'

#MoveDir is the folder which myth2kodi will move the file. No trailing / is
#accepted eg. "$HOME/videos"
MoveDir='/media/video/tv'                    #<------THIS VALUE MUST BE SET-------

#AlternateMoveDir will act as a secondary MoveDir if the primary MoveDir fails.
#No trailing / is accepted eg. "$HOME/videos"
AlternateMoveDir="$HOME/recordedTV"

#Primary Movie Dir. myth2kodi will attempt to move to this dir first. No
#trailing / is accepted eg. "$HOME/videos"
PrimaryMovieDir='/media/video/movies'        #<------THIS VALUE MUST BE SET-------

#AlternateMovieDir is a fallback move dir if the primary movie dir fails.
AlternateMovieDir="$HOME/recordedMovies"

#Primary Show Dir. myth2kodi will attempt to move to this dir first. No
#trailing / is accepted eg. "$HOME/videos"
PrimaryShowDir='/media/video/recordedShows'  #<------THIS VALUE MUST BE SET-------

#AlternateMoveDir is a fallback move dir if the primary move dir fails
AlternateShowDir="$HOME/recordedShows"

#FailSafeDir is used when the file cannot be moved to the MoveDir. FailSafe
#will not create folders. eg. /home/username
FailSafeDir="$HOME/FailSafe"                 #<------THIS VALUE MUST BE SET-------


######################### myth2kodi Database Settings ########################

#Whether to look online (primarily: www.thetvdb.com) when trying to identify
#series and episodes. This should be 'Enabled' for typical use. It is intended...
#Options: ['Enabled'(DEFAULT)|'Disabled'].
ONLINE_LOOKUP='Enabled'

#Language setting, used when accessing www.TheTVDB.com to build our local DB.
Language='en'

#API key used to access www.TheTVDB.com. Default: '3B054E548E3F4FBE'
APIkey='3B054E548E3F4FBE'

#Internet access Timeout in seconds, used for TheTVDB. Default: 50
Timeout=50

#Update database time in seconds, Longer duration means faster processing time
#and less strain on TheTVDB. Default='88920' (1 day + eps)
UpdateDatabase=264920


########################## MythTV Database Settings ##########################

#MythTV database access allows addition of movies, comskip data, and improves
#accuracy of episode recognition. Options: ['Enabled'(DEFAULT)|'Disabled']
Database='Enabled'

#Database access method for MythTV-DB ['PythonBindings'(DEFAULT)|'MySQL']
DATABASE_ACCESS='PythonBindings'

#MySQL MythTV Database: Default: 'mythconverg'
MySQLMythDb='mythconverg'

#Guide data type: SchedulesDirect currently covers DataDirect, MC2XML and others.
#SydFTA was written to handle the guide data transmitted by free-to-air digital
#channels in Sydney, Australia.
#Options: ['SchedulesDirect'|'SydFTA'(DEFAULT)]
GuideDataType='SydFTA'

#The IP address or name of the server for MythTV Database (used in python bindings only)
#TODO: This doesn't seem to be being used, at least, having it set incorrectly (192.168.1.42 while testing on borg (.78)) doesn't seem to cause a problem...
DBHostName='192.168.1.78'                    #<------THIS VALUE MUST BE SET-------

#MySQL User name: Default: 'mythtv'
MySQLuser='mythtv'

#MySQL Password: Default: 'mythtv'
MySQLpass='mythtv'                           #<------THIS VALUE MUST BE SET-------

#The Database Pin for the MythTV Database (used in python bindings only)
DBPin=0000                                   #<------THIS VALUE MUST BE SET-------


########################## Reporting/Communications ##########################

#DailyReport provides a local log of shows added to your library per day.
#Options: ['Enabled'(DEFAULT)|'Disabled']
DailyReport='Enabled'

#Notify tells myth2kodi to send a notification to the Desktop (currently only
#gnome) via DBUS upon completion. Options: ['Enabled'|'Disabled'(DEFAULT)]
Notify='Disabled'

#If notifications are enabled, desktop (currently only gnome) messages are
#sent to the user specified by NotifyUserName, Default: "$Librarian".
#  NOTE: if you want to specify a user other than $Librarian then $Librarian
#        must have passwordless sudo privileges otherwise the call to
#        m2k_notify will block, waiting for a password.
NotifyUserName="$Librarian"

#Send a notification to KODI to Update library upon Successful move job.
#Options: ['Enabled'(DEFAULT)|'Disabled']
KODIUpdate='Enabled'

#PREVENT CLOBBERING ON RECURSIVE CALLS#[[ -z "$KODIUpdate" ]] && KODIUpdate='Enabled'
#Send a notification to KODI to cleanup the library upon Successful move job.
#Options: ['Enabled'|'Disabled'(DEFAULT)]
KODIClean='Disabled'

#Send Notifications to KODI UI when the library is updated.
#Options: ['Enabled'(DEFAULT)|'Disabled']
KODINotify='Enabled'

#IP-Address and port for KODI Notifications. NOTE: If you've set username and
#password for remote access to kodi then you'll need to prepend user:password@
#to the ip addresses.
#Eg.KODIIPs=( '192.168.1.110:8080' 'user:password@192.168.1.111:8080' 'XBOX:8080' )
KODIIPs=( '127.0.0.1:8080' )                 #<------THIS VALUE MUST BE SET-------

#Whether to create an RSS entry. The RSS can be given as a target for the
#RSS-ticker running across the bottom of the default Kodi interface. If enabled
#it will show a list of recent successfully processed recordings. See,
#    myth2kodi --config-help
#for more information on setting this up.
#Options: ['Enabled'(DEFAULT)|'Disabled']
CREATE_RSS='Enabled'

#The directory to write the RSS file to when CREATE_RSS='Enabled'. The directory
#must exist and Librarian needs rwx permission to it.
#Default: '/var/www/myth2kodi-rss'
RSS_DIRECTORY='/var/www/myth2kodi-rss'

#RSSmaxItems controls the number of items in the RSS. RSS Can be activated by
#creating a folder in /var/www/myth2kodi-rss. NOTE: setting this to 0 will
#essentially be ignored as generateRSS() considers it unset and defaults to 8.
declare -i RSSmaxItems=8


############################ Maintenance Settings ############################

#How often (in seconds) to perform routine maintenance of tracked files.
#DEFAULT=259200 (72 hours)
#NOTE: Maintenance can be forced at any time using 'myth2kodi --maintenance'.
MAINTENANCE_PERIOD=259200

#How long to persist archived myth2kodi database files in months, DEFAULT=6.
M2K_DB_LIFE=6

#How long to persist daily report files in months, DEFAULT=12.
DAILYREPORT_LIFE=12

#How long to persist archived log files in months. Log files older than this
#will be deleted during maintenance. Default: 6
LOG_LIFE=6


############################## Logging Settings ##############################
#The settings below are for the bashlogging script which provides the configurable
#logging functionality used in myth2kodi.
#LOGLEVEL provides control over the amount of information myth2kodi reports.
#    0=Only Errors;
#    1=adds warnings;
#    2=adds more information;  --> DEFAULT
#    3=provides debugging output.
#Recommend 2 to start with or if you want to keep track of what myth2kodi is doing.
#Recommend 1 for usual operation, once you're confident that everything is working.
#Only use 3 if you have a particular problem that you're trying to track down,
#it significantly increases the output.
LOGLEVEL=2

#LogFileName is the name of the log file, this will be placed in myth2kodi's
#working directory, $m2kdir set above, and have the suffix '.log' appended.
#DEFAULT: 'myth2kodi'. Resulting in: "/home/$Librarian/.myth2kodi/myth2kodi.log"
#NOTE: LOGFILE is overridden in special contexts, such as running Diagnostics.
LogFileName='myth2kodi'

#LOGTYPE defines where to direct logging messages.
#Options: ['filestderr'(DEFAULT)|'stderr'|'file']:
#NOTE: This is made read only within the bashlogging script.
LOGTYPE='filestderr'

##############################################################################
######################### END USER SETTINGS ##################################
##############################################################################



#TODO: Review text under: Output-Files; Database-external; Database-internal;
#      Dependencies; .

#TODO: Make use of TMDb (https://www.themoviedb.org/) when the recorded
#  program is identified as being a Movie... eg
#    "https://api.themoviedb.org/3/search/movie?query=$$tmdbshowname&api_key=%(apikey)s&page=%%s" % (config)
#    "https://api.themoviedb.org/3/movie/$TMDbID?api_key=$TMDb_key
#Or http://omdbapi.com/, eg
#  http://www.omdbapi.com/?t=Casino&y=&plot=short&r=xml

#TODO: Consider adding consistent stack-trace information to all warn and err
#      statements in bash-logging. That is, add "${FUNCNAME[1]}(): " in front
#      of %s for all warn and err functions...

#TODO: Consider changing default binpath from "/usr/local/bin" to
#      "/home/$Librarian/bin". We really want to avoid root/sudo requirements
#      as much as possible.

#TODO: really need to review doover and undo usage...
#TODO: REALLY NEED TO REVIEW sudo USE AND PERMISSIONS EXPECTATIONS WITHIN THE SCRIPT...

#TODO: If we just prepend $binpath to $Librarian's path we could avoid all the
#      explicit paths in our function calls... Though we may need to clean up before we finished...
#          SCRIPTPATH="$( cd "$(dirname "$0")" ; pwd -P )"

#TODO: Check all deletion or other reference of ' ' and consider whether it
#      would be better to use the more inclusive [[:blank:]] or [[:space:]]...

#TODO: review issues caused by multiple simultaneous instances, eg log file
#      needs to be locked to prevent deleting by subsequent call that triggers
#      logrotate... maybe GUID log files on a per-call basis???

#
#TODO: ?Would it be neater to just have undo and doover as lists of MythTV
#      recording file names, then just have functions to process them???

################################################################################
##################### Abandon all hope, ye who enter here. #####################
################################################################################
#################### ADEPT PERSONNEL ONLY BEYOND THIS POINT ####################
################################################################################

################################################################################
######################### BEGIN FUNCTION DEFINITIONS ###########################
################################################################################

########################### ENTRY AND EXIT FUNCTIONS ###########################

#The exit_job function is a place where your custom scripts can be run at the
#end of execution. Though it may be at the top, this is actually the end of
#the program. Place custom scripts in $m2kdir/userjobs/ with filename $jobtype.
exit_job(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "Called with $# arguments"
  local -i i=0; local var; for var in "$@"; do ((++i)); debugcont "arg $i = '${var}'"; done
  local jobtype="$1"
  local ERR_HEADER="${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}()."
  local -i exitstatus
  local -a notify_icon
  notify_icon[0]="$m2kdir/myth2kodi.png"
  notify_icon[1]="$m2kdir/myth2kodi_failed.png"

  case "$jobtype" in
    SuccessfulCommandLineSwitch)
      exitstatus=0
      ;;
    #Successful Completion of myth2kodi
    LinkModeSuccessful|MoveModeSuccessful|CopyModeSuccessful|FailSafeModeComplete)
      inform "SUCCESSFUL COMPLETION TYPE: $jobtype"
      exitstatus=0
      ;;
    #Information was not obtainable
    TheTVDBIsIncomplete|FileIsNotRecording)
      warn "INSUFFICIENT INFORMATION WAS SUPPLIED: $jobtype"
      exitstatus=0
      ;;
    #File system error occurred #TODO: clean-up...
    PermissionError|ZeroLengthFile|FileOrPathDoesNotExist|MoveFailed|CopyFailed|RemoveFailed|LinkingFailed|NoTargetPathAvailable|NotFileOrDirectory)
      err "$ERR_HEADER FILE SYSTEM ERROR: $jobtype"
      exitstatus=1
      ;;
    #File name we're trying to move to already exists
    FileAlreadyExists)
      err "$ERR_HEADER NOT MOVING RECORDING: $jobtype"
      exitstatus=1
      ;;
    #Generic error occurred
    GenericUnspecifiedError)
      err "$ERR_HEADER UNKNOWN ERROR OCCOURED: $jobtype"
      exitstatus=1
      ;;
    #
    MythTVdatabaseFailure)
      err "$ERR_HEADER FAILED WHILE ACCESSING MythTV-DB: $jobtype"
      exitstatus=1
      ;;
    #User elected not to process jobs which can not be properly categorized
    NameCouldNotBeAssigned)
      warn 'NAME COULD NOT BE ASSIGNED BASED UPON DATA SUPPLIED'
      exitstatus=1
      ;;
    #User elected to use a title/category ignore file
    titleIgnore|categoricIgnore)
      warn "Show was ignored based on $jobtype"
      exitstatus=0
      ;;
    #The invocation of myth2kodi had something wrong with it.
    InvalidCall|InputPathNotFile|InsufficientInformationProvided|UserSettingError)
      err "$ERR_HEADER myth2kodi called incorrectly: $jobtype"
      exitstatus=1
      ;;
    #Already processed
    RecordingAlreadyProcessed)
      warn "THE PROVIDED RECORDING HAS ALREADY BEEN PROCESSED, ABORTING."
      exitstatus=0
      ;;
    #Catch any incorrectly set exit types.
    *)
      warn "Unrecognised exit job type: '$jobtype'"
      exitstatus=1
      ;;
  esac

  #Send a desktop notification message if appropriate conditions are met.
  if [[ "$m2kScanMode" != 'True' && "$Notify" = 'Enabled' && -n "$NOTIFY_MSG" ]]; then
    debug "NOTIFY_MSG=$NOTIFY_MSG  ;  notify_icon=${notify_icon[$exitstatus]}"
    #Work-around for systems that don't allow users to sudo as themselves (Ubuntu).
    if [[ "$NotifyUserName" = "$CALLER" ]]; then
      "$binpath/m2k_notify" "myth2kodi: $jobtype" "$NOTIFY_MSG" "${notify_icon[$exitstatus]}"
    else
      sudo -u "$NotifyUserName" "$binpath/m2k_notify" "myth2kodi: $jobtype" "$NOTIFY_MSG" "${notify_icon[$exitstatus]}"
    fi
  else
    debug 'Either: Notify=Disabled; scan mode; recording is in an ignore list; or NOTIFY_MSG was not set.'
  fi

  #Final myth2kodi log entry when processing a recording, regardless of LOGLEVEL.
  if [[ "$PROCESSING_RECORDING" = 'True' ]]; then
    printf '%s\n' "@@@@ COMPLETE: $(date --rfc-3339=seconds) @@@@" >> "$LOGFILE"
  fi

  #TODO: Hacky fix to work around markupframes temp files we loose track of when processing fails...
  [[ -f "$MARKUPFRAMES_TMP" ]] && (( LOGLEVEL < 3 )) && rm -rf "$MARKUPFRAMES_TMP"

  #Some excessive logging for extra buggy bugs.
  ((LOGLEVEL>=13)) && env | err_pipe 'env:  '
  ((LOGLEVEL>=42)) && set | err_pipe 'set:  '

  #Define the ExitJob hierarchy, each exit type is a variable that points to its parent.
  #shellcheck disable=SC2034
  {
  declare -r ExitJob=''
    declare -r Success='ExitJob'
        declare -r SuccessfulCommandLineSwitch='Success'
        declare -r SuccessfulIgnore='Success'
            declare -r titleIgnore='SuccessfulIgnore'
            declare -r categoricIgnore='SuccessfulIgnore'
            declare -r DuplicateAvoided='SuccessfulIgnore'
                declare -r RecordingAlreadyProcessed='DuplicateAvoided'
                declare -r FileAlreadyExists='DuplicateAvoided'
        declare -r SuccessfulProcessing='Success'
            declare -r LinkModeSuccessful='SuccessfulProcessing'
            declare -r MoveModeSuccessful='SuccessfulProcessing'
            declare -r CopyModeSuccessful='SuccessfulProcessing'
            declare -r FailSafeModeComplete='SuccessfulProcessing'
    declare -r Failed='ExitJob'
        declare -r FailedCommandLineSwitch='Failed'
        declare -r FailedProcessing='Failed'
            declare -r BadCall='FailedProcessing'
                declare -r InvalidCall='BadCall'
                declare -r InputPathNotFile='BadCall'
                declare -r FileIsNotRecording='BadCall'
                declare -r UserSettingError='BadCall'
            declare -r InsufficientInformation='FailedProcessing'
                declare -r InsufficientInformationProvided='InsufficientInformation'
                declare -r TheTVDBIsIncomplete='InsufficientInformation'
                declare -r NameCouldNotBeAssigned='InsufficientInformation'
            declare -r SystemFailure='FailedProcessing'
                declare -r MythTVdatabaseFailure='SystemFailure'
                declare -r PermissionError='SystemFailure'
                declare -r ZeroLengthFile='SystemFailure'
                declare -r FileOrPathDoesNotExist='SystemFailure'
                declare -r MoveFailed='SystemFailure'
                declare -r CopyFailed='SystemFailure'
                declare -r RemoveFailed='SystemFailure'
                declare -r LinkingFailed='SystemFailure'
                declare -r NoTargetPathAvailable='SystemFailure'
                declare -r NotFileOrDirectory='SystemFailure'
        declare -r GenericUnspecifiedError='Failed'
  }

  #Run the most specific userjob that is defined for this EXIT_JOB_TYPE.
  while [[ -n "$jobtype" ]]; do
    debug "Checking for user job: '$m2kdir/userjobs/$jobtype'."
    if [[ -f "$m2kdir/userjobs/$jobtype" ]]; then
      inform "Processing user job: $m2kdir/userjobs/$jobtype"
      source "$m2kdir/userjobs/$jobtype" 2>&1 | err_pipe "${FUNCNAME[0]}(): $jobtype: "
      break
    fi
    debug "No user job: '$m2kdir/userjobs/$jobtype'."
    jobtype="${!jobtype}"
    [[ -z "$jobtype" ]] && debug 'There are no userjobs defined for this exit type.'
  done

  exit "$exitstatus"
} #exit_job()

#This is the first command executed after the setting of variables at the top
#of this file. It initialises the state of the script and the logging system.
m2k_init(){
  #Write a temp file every time we are called, useful to debug MythTV User Job issues.
  local -r pre_logging_file="/tmp/m2k_init_pre_logging_debug_$(whoami).txt"
  {
    printf '%s\n' "Entered ${FUNCNAME[0]}() -- $(date)"
    printf '%s\n' "Called with $M2KARG_COUNT arguments. Called as:"
    printf '%s\n' "  myth2kodi '$M2KARG1' \"$M2KARG2\" \"$M2KARG3\" \"$M2KARG4\" '$M2KARG5'"
    printf '%s\n' "Working directory: '$m2kdir'"
  } > "$pre_logging_file"

  #Override default settings with anything in myth2kodi.conf
  # shellcheck source=./myth2kodi.conf
  [[ -f "$m2kdir/myth2kodi.conf" ]] && source "$m2kdir/myth2kodi.conf"

  #Provide debugging info prior to the logging system's initialisation.
  ((LOGLEVEL>=3)) && printf '%s\n' "Config complete." >> "$pre_logging_file"

  #What am I...
  m2kVersion='myth2kodi Version 1.5.1c' ; declare -gr m2kVersion
  m2kPlatform="$(uname)" ; declare -gr m2kPlatform
  ((LOGLEVEL>=3)) && printf '%s\n' "Running $m2kVersion on $m2kPlatform." >> "$pre_logging_file"

  #Who called me...
  CALLER=$(whoami) ; declare -gr CALLER
  ((LOGLEVEL>=3)) && printf '%s\n' "Called by $CALLER." >> "$pre_logging_file"
  if [[ "$CALLER" != "$Librarian" ]]; then
    printf 'ERROR: %s\n' "myth2kodi should be run by user '$Librarian'"
    printf '  %s\n' "Check the USER SETTINGS section near the top of the script"
    printf '  %s\n' "you just ran or the settings file. That is, take a look at"
    printf '  %s\n' "the top few hundred lines of: ${BASH_SOURCE[0]}"
    printf '  %s\n' "or: $m2kdir/myth2kodi.conf"
    exit 1
  fi
  #Strongly recommend against running as root.
  if [[ "$EUID" = '0' || "$UID" = '0' || "$USER" = 'root' ]]; then
    local yesorno='no'
    printf 'WARNING: %s\n' "myth2kodi should NOT be run as root."
    printf '  %s\n' "myth2kodi has detected that you are running as"
    printf '  %s\n' "a privileged user. This may lead to permission"
    printf '  %s\n' "contamination of normally unprivileged files."
    printf '  %s\n' "Do not run this script with sudo."
    read -r -p "Possible permission contamination. Continue anyway? yes/(no)" yesorno
    printf '\n'
    #Default to safety, ie do nothing and exit with status 1.
    [[ "$yesorno" != 'yes' ]] && exit 1
    printf 'WARNING: %s\n' "Continuation forced by $CALLER, despite possible permission contamination."
  fi

  #And when...
  TODAY="$(date +%F)"  #Date in IEEE standard format, ie YYYY-mm-dd
  SCRIPT_START_TIME="$(date +%H:%M:%S)" #Time in a readable IEEE standard format, ie HH:MM:SS
  FILE_NAME_NOW="$(date +%FT%H%M%S)"  #ISO 8601: YYYY-mm-ddThhMMSS
  declare -gr TODAY
  declare -gr SCRIPT_START_TIME
  declare -gr FILE_NAME_NOW

  #The full path version of the file to which logging output will be sent.
  #Do not clobber LOGFILE on sub call to myth2kodi from --diagnostics.
  [[ -z "$LOGFILE" ]] && LOGFILE="$m2kdir/${LogFileName}.log"
  ((LOGLEVEL>=3)) && printf '%s\n' "LOGFILE set as '$LOGFILE'." >> "$pre_logging_file"

  #When running diagnostics mode, output will instead be sent to this file:
  DIAGNOSTICS_FILE="$m2kdir/diagnostics.log" ; declare -gr DIAGNOSTICS_FILE
  #A file containing a list of possible duplicate recordings:
  DuplicatesFile="$m2kdir/duplicates.log" ; declare -gr DuplicatesFile
  #A file containing a list of unrecognised recordings:
  UnrecognizedSeriesFile="$m2kdir/unrecognizedseries.log" ; declare -gr UnrecognizedSeriesFile

  #Make our working directory if it doesn't already exist
  ((LOGLEVEL>=3)) && printf '%s\n' "Checking if we need to make '$m2kdir'." >> "$pre_logging_file"
  if [[ ! -d "$m2kdir" ]]; then
    local createworkingdirstatus
    mkdir --parents "$m2kdir"
    createworkingdirstatus="$?"
    if [[ "$createworkingdirstatus" != 0 || ! -d "$m2kdir" ]]; then
      printf 'ERROR: %s\n' "Creation of our working directory failed... This needs to be corrected."
      printf '  %s\n' "First check that the user settings 'Librarian' and 'm2kdir' are correct."
      printf '  %s\n' "Then check that $Librarian has a home directory, if not create it, eg:"
      printf '    %s\n' "sudo mkdir /home/$Librarian"
      printf '    %s\n' "sudo chown -R $Librarian:users /home/$Librarian"
      printf '  %s\n' "Finally, be sure to run 'myth2kodi --diagnostics' before first use."
      exit 1
    fi
    initialise_new_logfile
    {
      printf 'Created Working Directory: %s\n' "$m2kdir"
      printf '  %s\n' 'If you intend to Enable desktop notifications'
      printf '  %s\n' "then you'll need to copy myth2kodi.png and"
      printf '  %s\n' "myth2kodi_failed.png into $m2kdir"
    } | tee -a "$LOGFILE"
  fi
  #In case we already had a working directory, but no log file.
  [[ ! -f "$LOGFILE" ]] && initialise_new_logfile

  #Initialise logging system
  ((LOGLEVEL>=3)) && printf '%s\n' 'Initialising logging system.' >> "$pre_logging_file"
  if [[ -f "$binpath/bashlogging" ]]; then
    # shellcheck source=./bashlogging
    if ! source "$binpath/bashlogging"; then exit 1; fi
  else
    printf 'ERROR: %s\n' "$binpath/bashlogging does not exist." | tee -a "$LOGFILE"
    exit 1
  fi
  ((LOGLEVEL>=3)) && printf '%s\n' "Logging system initialised, see '$LOGFILE'." >> "$pre_logging_file"

  #When the LOGFILE exceeds 4MB compress it and start a fresh one.
  log_rotation "$LOGFILE" "$m2kdir/${LogFileName}_${FILE_NAME_NOW}.log" '4000000'
  if [[ "$ARCHIVED_FILE" = 'True' ]]; then
   initialise_new_logfile
   inform "Previous LOGFILE moved to: $m2kdir/${LogFileName}_${FILE_NAME_NOW}.log"
  fi
  debug "LOGFILE=$LOGFILE-"
  debug "LOGLEVEL=$LOGLEVEL-"
  debug "LOGTYPE=$LOGTYPE-"

  #Do some basic validation of the settings
  if ! validate_settings; then return 1; fi

  #A regex that should match MythTV's file naming, for the 21st century.
  RECPATTERN='[0-9]{4}_20[0-9]{2}[0-1][0-9][0-3][0-9][0-2][0-9][0-5][0-9]{3}\.'
  declare -gr RECPATTERN

  # #A regex that will match our generated episode file naming.
  # EPPATTERN=' S[0-9][0-9]E[0-9][0-9] (.*)'
  # declare -gr EPPATTERN

  #Initialise confidence rating variables.
  declare -gi ConfidenceRating=0
  declare -gi SeriesConfidenceRating=0
  declare -gi EpisodeConfidenceRating=0

  #Initialise paths to our local-database summary files.
  M2K_DB_LIST_TITLE="$m2kdir/m2k_db_series_list_tvdb_title.txt"
  M2K_DB_LIST_TVDBID="$m2kdir/m2k_db_series_list_tvdb_id.txt"
  M2K_DB_LIST_TVMAZEID="$m2kdir/m2k_db_series_list_tvmaze_id.txt"
  declare -gr M2K_DB_LIST_TITLE M2K_DB_LIST_TVDBID M2K_DB_LIST_TVMAZEID

  #Make sure our series list is consistent (directories still present).
  prune_series_list

  [[ "$ONLINE_LOOKUP" != 'Disabled' ]] && get_tvdb_token #TODO: if ! get_tvdb_token; then return 1; fi

  debug "myth2kodi script initialisation complete."
  debug "Running myth2kodi as '$CALLER'"

  #Some excessive logging for extra buggy bugs.
  ((LOGLEVEL>=13)) && env | err_pipe 'env:  '
  ((LOGLEVEL>=42)) && set | err_pipe 'set:  '
  return 0
} #m2k_init()

#
parse_command_flags(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  EXIT_JOB_TYPE='SuccessfulCommandLineSwitch'
  #check for command line switches
  case "$M2KARG1" in

    --scan) #filetype /path/to/folder
      debug "Recognised command line switch '--scan'"
      #TODO: Add ability to scan only specific files, eg those for a specific TITLE
      export m2kScanMode='True'
      m2k_scan
      declare -i scanreturnstatus="$?"
      unset m2kScanMode
      return $scanreturnstatus
    ;;
    --movie) #/path/to/recording/filename.mpg
      debug "Recognised command line switch '--movie'"
      #Check the basic call was ok.
      if ((M2KARG_COUNT > 3)); then
        err "myth2kodi --movie takes at most 2 additional arguments: /path/to/filename.mpg and [title]."
        return 1
      elif ((M2KARG_COUNT == 1)); then
        err "myth2kodi --movie requires at least 1 additional argument: /path/to/filename.mpg."
        return 1
      fi
      #Force processing as a movie.
      export CATEGORY='Movie'
      myth2kodi "$M2KARG2" "$M2KARG3"
      declare -i m2kreturnstatus="$?"
      unset CATEGORY
      return $m2kreturnstatus
    ;;
    --diagnostics)
      debug "Recognised command line switch '--diagnostics'"
      export M2K_DIAGNOSTICS_MODE='True'
      local PreCallLogFile="$LOGFILE"
      local PreCallLogLevel="$LOGLEVEL"
      (( LOGLEVEL < 2 )) && LOGLEVEL=2 && inform "Escalating LOGLEVEL to Info (2)."
      if [[ "$LOGTYPE" = 'stderr' ]]; then
        warn "Running diagnostics without any logging to file, consider using LOGTYPE='filestderr'."
      else
        inform "Running diagnostics, so redirecting subsequent messages to $DIAGNOSTICS_FILE"
      fi
      export LOGFILE="$DIAGNOSTICS_FILE"
      m2k_diagnostics
      declare -i diagnosticsreturnstatus="$?"
      #Reset the LOGFILE & LOGLEVEL to previous state, in case we ever call
      # myth2kodi --diagnostics from within myth2kodi
      unset LOGFILE
      LOGFILE="$PreCallLogFile"
      #Move current diagnostics file to diagnostics_<Current Date&Time>.log
      debug "Moving '$DIAGNOSTICS_FILE' to '$m2kdir/diagnostics_${FILE_NAME_NOW}.log'"
      [[ -f "$DIAGNOSTICS_FILE" ]] && mv "$DIAGNOSTICS_FILE" "$m2kdir/diagnostics_${FILE_NAME_NOW}.log"
      if [[ "$LOGTYPE" != 'stderr' ]]; then
        inform "Finished running diagnostics, see '$m2kdir/diagnostics_${FILE_NAME_NOW}.log'."
      fi
      #Reset LOGLEVEL after 'Finished...' so it and 'Running...' are written consistently to LOGFILE.
      LOGLEVEL="$PreCallLogLevel"
      unset M2K_DIAGNOSTICS_MODE
      return $diagnosticsreturnstatus
    ;;
    --confidence)
      debug "Recognised command line switch '--confidence'"
      msg_improve_confidence
      return 0
    ;;
    --doover)
      debug "Recognised command line switch '--doover'"
      m2k_doover
      return $?
    ;;
    --delete)
      debug "Recognised command line switch '--delete'"
      switch_delete_recording "$M2KARG2"
      return $?
    ;;
    --rerecord)
      debug "Recognised command line switch '--rerecord'"
      RERECORD='Enabled'
      switch_delete_recording "$M2KARG2"
      return $?
    ;;
    --disconnect)
      debug "Recognised command line switch '--disconnect'"
      disconnect_recording "$M2KARG2"
      return $?
    ;;
    --log)
      debug "Recognised command line switch '--log'"
      recording_log "$M2KARG2"
      return $?
    ;;
    --unmanned_doover)
      debug "Recognised command line switch '--unmanned_doover'"
      declare -gi DoOverBypass=1
      m2k_doover
      return $?
    ;;
    --undo)
      debug "Recognised command line switch '--undo'"
      if [[ -z "$M2KARG2" ]]; then
        err 'myth2kodi --undo requires either "all" or a file name arg.'
        return 1
      elif [[ "${M2KARG2,,}" = 'all' ]]; then
        m2k_undo_all
        return $?
      elif [[ -f "$M2KARG2" ]]; then
        m2k_undo_rec "$M2KARG2"
        return $?
      else
        err 'Argument to --undo must be "all" or /path/to/filename.ext. Called as:'
        errcont "myth2kodi $M2KARG1 '$M2KARG2'"
        return 1
      fi
    ;;
    --series-info) #TITLE
      debug "Recognised command line switch '--series-info'"
      #Example usage: myth2kodi --series-info "Black Books"
      TITLE="$M2KARG2"
      #If ONLINE_LOOKUP is Disabled in settings we will not have a token yet.
      if [[ "$ONLINE_LOOKUP" != 'Enabled' ]]; then
        ONLINE_LOOKUP='Enabled'
        if ! get_tvdb_token; then return 1; fi
      fi
      if ! identify_series; then return 1; fi
      #If a lastupdated.time file exists then remove it to force an update.
      local last_updated_file="$m2kdir/$TVDB_TITLE/lastupdated.time"
      [[ -f "$last_updated_file" ]] && rm -f "$last_updated_file"
      get_series_info
      return $?
    ;;
    --recording-info) #recording_filename
      debug "Recognised command line switch '--recording-info'"
      #Example usage: myth2kodi --recording-info "1070_20160331073100.mpg"
      inform "Attempting to access recording info for: $M2KARG2"
      if ! set_recording_name "$M2KARG2"; then return 1; fi
      INPUT_PATH_BASENAME="$RECORDING_NAME"
      TITLE=''
      if ! process_mythtvdb; then return 1; fi
      msg_recording_info
      (( LOGLEVEL < 3 )) && rm -rf "$MARKUPFRAMES_TMP"
      return 0
    ;;
    --about)
      debug "Recognised command line switch '--about'"
      msg_about
      return 0
    ;;
    --usage)
      debug "Recognised command line switch '--usage'"
      msg_usage
      return 0
    ;;
    --help|-h)
      debug "Recognised command line switch '--help|-h'"
      msg_about
      msg_usage
      msg_options
      return 0
    ;;
    --maintenance)
      debug "Recognised command line switch '--maintenance'"
      if ! maintenance_warning ; then return 1; fi
      declare -gi removedead=1
      m2k_maintenance
      return $?
    ;;
    --cleanse)
      debug "Recognised command line switch '--cleanse'"
      if ! cleanse_warning ; then return 1; fi
      m2k_cleanse
      return $?
    ;;
    --config-help)
      debug "Recognised command line switch '--config-help'"
      msg_config
      msg_rss
      return 0
    ;;
    --version)
      debug "Recognised command line switch '--version'"
      printf '%s\n' "$m2kVersion"
      return 0
    ;;
    --comskip) #/path/to/recording/filename.mpg | /path/to/recordings & [ext]
      debug "Recognised command line switch '--comskip'"
      recreate_comskip "$M2KARG2" "$M2KARG3"
      return $?
    ;;
  esac

  NOTIFY_MSG="Unrecognised command line switch: $M2KARG1"
  err "${FUNCNAME[0]}(): $NOTIFY_MSG"
  msg_usage
  EXIT_JOB_TYPE='UnrecognisedCommand'
  return 1
} #parse_command_flags()

#Initialises a new log file with creation information -- can be run before
#the logging system is initialised.
initialise_new_logfile(){
  touch "$LOGFILE"
  {
    printf 'Creating Log File: %s\n' "$LOGFILE"
    printf 'Created on %s at %s\n' "$TODAY" "$SCRIPT_START_TIME"
  } >> "$LOGFILE"
} #initialise_new_logfile()

######################## TESTING & CHECKING FUNCTIONS ########################

#Check for incompatible or inadvisable setting combinations, or just wrong
#settings, such as directory settings that aren't directories and then warn or
#err and abort as appropriate.
validate_settings(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #TODO: Consider: When it counts as an error we should abort.

  #A local reusable message variable
  local msg

  #Check all Enabled|Disabled switches are set correctly.
  local -a switch_user_settings
  switch_user_settings=( 'CommercialMarkup' 'CommercialMarkupCleanup' 'CREATE_RSS' \
                         'DailyReport' 'Database' 'DIR_TRACKING_CLEANUP'           \
                         'FailSafeMode' 'FORCE_PROCESS' 'KODIClean' 'KODINotify'   \
                         'KODIUpdate' 'MATCH_ORIGINALAIRDATE' 'MATCH_PLOT'         \
                         'MATCH_SEASON_EPISODE' 'MATCH_SUBTITLE' 'Notify'          \
                         'ONLINE_LOOKUP' 'ShowStopper' 'StorageGroupFallback'      \
                         'SYMLINK' 'TargetPathIsInputPath' 'TRACKING' 'GROUP_BY_RECGROUP' )
  msg="is expected to be set as either 'Enabled' or 'Disabled'."
  for var in "${switch_user_settings[@]}"; do
    [[ "${!var}" =~ ^(Enabled|Disabled)$ ]] || err "$var $msg"
  done

  msg="PROCESS_RECORDING_MODE is expected to be set as one of ['MOVE'|'LINK'|'COPY']."
  [[ "$PROCESS_RECORDING_MODE" =~ ^(MOVE|LINK|COPY|HARDLINK)$ ]] || err "$msg"

  msg="DATABASE_ACCESS is expected to be set as either 'PythonBindings' or 'MySQL'."
  [[ "$DATABASE_ACCESS" =~ ^(PythonBindings|MySQL)$ ]] || err "$msg"

  msg="Processing in COPY mode without FORCE_PROCESS='Enabled' will not copy already processed recordings."
  [[ "$PROCESS_RECORDING_MODE" = 'COPY' && "$FORCE_PROCESS" != 'Enabled' ]] &&  warn "$msg"

  #Check that all user set directories are, in fact, directories.
  msg='is not a directory:'
  [[ -d "$m2kdir" ]]            || err "'m2kdir' $msg $m2kdir"
  [[ -d "$binpath" ]]           || err "'binpath' $msg $binpath"
  [[ -d "$M2K_TMPDIR" ]]        || err "'M2K_TMPDIR' $msg $M2K_TMPDIR"
  [[ -d "$MoveDir" ]]           || err "'MoveDir' $msg $MoveDir"
  [[ -d "$AlternateMoveDir" ]]  || err "'AlternateMoveDir' $msg $AlternateMoveDir"
  [[ -d "$PrimaryMovieDir" ]]   || err "'PrimaryMovieDir' $msg $PrimaryMovieDir"
  [[ -d "$AlternateMovieDir" ]] || err "'AlternateMovieDir' $msg $AlternateMovieDir"
  [[ -d "$PrimaryShowDir" ]]    || err "'PrimaryShowDir' $msg $PrimaryShowDir"
  [[ -d "$AlternateShowDir" ]]  || err "'AlternateShowDir' $msg $AlternateShowDir"
  [[ -d "$FailSafeDir" ]]       || err "'FailSafeDir' $msg $FailSafeDir"

  #TODO: Consider running check_path_permission() here for all configured directories...
  #      May need to skip validate_settings call in m2k_init when called as 'myth2kodi --diagnostics'.
  #Check that we have the required permissions to all configured directories.
  # check_path_permission "$m2kdir"     "rwx"
  # check_path_permission "$M2K_TMPDIR" "rwx"
  # check_path_permission "$binpath"    "rx"
  # local origdir_permissions
  # [[ "$PROCESS_RECORDING_MODE" =~ ^(LINK|COPY)$ ]] && origdir_permissions='rx'
  # [[ "$PROCESS_RECORDING_MODE" = 'MOVE' ]] && origdir_permissions='rwx'
  # #TODO: originaldir not set when this is called... ?move elsewhere?
  # local target_permissions='rwx'
  # check_path_permission "$MoveDir"           "$target_permissions"
  # check_path_permission "$AlternateMoveDir"  "$target_permissions"
  # check_path_permission "$PrimaryMovieDir"   "$target_permissions"
  # check_path_permission "$AlternateMovieDir" "$target_permissions"
  # check_path_permission "$PrimaryShowDir"    "$target_permissions"
  # check_path_permission "$AlternateShowDir"  "$target_permissions"
  # check_path_permission "$FailSafeDir"       "$target_permissions"

  #Discourage excessive load on TheTVDB.
  msg="Do not update from TheTVDB more than once per day, ie set UpdateDatabase>=86400."
  ((UpdateDatabase < 86400)) && err "$msg"

  #PROCESS_RECORDING_MODE='LINK' and SYMLINK='Disabled' are incompatible
  if [[ "$PROCESS_RECORDING_MODE" = 'LINK' && "$SYMLINK" != 'Enabled' ]]; then
    NOTIFY_MSG="Using LINK mode processing without 'SYMLINK'ing set as 'Enabled' does not make sense."
    err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
    EXIT_JOB_TYPE='UserSettingError'
    return 1
  fi
  return 0
} #validate_settings()

#Do some basic tests to make sure we were called correctly
validate_args(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #TODO: Review/Expand the checks of whether we were called correctly.

  debug "Called with $M2KARG_COUNT arguments. Called as:"
  debugcont "myth2kodi '$M2KARG1' \"$M2KARG2\" \"$M2KARG3\" \"$M2KARG4\" '$M2KARG5'"

  #We need at least one arg
  if [[ -z "$M2KARG1" ]]; then
    NOTIFY_MSG='myth2kodi must be called with at least one argument.'
    err "${FUNCNAME[0]}(): $NOTIFY_MSG"
    msg_usage
    EXIT_JOB_TYPE='InvalidCall'
    return 1
  fi

  #Called at command line with MythTV user job form.
  if [[ "$M2KARG1" = '%DIR%/%FILE%' ]]; then
    msg_userjob_outside_mythtv_error
    return 1
  fi

  #Validations that only apply when our first argument is not a switch.
  if [[ "${M2KARG1:0:1}" != '-' ]]; then

    #Our first argument must be a file.
    if [[ ! -f "$M2KARG1" ]]; then
      NOTIFY_MSG='The specified INPUT_PATH is not a file.'
      err "${FUNCNAME[0]}(): $NOTIFY_MSG."
      msg_invalid_path_error "$M2KARG1"
      EXIT_JOB_TYPE='InputPathNotFile'
      return 1
    fi

    #Check that we have the necessary permissions for INPUT_PATH.
    if [[ "$PROCESS_RECORDING_MODE" =~ ^('LINK'|'COPY'|'HARDLINK')$ ]]; then
      if ! check_path_permission "$M2KARG1" 'r'; then return 1; fi
    else
      if ! check_path_permission "$M2KARG1" 'rw'; then return 1; fi
    fi

    #Do not reprocess a recording we already processed, unless forced to.
    if [[ "$FORCE_PROCESS" != 'Enabled' ]]; then
      if ! pre_process_check "$M2KARG1"; then return 1; fi
    fi

    #Setting Season or Episode number without setting both is of no use.
    if [[ ( -n "$M2KARG4" || -n "$M2KARG5" ) && ! ( -n "$M2KARG4" && -n "$M2KARG5" ) ]]; then
      warn "Setting Season or Episode number but not both is of no use ('$M2KARG4', '$M2KARG5')."
    fi

  fi
  debug "Arguments seem valid."
  return 0
} #validate_args()

#Given a file to process, returns 1 if it's not actually a MythTV recording
#file or if we have already processed it, otherwise returns 0.
pre_process_check(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "arg1: '$1'"
  #Takes a single argument
  (( "$#" > 1 )) && { err "${FUNCNAME[0]}() only takes one arg."; return 1; }
  local file_path="$1"
  [[ -f "$file_path" ]] || { err "${FUNCNAME[0]}(): Not a file: $file_path"; return 1; }
  local file_basename
  file_basename="${file_path##*/}"

  #Is file_path named like a MythTV recording, or is there enough info to process without MythTV-DB.
  if [[ "$file_basename" =~ ^$RECPATTERN ]]; then #NOTE: Don't quote the RHS
    debug "Looks ok, file_path is named like a MythTV recording: '$file_path'"
  elif [[ -n "$M2KARG2" ]]; then
    warn "${FUNCNAME[0]}(): This does not look like a MythTV recording: '$file_path'"
    debug "M2KARG2:'$M2KARG2'"
    if [[ -n "$M2KARG3" ]] || [[ -n "$M2KARG4" && -n "$M2KARG5" ]]; then
      inform "But we seem to have enough info from the command line to process it as an episode."
      debug "M2KARG3:'$M2KARG3'"
      debug "M2KARG4:'$M2KARG4'"
      debug "M2KARG5:'$M2KARG5'"
      debug "Setting  Database='Disabled'"
      [[ "$Database" = 'Enabled' ]] && inform "Disabling access to MythTV-DB -- trying to process non-MythTV file."
      RECORDING_TYPE='EP'
      Database='Disabled'
      debug "Setting  TRACKING='Disabled'"
      TRACKING='Disabled'
    elif [[ "$CATEGORY" = 'Movie' ]]; then
      inform "But we seem to have enough info from the command line to process it as a movie."
      [[ "$Database" = 'Enabled' ]] && inform "Disabling access to MythTV-DB -- trying to process non-MythTV file."
      RECORDING_TYPE='MV'
      Database='Disabled'
      debug "Setting  TRACKING='Disabled'"
      TRACKING='Disabled'
    else
      NOTIFY_MSG="This does not look like a MythTV recording: '$file_path'"
      err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
      EXIT_JOB_TYPE='FileIsNotRecording'
      return 1
    fi
  else
    NOTIFY_MSG="This does not look like a MythTV recording: '$file_path'"
    err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
    EXIT_JOB_TYPE='FileIsNotRecording'
    return 1
  fi

  #Has file_path already been processed
  if [[ -L "$file_path" ]]; then #it's already processed
    NOTIFY_MSG="We've already processed this recording: $file_path => $(readlink "$file_path")"
    err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
    EXIT_JOB_TYPE='RecordingAlreadyProcessed'
    return 1
  else #check if it was processed in LINK mode
    if ! RECORDING_FILE="$(realpath "$file_path" 2> >(err_pipe "ERROR: ${FUNCNAME[0]}(): Line $LINENO: "))"; then return 1; fi
    local -i found=1 #We'll be trying to find a link: 0=success; 1=failure.
    local -a check_dirs
    local link_name
    check_dirs=("$MoveDir" "$PrimaryMovieDir" "$PrimaryShowDir" "$AlternateMoveDir" "$AlternateMovieDir" "$AlternateShowDir")
    for check_dir in "${check_dirs[@]}" ; do
      link_name="$(find -L "$check_dir" -samefile "$RECORDING_FILE" 2> >(err_pipe "ERROR: ${FUNCNAME[0]}(): Line $LINENO: "))"
      [[ -L "$link_name" ]] && { found=0 ; break ; }
    done
    if (( found == 0 )); then
      NOTIFY_MSG="We've already processed this recording: $link_name => $RECORDING_FILE."
      err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
      EXIT_JOB_TYPE='RecordingAlreadyProcessed'
      return 1
    fi
  fi
  return 0
} #pre_process_check()

#Check write permission and free space, return 0 (writeable) or 1 (not).
#Takes 3 args: $1=filesize ; $2=freespace ; $3=directory
check_write(){
  #TODO: Do we really need to write a dummy file here??? Wouldn't file comparisons using -e -d -r -w etc be sufficient...
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "Called with $# arguments"
  local -i i=0 ; local var ; for var in "$@"; do ((++i)) ; debugcont "arg $i = '${var}'" ; done
  if [[ -n "$2" ]]; then
    if [[ -n "$1" ]]; then
      if [[ -d "$3" ]]; then
        if (($1 < $2)); then
          printf '%s\n' "Testing write permission on $3" > "$3/arbitraryfile.ext"
          if [[ -f "$3/arbitraryfile.ext" ]]; then
            if [[ -s "$3/arbitraryfile.ext" ]]; then
              rm -f "$3/arbitraryfile.ext"
              if [[ ! -f "$3/arbitraryfile.ext" ]]; then return 0 ; else return 1; fi
            else
              err "${FUNCNAME[0]}(): CREATED $3/arbitraryfile.ext BUT COULD NOT WRITE DATA INTO THE FILE"
              return 1
            fi
          else
            err "${FUNCNAME[0]}(): $CALLER TRIED TO WRITE TO $3 --FAILED"
            [[ ! -r "$3" ]] && inform "QUICK FIX: sudo chmod a+r '$3'"
            [[ ! -w "$3" ]] && inform "QUICK FIX: sudo chmod a+w '$3'"
            inform "QUICK FIX: sudo chown $CALLER '$3'"
          fi
        elif [[ -z "$2" ]] || (( $1 >= $2 )); then
          err "${FUNCNAME[0]}(): INSUFFICIENT FREE SPACE ON '$3'"
          inform "QUICK FIX: Remove unnecessary files"
          return 1
        fi
      else
        err "${FUNCNAME[0]}(): FOLDER DOES NOT EXIST: '$3'"
        inform "QUICK FIX: mkdir '$3'"
      fi
    else
      warn "${FUNCNAME[0]}(): COULD NOT READ FILESIZE ON $RECORDING_PATH" #TODO: This message isn't valid for the current wider use of check_write().
      inform "QUICK FIX: chmod -R 775 '$RECORDING_PATH'"
    fi
  else
    warn "${FUNCNAME[0]}(): COULD NOT READ FREE SPACE on '$3'"
    inform "QUICK FIX: mkdir '$3' ; chmod -R 775 '$3'"
  fi

  return 1
} #check_write()

#Check to see if a path/file is owned by $Librarian or at least that $Librarian
#has sufficient read-write permissions. If not, exit with a descriptive message.
check_path_permission(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "path_to_check = '$1'"
  debugcont "required_permission = '$2'"
  (( "$#" > 2 )) && err "${FUNCNAME[0]}() only takes two args."
  local path_to_check
  local required_permission
  local path_owner
  local path_group
  path_to_check="$1"
  if [[ -n "$2" ]]; then
    required_permission="$2"
  else #If not specified, assume all permissions are required.
    debug "Setting required_permission='rwx'"
    required_permission='rwx'
  fi
  debug "Checking '$required_permission' permissions for: '$path_to_check'"

  #First check that the file or path actually exists
  if [[ ! -e "$path_to_check" ]]; then
    NOTIFY_MSG="Path or file does not exist: $path_to_check"
    err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
    EXIT_JOB_TYPE='FileOrPathDoesNotExist'
    return 1
  fi

  #Make sure it is either a file or directory
  if [[ ! -f "$path_to_check" ]]; then
    if [[ ! -d "$path_to_check" ]]; then
      NOTIFY_MSG="Path or file is neither a file nor a directory: $path_to_check"
      err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
      EXIT_JOB_TYPE='NotFileOrDirectory'
      return 1
    fi
  fi

  #Who owns this thing
  path_owner="$(find "$path_to_check" -maxdepth 0 -printf %u 2> >(err_pipe "ERROR: ${FUNCNAME[0]}(): Line $LINENO: "))"
  path_group="$(find "$path_to_check" -maxdepth 0 -printf %g 2> >(err_pipe "ERROR: ${FUNCNAME[0]}(): Line $LINENO: "))"

  #Log some ownership related info
  if [[ "$path_owner" = "$Librarian" ]]; then
    debug "Good start: '$Librarian' owns it."
  elif id -nG "$Librarian" | grep -qw "$path_group"; then
    debug "May be ok: '$Librarian' is at least a member of the same group."
  else
    warn "${FUNCNAME[0]}(): '$Librarian' neither owns nor is a member of the group for '$path_to_check'."
  fi

  #If we require read permission then check for it
  if [[ "$required_permission" = *'r'* && ! -r "$path_to_check" ]]; then
    NOTIFY_MSG="Cannot read: $path_to_check"
    err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
    EXIT_JOB_TYPE='PermissionError'
    return 1
  fi

  #If we require read permission then check for it
  if [[ "$required_permission" = *'w'* && ! -w "$path_to_check" ]]; then
    NOTIFY_MSG="Cannot write: '$path_to_check'"
    err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
    errcont "USER NAME:'$CALLER' ATTEMPTED TO MODIFY A '$path_owner' OWNED FILE."
    errcont "To preserve file permissions this has been prevented."
    EXIT_JOB_TYPE='PermissionError'
    return 1
  fi

  #If we require execution permission then check for it
  if [[ "$required_permission" = *'x'* && ! -x "$path_to_check" ]]; then
    if [[ -f "$path_to_check" ]]; then
      NOTIFY_MSG="Cannot execute: '$path_to_check'"
      err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
      EXIT_JOB_TYPE='PermissionError'
    elif [[ -d "$path_to_check" ]]; then
      NOTIFY_MSG="Directories need to be executable for access: '$path_to_check'"
      err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
      EXIT_JOB_TYPE='PermissionError'
    fi
    return 1
  fi

  #If we have made it this far then all is well
  debug "Permissions ok for: '$path_to_check'"
  return 0
} #check_path_permission()

check_filesystem(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local filesystem_write_state=0
  #Get file size for the recording we are processing.
  if [[ -f "$RECORDING_PATH" ]]; then #Not test_file
    MoveFileSize=$(wc --bytes < "$RECORDING_PATH")
  else
    MoveFileSize=1000000000 #default to ~1GB for diagnostics.
  fi
  MoveFileSize=$((MoveFileSize/1048576)) #Convert from Bytes to MB

  #Determine the free space available in all the directories we might use.
  WorkingDirFreeSpace=$(df -P "$m2kdir"             | sed -n 2p | awk '{print $4}') || WorkingDirFreeSpace=0
  TempDirFreeSpace=$(df -P "$M2K_TMPDIR"            | sed -n 2p | awk '{print $4}') || TempDirFreeSpace=0
  OriginalDirFreeSpace=$(df -P "$ORIGINAL_DIRNAME"  | sed -n 2p | awk '{print $4}') || OriginalDirFreeSpace=0
  MoveDirFreeSpace=$(df -P "$MoveDir"               | sed -n 2p | awk '{print $4}') || MoveDirFreeSpace=0
  AltMoveDirFreeSpace=$(df -P "$AlternateMoveDir"   | sed -n 2p | awk '{print $4}') || AltMoveDirFreeSpace=0
  MovieDirFreeSpace=$(df -P "$PrimaryMovieDir"      | sed -n 2p | awk '{print $4}') || MovieDirFreeSpace=0
  AltMovieDirFreeSpace=$(df -P "$AlternateMovieDir" | sed -n 2p | awk '{print $4}') || AltMovieDirFreeSpace=0
  ShowDirFreeSpace=$(df -P "$PrimaryShowDir"        | sed -n 2p | awk '{print $4}') || ShowDirFreeSpace=0
  AltShowDirFreeSpace=$(df -P "$AlternateShowDir"   | sed -n 2p | awk '{print $4}') || AltShowDirFreeSpace=0

  #Convert from kB to MB
  WorkingDirFreeSpace="$((WorkingDirFreeSpace/1024))"
  TempDirFreeSpace="$((TempDirFreeSpace/1024))"
  OriginalDirFreeSpace="$((OriginalDirFreeSpace/1024))"
  MoveDirFreeSpace="$((MoveDirFreeSpace/1024))"
  AltMoveDirFreeSpace="$((AltMoveDirFreeSpace/1024))"
  MovieDirFreeSpace="$((MovieDirFreeSpace/1024))"
  AltMovieDirFreeSpace="$((AltMovieDirFreeSpace/1024))"
  ShowDirFreeSpace="$((ShowDirFreeSpace/1024))"
  AltShowDirFreeSpace="$((AltShowDirFreeSpace/1024))"

  #Check write permissions and sufficiency of free space.
  check_write "$MoveFileSize" "$MoveDirFreeSpace"     "$MoveDir"
  MoveDirWritable="$?" ; ((filesystem_write_state+=MoveDirWritable))
  check_write "$MoveFileSize" "$AltMoveDirFreeSpace"  "$AlternateMoveDir"
  AltMoveDirWritable="$?" ; ((filesystem_write_state+=AltMoveDirWritable))
  check_write "$MoveFileSize" "$MovieDirFreeSpace"    "$PrimaryMovieDir"
  MovieDirWritable="$?" ; ((filesystem_write_state+=MovieDirWritable))
  check_write "$MoveFileSize" "$AltMovieDirFreeSpace" "$AlternateMovieDir"
  AltMovieDirWritable="$?" ; ((filesystem_write_state+=AltMovieDirWritable))
  check_write "$MoveFileSize" "$ShowDirFreeSpace"     "$PrimaryShowDir"
  ShowDirWritable="$?" ; ((filesystem_write_state+=ShowDirWritable))
  check_write "$MoveFileSize" "$AltShowDirFreeSpace"  "$AlternateShowDir"
  AltShowDirWritable="$?" ; ((filesystem_write_state+=AltShowDirWritable))
  if [[ "$PROCESS_RECORDING_MODE" = 'MOVE' ]]; then
    check_write "1"           "$OriginalDirFreeSpace" "$ORIGINAL_DIRNAME"
    OriginalDirWritable="$?" ; ((filesystem_write_state+=OriginalDirWritable))
  else #Unknown as we won't check, the other modes don't require it.
    OriginalDirWritable='?' #This is intentionally the '?' symbol and not "$?".
  fi
  check_write "5"             "$WorkingDirFreeSpace"  "$m2kdir"
  WorkingDirWritable="$?" ; ((filesystem_write_state+=WorkingDirWritable))
  check_write "5"             "$TempDirFreeSpace"  "$M2K_TMPDIR"
  TempDirWritable="$?" ; ((filesystem_write_state+=TempDirWritable))

  debug "filesystem_write_state='$filesystem_write_state'"
  ((filesystem_write_state != 0)) && return 1
  return 0
} #check_filesystem()

#Assuming the provided argument is a recording file successfully processed in
#LINK mode or MOVE mode with SYMLINKing Enabled, identify the file, the link,
#who owns what, and the MythTV recording path and name.
identify_recording_files(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local inputarg="$1"
  if [[ -f "$inputarg" ]]; then
    #Find the recording file and any link to it.
    if ! find_file_link_pairs "$inputarg"; then return 1; fi
    debug "RECORDING_LINK: '$RECORDING_LINK'"
    debug "RECORDING_LINK_OWNER: '$RECORDING_LINK_OWNER'"
    debug "RECORDING_FILE: '$RECORDING_FILE'"
    debug "RECORDING_FILE_OWNER: '$RECORDING_FILE_OWNER'"

    #Find the MythTV recording file name and its path.
    if ! set_recording_name "$inputarg"; then return 1; fi
    debug "RECORDING_PATH: '$RECORDING_PATH'"
    debug "RECORDING_NAME: '$RECORDING_NAME'"
    INPUT_PATH_BASENAME="$RECORDING_NAME"
  else
    EXIT_JOB_TYPE='FileOrPathDoesNotExist'
    NOTIFY_MSG="Provided argument is not a file: '$inputarg'"
    err "${FUNCNAME[0]}(): $NOTIFY_MSG"
    return 1
  fi
  return 0
} #identify_recording_files()

#Given a recording file or link find the associated link or file.
#Full paths are returned via RECORDING_FILE and RECORDING_LINK variables.
#It's possible to get RECORDING_LINK='' if recording is disconnected from MythTV.
find_file_link_pairs(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "arg1: $1"
  #Takes a single argument
  (( "$#" > 1 )) && { err "${FUNCNAME[0]}() only takes one arg."; return 1 ; }
  local file_path="$1"
  [[ -e "$file_path" ]] || { err "${FUNCNAME[0]}(): Does not exist: '$file_path'"; return 1; }
  #Is file_path a link or a file
  if [[ -L "$file_path" ]]; then
    #file_path is a link, grab its target. #TODO: maybe "$(realpath --strip "$file_path")" ~ "$(cd "$(dirname "$file_path")" ; pwd)"
    if ! RECORDING_LINK="$(realpath --strip "$file_path" 2> >(err_pipe "ERROR: ${FUNCNAME[0]}(): Line $LINENO: "))"; then return 1; fi
    if ! RECORDING_FILE="$(readlink "$file_path" 2> >(err_pipe "ERROR: ${FUNCNAME[0]}(): Line $LINENO: "))"; then return 1; fi
    [[ -f "$RECORDING_FILE" ]] || { err "${FUNCNAME[0]}(): Broken link: $RECORDING_FILE"; return 1; }
    [[ -L "$RECORDING_FILE" ]] && { err "${FUNCNAME[0]}(): Multiple links, not following: $RECORDING_FILE"; return 1; }
    if [[ "${RECORDING_FILE##*/}" =~ ^$RECPATTERN ]]; then #NOTE: Don't quote the RHS.
      RECORDING_FILE_OWNER='MythTV'
      RECORDING_LINK_OWNER='myth2kodi'
    elif [[ "${RECORDING_LINK##*/}" =~ ^$RECPATTERN ]]; then #NOTE: Don't quote the RHS.
      RECORDING_FILE_OWNER='myth2kodi'
      RECORDING_LINK_OWNER='MythTV'
    #else
    #  debug "This must be a non-MythTV file, so assuming the file we were provided is the effective MythTV file."
    #  RECORDING_FILE_OWNER='myth2kodi'
    #  RECORDING_LINK_OWNER='MythTV'
    fi
    return 0
  elif [[ -f "$file_path" ]]; then
    #file_path is a file, #TODO: realpath == readlink -f
    if ! RECORDING_FILE="$(realpath "$file_path" 2> >(err_pipe "ERROR: ${FUNCNAME[0]}(): Line $LINENO: "))"; then return 1; fi
    local -i found=1 #Use exit code convention of 0=success 1=failure.
    local -a check_dirs
    local link_name
    if [[ "${RECORDING_FILE##*/}" =~ ^$RECPATTERN ]]; then #NOTE: Don't quote the RHS.
      #file_path is a MythTV file name, check if there is a link to file_path from a myth2kodi target directory
      RECORDING_FILE_OWNER='MythTV'
      RECORDING_LINK_OWNER='myth2kodi'
      check_dirs=("$MoveDir" "$PrimaryMovieDir" "$PrimaryShowDir" "$AlternateMoveDir" "$AlternateMovieDir" "$AlternateShowDir")
    else #elif [[ "$Database" = 'Enabled' ]]; then #&& "${RECORDING_FILE##*/}" =~ ^$EPPATTERN  #TODO: Missing movie pattern for this to work.
      #file_path is a moved file name, check if there is a link to file_path from a MDB_STORAGEGROUP Directory
      RECORDING_FILE_OWNER='myth2kodi'
      RECORDING_LINK_OWNER='MythTV'
      if ! get_mythtvdb_storagegroups; then return 1; fi
      check_dirs=("${STORAGEGROUP_DIRS[@]}")
    #else
    #  debug "This must be a non-MythTV file, so assuming the file we were provided is the effective MythTV file."
    #  RECORDING_FILE_OWNER='MythTV'
    #  RECORDING_LINK_OWNER='myth2kodi'
    #  check_dirs=("$MoveDir" "$PrimaryMovieDir" "$PrimaryShowDir" "$AlternateMoveDir" "$AlternateMovieDir" "$AlternateShowDir")
    fi
    #if [[ -n "${check_dirs[@]}" ]]; then
    for check_dir in "${check_dirs[@]}" ; do
      link_name="$(find -L "$check_dir" -samefile "$RECORDING_FILE" 2> >(err_pipe "ERROR: ${FUNCNAME[0]}(): Line $LINENO: "))"
      [[ -L "$link_name" ]] && { found=0 ; break ; }
    done
    #fi
    #TODO: realpath may be heading toward deprecation, so maybe: "$(cd "$(dirname "$link_name")" ; pwd)". THough not sure about the robustness of dirname here...
    if (( found == 0 )); then
      if ! RECORDING_LINK="$(realpath --strip "$link_name" 2> >(err_pipe "ERROR: ${FUNCNAME[0]}(): Line $LINENO: "))"; then return 1; fi
      return 0
    fi
    if [[ ! "${RECORDING_FILE##*/}" =~ ^$RECPATTERN ]]; then
      warn "${FUNCNAME[0]}(): No link found to: '$RECORDING_FILE'"
      warncont "Assuming recording has been disconnected from MythTV."
      RECORDING_LINK=''
      return 0
    fi
    warn "${FUNCNAME[0]}(): Cannot find link to: '$RECORDING_FILE'"
    warncont "This probably means that the file was not successfully processed by myth2kodi."
    RECORDING_LINK=''
    return 0
  else
    err "${FUNCNAME[0]}(): Not a file or link: $file_path"
    return 1
  fi
} #find_file_link_pairs()

#Sets the RECORDING_NAME variable. If the arg is a MythTV recording file then
#it just sets as basename, if given a myth2kodi moved name then, if possible,
#we find the corresponding MythTV recording name.
set_recording_name(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "arg1: '$1'"
  local file_name="$1"
  #Takes a single argument
  (( "$#" > 1 )) && { err "${FUNCNAME[0]}() only takes one arg."; return 1 ; }
  local -i found=1 #Use exit code convention of: 0=success; 1=failure.
  if [[ "${file_name##*/}" =~ ^$RECPATTERN ]]; then #NOTE: Don't quote the RHS.
    #Is a MythTV recording.
    found=0
    RECORDING_NAME="$file_name"
  else
    #In this case we need a full or relative path
    [[ -f "$file_name" ]] || { err "${FUNCNAME[0]}(): arg1 is not a file."; return 1; }
    # if [[ "$Database" = 'Enabled' ]]; then #&& "${RECORDING_FILE##*/}" =~ ^$EPPATTERN  #TODO: Missing movie pattern for this to work.
    #Get the storage group directories defined in MythTV-DB
    if ! get_mythtvdb_storagegroups; then return 1; fi
    #Check if it's a moved file name that's still tracked by MythTV
    for sg_dir in "${STORAGEGROUP_DIRS[@]}" ; do
      RECORDING_NAME="$(find -L "$sg_dir" -samefile "$file_name" 2> >(err_pipe "ERROR: ${FUNCNAME[0]}(): Line $LINENO: "))"
      [[ "${RECORDING_NAME##*/}" =~ ^$RECPATTERN ]] && { found=0 ; break ; }
    done
    (( found == 0 )) && inform "$file_name <==> $RECORDING_NAME"
    #else
    #  debug "This must be a non-MythTV file, so assuming the file we were provided is the effective MythTV file."
    #  RECORDING_NAME="$file_name"
    #  found=0
    #fi
  fi
  if (( found == 0 )); then
    if ! RECORDING_PATH="$(realpath --strip "$RECORDING_NAME" 2> >(err_pipe "ERROR: ${FUNCNAME[0]}(): Line $LINENO: "))"; then return 1; fi
    if ! RECORDING_NAME="$(basename "$RECORDING_NAME" 2> >(err_pipe "ERROR: ${FUNCNAME[0]}(): Line $LINENO: "))"; then return 1; fi
    debug "Setting RECORDING_PATH='$RECORDING_PATH'"
    debug "Setting RECORDING_NAME='$RECORDING_NAME'"
    return 0
  else
    err "${FUNCNAME[0]}(): Failed to find MythTV-DB recording name for: $1"
    return 1
  fi
} #set_recording_name()

########################### MAINTENANCE FUNCTIONS ############################

#When a file exceeds a specified size, give it an archive name and compress it.
log_rotation(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local file_name archive_name
  local -i file_size_limit
  file_name="$1"
  archive_name="$2"
  file_size_limit="${3-1048576}" #Default to ~1MB
  declare -g ARCHIVED_FILE
  ARCHIVED_FILE='' #Global/return-state set to 'True' when we archive a file.

  #When the $file_name exceeds $file_size_limit, archive it.
  if [[ -f "$file_name" ]]; then
    local file_size mvstatus gzipstatus
    file_size=$(wc --bytes < "$file_name")
    if ((file_size > file_size_limit)); then
      inform "Moving and compressing $file_name"
      mv "$file_name" "$archive_name" 2>&1 | err_pipe "${FUNCNAME[0]}(): "
      mvstatus="${PIPESTATUS[0]}"
      ((mvstatus==0)) && gzip "$archive_name" 2>&1 | err_pipe "${FUNCNAME[0]}(): "
      gzipstatus="${PIPESTATUS[0]}"
      if ((mvstatus+gzipstatus==0)); then
        inform "Moved old $file_name to ${archive_name}.gz"
        ARCHIVED_FILE='True'
      else
        err "${FUNCNAME[0]}(): Errors archiving '$file_name': mv='$mvstatus'; gzip='$gzipstatus'"
        ARCHIVED_FILE='False'
      fi
    fi
  fi
} #log_rotation()

periodic_maintenace(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Do periodic maintenance
  if [[ "$m2kScanMode" != 'True' ]]; then
    #check for interrupted undo jobs
    [[ -f "$m2kdir/undo.lock" && ! -f "$m2kdir/undo.sh" ]] && mv "$m2kdir/undo.lock" "$m2kdir/undo.sh"
    local last_maintenance_time
    #If file exist for last maintenance time, then get value
    if [[ -f "$m2kdir/lastmaintenace.time" ]]; then
      last_maintenance_time="$(<"$m2kdir/lastmaintenace.time")"
    else #no last maintenance time, so assign a never updated value.
      inform "Seems we've never run maintenance -- no lastmaintenace.time file."
      last_maintenance_time=42 #A meaningless low number to start from...
    fi
    local current_time
    current_time="$(date +%s)"
    if ((current_time > last_maintenance_time+MAINTENANCE_PERIOD)); then
      inform "Last maintenance more than $((MAINTENANCE_PERIOD/3600)) hours ago."
      if m2k_maintenance; then
        printf '%s\n' "$current_time" > "$m2kdir/lastmaintenace.time"
      else
        warn "${FUNCNAME[0]}(): maintenance failed to run correctly."
        return 1
      fi
    fi
  else
    debug "Skipping m2k_maintenance() as m2kScanMode has been set to 'True'"
  fi
  return 0
} #periodic_maintenace()

#Loops through tracked files and directories deleting them if they've been orphaned.
m2k_maintenance(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  inform "PERFORMING MAINTENANCE ROUTINE..."
  local -i counter=0

  #Correct created.tracking for transition from version < 1.5 to >= 1.5
  if [[ "$(head -c 1 "$m2kdir/created.tracking")" = "'" ]]; then
    warn "Updating created.tracking format for myth2kodi >= v1.5.0"
    sed -i.bak s/\'/\"/g "$m2kdir/created.tracking"
  fi

  #Check for comskip (.txt) and .nfo files listed in created.tracking and
  #remove them if their associated "main" file (.mpg) is missing.
  if [[ "$CommercialMarkupCleanup" = 'Enabled' && -f "$m2kdir/created.tracking" ]]; then
    inform "PERFORMING CLEANUP OF ORPHANED SUPPORT FILES."
    local support_file=""
    local main_file=""
    #Initialise counter for use in created.tracking
    counter=0
    while read -r line ; do
      (( ++counter ))
      support_file="$(cut -d'"' -f2 <<< "$line")"
      debug "Support file (record $counter): ${support_file}"
      main_file="$(cut -d'"' -f4 <<< "$line")"
      debug "Main file (record $counter): ${main_file}"
      if [[ -e "$main_file" ]]; then
        #If the main_file is actually the original MythTV recording file (it was
        #processed in LINK mode) and the support_file no longer exists, then
        #'[0-9]{4}_20[0-9]{2}[0-1][0-9][0-3][0-9][0-2][0-9][0-5][0-9]{3}'
        if grep -q -E '[0-9]{4}_20[0-9]{12}' <<< "$main_file" ; then
          debug "Identified as LINK mode created.tracking entry."
          if [[ -f "$support_file" ]]; then
            debug "Link still present, continuing to track."
            printf '%s\n' "$line" >> "$m2kdir/created.tracking2"
          else
            inform "Link no longer exists, removing from created.tracking."
            printf '%s\n' "$line" >> "$m2kdir/created.tracking.old"
          fi
        else
          #Not LINK mode and main file still exists, so continue to track
          printf '%s\n' "$line" >> "$m2kdir/created.tracking2"
        fi
      else
        if [[ -d "$(dirname "$support_file")" ]]; then
          inform "REMOVING ORPHAN FILE: '$support_file'"
          rm -f "$support_file"
          printf '%s\n' "$line" >> "$m2kdir/created.tracking.old"
        else
          warn "${FUNCNAME[0]}(): FOLDER DISCONNECTED: '$support_file'"
          if (( removedead != 1 )); then
            printf '%s\n' "$line" >> "$m2kdir/created.tracking2"
          else
            inform "REMOVING FROM FUTURE SEARCHES: '$line'"
            printf '%s\n' "$line" >> "$m2kdir/created.tracking.old"
          fi
        fi
      fi
    done < "$m2kdir/created.tracking"
    [[ -f "$m2kdir/created.tracking" ]] && rm -f "$m2kdir/created.tracking"
    [[ -f "$m2kdir/created.tracking2" ]] && mv "$m2kdir/created.tracking2" "$m2kdir/created.tracking"
  fi

  #Check if folders are empty and remove dir if needed and it was created by myth2kodi
  if [[ "$DIR_TRACKING_CLEANUP" = 'Enabled' && -f "$m2kdir/dir.tracking" ]]; then
    inform "PERFORMING CLEANUP OF EMPTY DIRECTORIES."
    local sorted_dir_tracking_file
    if ! sorted_dir_tracking_file="$(mktemp "$M2K_TMPDIR"/m2k_sorted_dir_tracking-XXXX)"; then
      err "${FUNCNAME[0]}(): Failed to create temporary sorted-dir-tracking file."
      return 1
    fi
    debug "Created a temporary sorted dir,tracking file: '$sorted_dir_tracking_file'"
    #Reverse dictionary sort the tracked dirs, should have the effect of depth first.
    sort -dr "$m2kdir/dir.tracking" > "$sorted_dir_tracking_file"
    local contains
    #Initialise counter for use in dir.tracking
    counter=0
    while read -r dirtocheck ; do
      (( ++counter ))
      debug "Folder record $counter: $dirtocheck"
      if [[ -d "$dirtocheck" ]]; then
        #Is there something in the directory other than 'tvshow.nfo'
        contains="$(find "$dirtocheck" -mindepth 1 ! -name 'tvshow.nfo' -print -quit)"
        if [[ -z "$contains" ]]; then
          inform "REMOVING ORPHAN FOLDER: '$dirtocheck'"
          [[ -f "$dirtocheck/tvshow.nfo" ]] && rm -f "$dirtocheck/tvshow.nfo"
          rmdir "$dirtocheck"
          printf '%s\n' "$dirtocheck" >> "$m2kdir/dir.tracking.old"
        else
          debugcont "Continuing to track folder record $counter, it contains, at least: $contains"
          printf '%s\n' "$dirtocheck" >> "$m2kdir/dir.tracking2"
        fi
      else
        warn "${FUNCNAME[0]}(): Tracked directory does not seem to be a directory."
        warncont "Continuing to track (just in case): '$dirtocheck'"
        printf '%s\n' "$dirtocheck" >> "$m2kdir/dir.tracking2"
      fi
    done < "$sorted_dir_tracking_file"
    [[ -f "$m2kdir/dir.tracking" ]] && rm -f "$m2kdir/dir.tracking"
    [[ -f "$sorted_dir_tracking_file" ]] && rm -f "$sorted_dir_tracking_file"
    [[ -f "$m2kdir/dir.tracking2" ]] && mv "$m2kdir/dir.tracking2" "$m2kdir/dir.tracking"
  fi

  #When the dir.tracking.old exceeds 512kB compress it and start a fresh one.
  log_rotation "$m2kdir/dir.tracking.old" "$m2kdir/dir.tracking.old_${FILE_NAME_NOW}" '512000'

  #When the created.tracking.old exceeds 512kB compress it and start a fresh one.
  log_rotation "$m2kdir/created.tracking.old" "$m2kdir/created.tracking.old_${FILE_NAME_NOW}" '512000'

  #This isn't super fast, so only cleanse the working when called from --maintenance mode.
  if (( removedead == 1 )); then
    inform "Cleaning up old archived logs, myth2kodi database files, and daily report files."
    m2k_cleanse
  fi
  inform "MAINTENANCE ROUTINE COMPLETE."
  return 0
} #m2k_maintenance()

#Process a list of archived files and remove those older than a specified age.
process_cleanup_file(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "Called with $# arguments"
  local -i i=0; local var; for var in "$@"; do ((++i)); debugcont "arg $i = '${var}'"; done
  local cleanup_file
  local -i archive_life
  local archive_date
  local -i expire_older_than
  cleanup_file="$1"
  [[ ! -f "$cleanup_file" ]] && err "${FUNCNAME[0]}(): Not a file: $cleanup_file" && return 1
  archive_life="$2"
  expire_older_than="$(date -d "-$archive_life months" '+%Y%m%d')"

  inform "Removing files created more than $archive_life months ago."
  while read -r line ; do
    if [[ -f "$line" ]]; then
      #Extract the creation date of the archived file
      archive_date="$(grep --only-matching '20[0-9][0-9]-[0-1][0-9]-[0-3][0-9]' <<< "$line")"
      #Convert it to an integer
      archive_date="$(date -d "$archive_date" +"%Y%m%d")"
      if ((archive_date < expire_older_than)); then
        debug "Removing old archive file: '$line'"
        rm -f "$line"
      fi
    else
      warn "${FUNCNAME[0]}(): Entry in '$cleanup_file' is not a file: '$line'."
    fi
  done < "$cleanup_file"

  #If we're not in debug mode then remove the clean-up file we just processed.
  if (( LOGLEVEL < 3 )); then
    rm -f "$cleanup_file"
    return "$?"
  else
    debug "Not removing temporary clean-up file: '$cleanup_file'"
  fi
  return 0
} #process_cleanup_file()

#Clean-up old files we don't need any more: log files; m2k database files; etc.
m2k_cleanse(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #TODO: Consider making the cleanup_logs file more modular, so we can set different
  #      lifetimes for the archived main logs, doover scripts, undo scripts, etc.
  #      Maybe make an archived_logs directory with sub directories: main; diagnostics; etc.
  #      In the interim, you can get a cleaner view of the working directory with:
  #          ls ~/.myth2kodi/ --ignore=*20[0-9][0-9]-[0-1][0-9]-[0-3][0-9]*
  #      or
  #          ls -Fltrh ~/.myth2kodi/ --ignore=*20[0-9][0-9]-[0-1][0-9]-[0-3][0-9]*

  #Create cleanup files for archived logs, myth2kodi database, and daily report files.
  local cleanup_logs cleanup_m2k_db cleanup_dailyreport
  if ! cleanup_logs="$(mktemp "$M2K_TMPDIR/m2k_cleanup_logs_$FILE_NAME_NOW"-XXXX)"; then
    err "${FUNCNAME[0]}(): Failed to create temporary cleanup-logs file."
    return 1
  fi
  if ! cleanup_m2k_db="$(mktemp "$M2K_TMPDIR/m2k_cleanup_m2k_db_$FILE_NAME_NOW"-XXXX)"; then
    err "${FUNCNAME[0]}(): Failed to create temporary cleanup-m2k-db file."
    return 1
  fi
  if ! cleanup_dailyreport="$(mktemp "$M2K_TMPDIR/m2k_cleanup_dailyreport_$FILE_NAME_NOW"-XXXX)"; then
    err "${FUNCNAME[0]}(): Failed to create temporary cleanup-daily reportfile."
    return 1
  fi
  find "$m2kdir" -maxdepth 1 -type f -name '*20[0-9][0-9]-[0-1][0-9]-[0-3][0-9]*' > "$cleanup_logs"
  find "$m2kdir" -mindepth 2 -type f ! -path "*DailyReport*" -name '*20[0-9][0-9]-[0-1][0-9]-[0-3][0-9]*' > "$cleanup_m2k_db" #TODO: Probably better if we move series directories into something like $m2kdir/series-db/
  find "$m2kdir/DailyReport" -type f -name '*20[0-9][0-9]-[0-1][0-9]-[0-3][0-9]*' > "$cleanup_dailyreport"

  inform "Processing log clean-up file: $cleanup_logs"
  process_cleanup_file "$cleanup_logs" "$LOG_LIFE"

  inform "Processing myth2kodi database clean-up file: $cleanup_m2k_db"
  process_cleanup_file "$cleanup_m2k_db" "$M2K_DB_LIFE"

  inform "Processing daily report clean-up file: $cleanup_dailyreport"
  process_cleanup_file "$cleanup_dailyreport" "$DAILYREPORT_LIFE"

  #Clean-up temporary files we leave around when running with debug logging.
  #NOTE: While this could be 'rm -f "$M2K_TMPDIR/m2k_"*', this way we know
  #      what it is we're expecting to clean-up...
  rm -f "$M2K_TMPDIR/m2k_cleanup_logs_"*
  rm -f "$M2K_TMPDIR/m2k_cleanup_m2k_db_"*
  rm -f "$M2K_TMPDIR/m2k_cleanup_dailyreport_"*
  rm -f "$M2K_TMPDIR/m2k_comskip_scan_"*
  rm -f "$M2K_TMPDIR/m2k_scan_"*
  rm -f "$M2K_TMPDIR/m2k_recinfo_"*
  rm -f "$M2K_TMPDIR/m2k_shn_"*
  rm -f "$M2K_TMPDIR/m2k_sid_"*
  rm -f "$M2K_TMPDIR/m2k_working_"*
  rm -f "$M2K_TMPDIR/m2k_markupframes_"*
  rm -f "$M2K_TMPDIR/m2k_markupstart_"*
  rm -f "$M2K_TMPDIR/m2k_markupstop_"*
  rm -f "$M2K_TMPDIR/m2k_zap2it_"*  #TODO: no longer used, leave for a release or three after 1.5.0 so that it cleans up old files...
  rm -f "$M2K_TMPDIR/m2k_sorted_dir_tracking-"*
  rm -f "$M2K_TMPDIR/m2k_logfilelist-"*
  rm -f "$M2K_TMPDIR/m2k_templog-"*

  #Archive our duplicates.log.
  if [[ -f "$DuplicatesFile" ]]; then
    debug "Moving '$DuplicatesFile' to '${DuplicatesFile%.*}_${FILE_NAME_NOW}.log'."
    mv "$DuplicatesFile" "${DuplicatesFile%.*}_${FILE_NAME_NOW}.log"
  fi
  return 0
} #m2k_cleanse()

#################### FUNCTIONS TO ACCESS MythTV DATABASE #####################

#Helper function for MySQL access to the MythTV-DB. It takes 3 arguments; the
#first(required) is the name of the field we want; the second(optional) is to
#specify a non-default table (default='recorded'); the third(optional) is to
#specify a non-default WHERE construct, which needs to be set as '' when we
#do not want a WHERE (default="WHERE basename LIKE '$INPUT_PATH_BASENAME'").
dbselect(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "Called with $# arguments."
  local -i i=0; local var; for var in "$@"; do ((++i)); debugcont "arg $i = '${var}'"; done
  local field table where query
  field="$1"
  if [[ -z "$2" ]]; then table='recorded'; else table="$2"; fi
  if (($# < 3)); then
    where="WHERE basename LIKE '$INPUT_PATH_BASENAME'"
  else
    where="$3"
  fi
  query="USE $MySQLMythDb ; SELECT $field FROM $table $where ; "
  mysql -u"$MySQLuser" -p"$MySQLpass" -e "$query"
  return "$?"
} #dbselect()

#Use mysql commands to get MythTV-DB entry for the current recording.
get_mythtvdb_info_mysql(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "m2kdir: '$m2kdir'"
  debugcont "INPUT_PATH_BASENAME: '$INPUT_PATH_BASENAME'"
  debugcont "MySQLMythDb: '$MySQLMythDb'"
  debugcont "MySQLuser: '$MySQLuser'"
  ((LOGLEVEL > 3)) && debugcont "MySQLpass: '$MySQLpass'"

  #Obtain MythTV Database Information
  inform "Accessing MythTV DataBase Using mysql Commands."

  #Select the variables we are interested in from the MythTV-DB.
  MDB_TITLE="$(          dbselect title           | sed -n "2p")"
  MDB_SUBTITLE="$(       dbselect subtitle        | sed -n "2p")"
  MDB_SEASON="$(         dbselect season          | sed -n "2p")"
  MDB_EPISODE="$(        dbselect episode         | sed -n "2p")"
  MDB_CATEGORY="$(       dbselect category        | sed -n "2p")"
  MDB_ORIGINALAIRDATE="$(dbselect originalairdate | sed -n "2p")"
  MDB_RECGROUP="$(       dbselect recgroup        | sed -n "2p")"
  MDB_STORAGEGROUP="$(   dbselect storagegroup    | sed -n "2p")"
  MDB_STARS="$(          dbselect stars           | sed -n "2p")"
  MDB_DESCRIPTION="$(    dbselect description     | sed -n "2p")"
  MDB_SERIESID="$(       dbselect seriesid        | sed -n "2p")"
  MDB_PROGRAMID="$(      dbselect programid       | sed -n "2p")"
  MDB_INETREF="$(        dbselect inetref         | sed -n "2p")"
  MDB_CHANID="$(         dbselect chanid          | sed -n "2p")"
  MDB_STARTTIME="$(      dbselect starttime       | sed -n "2p")"

  local where
  where="WHERE programid LIKE '$MDB_PROGRAMID' AND chanid LIKE '$MDB_CHANID'"
  MDB_AIRDATE="$(dbselect 'airdate' 'recordedprogram' "$where" | sed -n "2p")"
  MDB_XMLTVGRABBER="$(dbselect 'xmltvgrabber' 'videosource' '' | sed -n "2p")"

  #Make the MythTV-DB variables read-only.
  debug 'Extracted the following data from MythTV-DB:'
  declare -gr MDB_TITLE           ; debugcont "MDB_TITLE='$MDB_TITLE'"
  declare -gr MDB_SUBTITLE        ; debugcont "MDB_SUBTITLE='$MDB_SUBTITLE'"
  declare -gr MDB_SEASON          ; debugcont "MDB_SEASON='$MDB_SEASON'"
  declare -gr MDB_EPISODE         ; debugcont "MDB_EPISODE='$MDB_EPISODE'"
  declare -gr MDB_CATEGORY        ; debugcont "MDB_CATEGORY='$MDB_CATEGORY'"
  declare -gr MDB_ORIGINALAIRDATE ; debugcont "MDB_ORIGINALAIRDATE='$MDB_ORIGINALAIRDATE'"
  declare -gr MDB_RECGROUP        ; debugcont "MDB_RECGROUP='$MDB_RECGROUP'"
  declare -gr MDB_STORAGEGROUP    ; debugcont "MDB_STORAGEGROUP='$MDB_STORAGEGROUP'"
  declare -gr MDB_STARS           ; debugcont "MDB_STARS='$MDB_STARS'"
  declare -gr MDB_DESCRIPTION     ; debugcont "MDB_DESCRIPTION='$MDB_DESCRIPTION'"
  declare -gr MDB_SERIESID        ; debugcont "MDB_SERIESID='$MDB_SERIESID'"
  declare -gr MDB_PROGRAMID       ; debugcont "MDB_PROGRAMID='$MDB_PROGRAMID'"
  declare -gr MDB_INETREF         ; debugcont "MDB_INETREF='$MDB_INETREF'"
  declare -gr MDB_CHANID          ; debugcont "MDB_CHANID='$MDB_CHANID'"
  declare -gr MDB_STARTTIME       ; debugcont "MDB_STARTTIME='$MDB_STARTTIME'"
  declare -gr MDB_AIRDATE         ; debugcont "MDB_AIRDATE='$MDB_AIRDATE'"
  declare -gr MDB_XMLTVGRABBER    ; debugcont "MDB_XMLTVGRABBER='$MDB_XMLTVGRABBER'"

  #####COMSKIP DATA#####
  #Set up counter, remove old markup data and generate new markup file from markupstart and stop
  if [[ "$CommercialMarkup" = 'Enabled' ]]; then
    if ! MARKUPSTART_TMP="$(mktemp "$M2K_TMPDIR/m2k_markupstart_$FILE_NAME_NOW"-XXXX)"; then
      err "${FUNCNAME[0]}(): Failed to create temporary markupstart file."
      return 1
    fi
    debug "Created a temporary comskip markupstart file: '$MARKUPSTART_TMP'"
    declare -gr MARKUPSTART_TMP

    if ! MARKUPSTOP_TMP="$(mktemp "$M2K_TMPDIR/m2k_markupstop_$FILE_NAME_NOW"-XXXX)"; then
      err "${FUNCNAME[0]}(): Failed to create temporary markupstop file."
      return 1
    fi
    debug "Created a temporary comskip markupstop file: '$MARKUPSTOP_TMP'"
    declare -gr MARKUPSTOP_TMP

    #Remove old and generate a comskip Start list
    printf '\n' > "$MARKUPSTART_TMP" #TODO: Compare this against what's returned by the python bindings version.
    where="WHERE starttime LIKE '$MDB_STARTTIME' AND chanid LIKE '$MDB_CHANID' AND type LIKE 4"
    dbselect 'mark' 'recordedmarkup' "$where" >> "$MARKUPSTART_TMP"
    #Remove old and generate comskip Stop list
    printf '\n' > "$MARKUPSTOP_TMP"
    where="WHERE starttime LIKE '$MDB_STARTTIME' AND chanid LIKE '$MDB_CHANID' AND type LIKE 5"
    dbselect 'mark' 'recordedmarkup' "$where" >> "$MARKUPSTOP_TMP"
    #Combine commercial data into a single comskip file and remove the initial files
    generate_comskip
  fi
  return 0
} #get_mythtvdb_info_mysql()

#Use python bindings to get MythTV-DB entry for the current recording.
get_mythtvdb_info_pythonbindings(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "m2kdir: '$m2kdir'"
  debugcont "binpath: '$binpath'"
  debugcont "INPUT_PATH_BASENAME: '$INPUT_PATH_BASENAME'"
  ((LOGLEVEL > 3)) && debugcont "DBPin: '$DBPin'"
  debugcont "DBHostName: '$DBHostName'"
  debugcont "MySQLMythDb: '$MySQLMythDb'"
  debugcont "MySQLuser: '$MySQLuser'"
  ((LOGLEVEL > 3)) && debugcont "MySQLpass: '$MySQLpass'"
  inform "Accessing MythTV DataBase Using PythonBindings."

  local python_exit_status
  local mtv_recinfo_file
  if ! mtv_recinfo_file="$(mktemp "$M2K_TMPDIR/m2k_recinfo_$FILE_NAME_NOW"-XXXX)"; then
    err "${FUNCNAME[0]}(): Failed to create temporary recinfo file."
    return 1
  fi
  debug "Storing MythTV-DB info in temporary file: '$mtv_recinfo_file'"

  #Declare the MythTV-DB variables we want access to outside of this function.
  local access_list
  access_list='title|subtitle|season|episode|category|originalairdate|recgroup|'
  access_list="$access_list"'storagegroup|stars|description|seriesid|programid|'
  access_list="$access_list"'inetref|chanid|starttime|airdate|xmltvgrabber'

  #Access MytTV-DB via the python bindings and output to a temporary file.
  "$binpath"/mythdb_access --verbosity="$((LOGLEVEL<3?LOGLEVEL:3))" \
                           --filename="$INPUT_PATH_BASENAME"        \
                           --SecurityPin="$DBPin"                   \
                           --DBHostName="$DBHostName"               \
                           --DBName="$MySQLMythDb"                  \
                           --DBUserName="$MySQLuser"                \
                           --DBPassword="$MySQLpass"                \
                           --output="$mtv_recinfo_file"             \
                           --writeFile 2>&1 | err_pipe "mythdb_access: "

  python_exit_status="${PIPESTATUS[0]}"
  if (( python_exit_status != 0 )); then
    err "${FUNCNAME[0]}(): DATABASE ACCESS ERROR: Could not obtain information."
    return 1
  fi

  #Read values obtained by mythdb_access, remove quotes and declare variables.
  debug "Guide data as extracted by: ${FUNCNAME[0]}()"
  local this_var
  while read -r var equals value ; do
    value="$(tr -d \" <<< "$value")"
    if [[ "$equals" = '=' ]]; then
      this_var="MDB_${var^^}"
      if [[ "$this_var" =~ ^(MDB_STARTDATA\[[0-9]*\]|MDB_STOPDATA\[[0-9]*\])$ ]]; then
        declare "$this_var=$value"
        debugcont "$this_var='$value'"
      elif [[ "$var" =~ ^($access_list)$ ]]; then
        declare -gr "$this_var=$value"
        debugcont "$this_var='$value'"
      else
        ((LOGLEVEL>3)) && debugcont "UNUSED: $this_var='$value'"
      fi
    fi
  done < "$mtv_recinfo_file"

  if [[ "$CommercialMarkup" = 'Enabled' ]]; then
    if ! MARKUPSTART_TMP="$(mktemp "$M2K_TMPDIR/m2k_markupstart_$FILE_NAME_NOW"-XXXX)"; then
      err "${FUNCNAME[0]}(): Failed to create temporary markupstart file."
      return 1
    fi
    debug "Created a temporary comskip markupstart file: '$MARKUPSTART_TMP'"
    declare -gr MARKUPSTART_TMP

    if ! MARKUPSTOP_TMP="$(mktemp "$M2K_TMPDIR/m2k_markupstop_$FILE_NAME_NOW"-XXXX)"; then
      err "${FUNCNAME[0]}(): Failed to create temporary markupstop file."
      return 1
    fi
    debug "Created a temporary comskip markupstop file: '$MARKUPSTOP_TMP'"
    declare -gr MARKUPSTOP_TMP

    #Output commercial data to temporary files
    printf '%s\n' "${MDB_STARTDATA[@]}" > "$MARKUPSTART_TMP"
    printf '%s\n' "${MDB_STOPDATA[@]}"  > "$MARKUPSTOP_TMP"
    #Combine commercial data into a single comskip file and remove the temporary files
    generate_comskip
  fi

  #If we're not in debug mode then clean-up the file written by mythdb_access
  if (( LOGLEVEL < 3 )) ; then
    rm -f "$mtv_recinfo_file"
  else
    debug "Not removing the temporary MythTV-DB info file: '$mtv_recinfo_file'"
  fi
} #get_mythtvdb_info_pythonbindings()

get_mythtvdb_info(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  if [[ "$Database" = 'Enabled' ]]; then
    #Access the database entry using the requested grabber
    case "$DATABASE_ACCESS" in
      MySQL)
        get_mythtvdb_info_mysql
        return "$?"
        ;;
      PythonBindings)
        if ! get_mythtvdb_info_pythonbindings; then
          NOTIFY_MSG="Call to MythTV-DB Python bindings failed."
          EXIT_JOB_TYPE='MythTVdatabaseFailure'
          return 1
        fi
        return 0
        ;;
      *)
        NOTIFY_MSG="DATABASE_ACCESS incorrectly specified."
        err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
        EXIT_JOB_TYPE='UserSettingError'
        return 1
        ;;
    esac
  else
    NOTIFY_MSG="Trying to access recording info with Database='Disabled'."
    err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
    EXIT_JOB_TYPE='InsufficientInformationProvided'
    return 1
  fi
} #get_mythtvdb_info()

get_mythtvdb_storagegroups(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  if [[ "$Database" = 'Enabled' ]]; then
    declare -ga STORAGEGROUP_DIRS
    local db_storagegroup_dirs
    #Access the database entry using the requested grabber
    case "$DATABASE_ACCESS" in
      MySQL)
        if ! db_storagegroup_dirs="$(dbselect 'dirname' 'storagegroup' '' )"; then
          NOTIFY_MSG='Accessing storagegroup table from MythTV-DB using MySQL failed.'
          EXIT_JOB_TYPE='MythTVdatabaseFailure'
          return 1
        fi
        STORAGEGROUP_DIRS=($(sed -n '2~1p' <<< "$db_storagegroup_dirs"))
        return 0
        ;;
      PythonBindings)
        local returnstatus
        STORAGEGROUP_DIRS=($("$binpath"/mythdb_access --storagegroups            \
                                                      --SecurityPin="$DBPin"     \
                                                      --DBHostName="$DBHostName" \
                                                      --DBName="$MySQLMythDb"    \
                                                      --DBUserName="$MySQLuser"  \
                                                      --DBPassword="$MySQLpass"))
        returnstatus="$?"
        if [[ "$returnstatus" != 0 ]]; then
          NOTIFY_MSG='Accessing storagegroup table from MythTV-DB using Python-bindings failed.'
          EXIT_JOB_TYPE='MythTVdatabaseFailure'
          return 1
        fi
        return 0
        ;;
      *)
        NOTIFY_MSG="DATABASE_ACCESS incorrectly specified."
        err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
        EXIT_JOB_TYPE='UserSettingError'
        return 1
        ;;
    esac
  else
    NOTIFY_MSG="Trying to access storagegroups with Database='Disabled'."
    err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
    EXIT_JOB_TYPE='InsufficientInformationProvided'
    return 1
  fi
} #get_mythtvdb_storagegroups()

#Remove recording's pictures and entries from MythTV-DB. Thanks to barney_1.
delete_mythtv_database_entry_mysql(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debug "RECORDING_PATH: '$RECORDING_PATH'"
  debug "INPUT_PATH_BASENAME: '$INPUT_PATH_BASENAME'"
  debug "MySQLMythDb: '$MySQLMythDb'"
  debug "MySQLuser: '$MySQLuser'"
  ((LOGLEVEL > 3)) && debug "MySQLpass: '$MySQLpass'"

  if [[ -z "$RECORDING_PATH" ]]; then
    err "${FUNCNAME[1]}():${FUNCNAME[0]}(): Called with empty RECORDING_PATH."
    return 1
  fi

  #Make sure we got input arguments and file is valid
  if [[ ! -e "$RECORDING_PATH" ]]; then
    #Remove recording entry from mysql database
    inform "${FUNCNAME[0]}(): REMOVING: '$INPUT_PATH_BASENAME'; THUMBNAILS; DATABASE ENTRIES."
    local cmd="USE $MySQLMythDb ; DELETE FROM recorded WHERE basename LIKE '$INPUT_PATH_BASENAME' ; "
    if ! mysql -u"$MySQLuser" -p"$MySQLpass" -e "$cmd"; then
      err "${FUNCNAME[0]}(): Failed to delete DB entry for: $INPUT_PATH_BASENAME"
      return 1
    fi
    #Remove thumbnails
    rm -f "$RECORDING_PATH".*
  else
    warn "${FUNCNAME[0]}(): File still exists: '$RECORDING_PATH'"
    warncont "Not removing MythTV-DB information."
    return 1
  fi
  return 0
} #delete_mythtv_database_entry_mysql()

############## FUNCTIONS TO PROCESS MythTV DATABASE INFORMATION ##############

#Gather information from the MythTV database based on user settings.
process_mythtvdb(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"

  if [[ "$Database" = 'Enabled' ]]; then
    #Access the database entry using the requested grabber
    if ! get_mythtvdb_info; then return 1; fi

    #Do appropriate, guide-data specific, processing.
    case "$GuideDataType" in
      SchedulesDirect)
        process_mythtvdb_schedulesdirect
        ;;
      SydFTA)
        process_mythtvdb_sydfta
        ;;
      *)
        warn "GuideDataType incorrectly specified, processing MythTV database info assuming SchedulesDirect."
        process_mythtvdb_schedulesdirect
        ;;
    esac
    if [[ -z "$TITLE" ]]; then
      NOTIFY_MSG="Failed to determine TITLE from MythTV-DB, and none provided."
      err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
      EXIT_JOB_TYPE='NameCouldNotBeAssigned'
      return 1
    fi
  else
    if [[ -z "$TITLE" ]]; then
      NOTIFY_MSG="Database disabled and no TITLE provided on command line."
      err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
      EXIT_JOB_TYPE='InsufficientInformationProvided'
      return 1
    else
      #The Database is 'Disabled' but we have a TITLE to work with.
      if [[ "$CATEGORY" = 'Movie' ]]; then
        #The --movie flag must have been set.
        RECORDING_TYPE='MV'
      else
        #Default to assuming we're processing an episode.
        RECORDING_TYPE='EP'
      fi
    fi
  fi
  return 0
} #process_mythtvdb()

#Gather information from the MythTV database common to guide-data types.
process_mythtvdb_common(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Check for database permissions: assumes MDB_CHANID set if DB access successful.
  [[ -z "$MDB_CHANID" ]] && err "${FUNCNAME[0]}(): No MythTV-DB information." #TODO: Probably should return 1 here.

  #Command-line arguments take precedence over MythTV-DB (guide-data).
  [[ -z "$INPUT_TITLE" ]]    && TITLE="$MDB_TITLE"
  [[ -z "$INPUT_SUBTITLE" ]] && SUBTITLE="$MDB_SUBTITLE"
  [[ -z "$INPUT_SEASON" ]]   && SEASON="$MDB_SEASON"
  [[ -z "$INPUT_EPISODE" ]]  && EPISODE="$MDB_EPISODE"
  [[ -z "$CATEGORY" ]]       && CATEGORY="$MDB_CATEGORY" #Support the --movie flag.

  Plot="$MDB_DESCRIPTION"

  #Some guide-data sources set 'none' instead of '' to mean no-information.
  ORIGINALAIRDATE="$MDB_ORIGINALAIRDATE"
  [[ "${ORIGINALAIRDATE,,}" = 'none' ]] && ORIGINALAIRDATE=''

  #Get rating from MDB_STARS
  RATING="$(printf '%0.f' "$MDB_STARS")"
  if [[ -n "$RATING" ]]; then ((RATING=RATING*2)); else RATING=1; fi

  #The definition of the 'season' and 'episode' fields of a 'recorded' entry
  #specifies a default of NULL: https://www.mythtv.org/wiki/Recorded_table
  #However, it seems common that "no information" is incorrectly indicated
  #by setting them as 0 instead of NULL (which for us would resolve to '').
  #Special episodes, not belonging to a particular season, are typically
  #designated as season=0, however, I'm not aware of a valid use of episode=0.
  [[ "$EPISODE" = '0' ]] && { SEASON=''; EPISODE=''; }

  #Predefined naming conventions
  if [[ "$CATEGORY" =~ ^('Sports event'|'News'|'Newsmagazine')$ ]]; then
    NamingConvention="$CATEGORY"
  fi

  #If news, bypass Categoric naming convention 1
  [[ "$NamingConvention" = 'News' ]] && UseMethod2=1

  #strip needless chars from date
  STARTTIME="$(printf '%s' "$MDB_STARTTIME" | tr ':' '.' | tr ' ' '@')" #TODO: Consider getting rid of the @ from this, as it's used in file naming... Maybe _ instead

  return 0
} #process_mythtvdb_common()

#Processes Zap2it/SchedulesDirect/Tribune data for use in the program
process_mythtvdb_schedulesdirect(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  inform 'Processing MythTV database info as SchedulesDirect.'

  #Gather information from the MythTV database common to guide-data types.
  process_mythtvdb_common

  #Create MV/EP/SH Identification Type from MDB_PROGRAMID
  RECORDING_TYPE="${MDB_PROGRAMID:0:2}"

  #TODO: Does SchedulesDirect contain a Movie's release year in the MDB_AIRDATE field?
  # MOVIE_RELEASE_YEAR="$MDB_AIRDATE"
  # [[ -n "$MOVIE_RELEASE_YEAR" ]] && (( MOVIE_RELEASE_YEAR < 1900 )) && MOVIE_RELEASE_YEAR=''

  #Extrapolate data from RECORDING_TYPE
  set_ProgramIDType

  #account for .0123's in EITonly data type
  Zap2itSeriesID="$(cut -f1 -d"." <<< "$MDB_PROGRAMID")"

  #Get barebones zap2it series id.
  Zap2itSeriesID=$(echo "$Zap2itSeriesID" | tr -d MVSHEP | sed 's/0*//' | sed 's/.\{4\}$//')

  #Only keep Alpha-numeric characters, space and the four chars & , . -
  Plot="$(sed -r 's/[^[:alnum:] &,.-]//g' <<< "$Plot")"

  return 0
} #process_mythtvdb_schedulesdirect()

#A Process function compatible with Sydney over the air data...
process_mythtvdb_sydfta(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  inform 'Processing MythTV database info as SydFTA.'

  #Gather information from the MythTV database common to guide-data types.
  process_mythtvdb_common

  #Current (2016-08) issue from 7flix: description in Subtitle field, all-caps cast in Plot...
  #Strip the all-caps actor names that are still showing up in 7fix's plot field...
  local actor_names
  actor_names="$(grep -E --only-matching '^(([A-Z]{1,12}[[:space:]|\.|-]?){1,3}[[:space:]|,][[:space:]]?){1,20}' <<< "$Plot")"
  if [[ -n "$actor_names" ]]; then
    warn "${FUNCNAME[0]}(): Stripping actor names from plot."
    debug "actor_names: '$actor_names'"
    debug "Orig Plot: '$Plot'"
    Plot="${Plot/$actor_names/}"
    debug "New Plot: '$Plot'"
  fi
  #NOTE: BrainDead s01e04 has a 136 character subtitle, but as it is an outlier, stick with 84.
  #Longest actual subtitle I've seen so far is 84 characters. Rather than assuming Plot field
  #is garbage, we'll append the SUBTITLE field to the Plot -- this will almost certainly
  #prevent full Plot fuzzy match from succeeding but chunked match should still match effectively.
  if [[ -z "$INPUT_SUBTITLE" ]] && (( $(wc --chars <<< "$SUBTITLE") > 84 )); then #Probably not a subtitle.
    local PossiblePlot
    PossiblePlot="$SUBTITLE"
    warn "${FUNCNAME[0]}(): SUBTITLE field from MythTV-DB appears to contain Plot information."
    debug "Plot: '$Plot'"
    debug "PossiblePlot: '$PossiblePlot'"
    warn "Resetting SUBTITLE to ''"
    SUBTITLE=''
    warn "Appending PossiblePlot to Plot."
    Plot="$Plot $PossiblePlot"
    debug "Plot: '$Plot'"
    debug "Full Plot match will almost certainly fail, though chunked match should still work."
  fi

  #The MDB_PROGRAMID field from FTA EPG data in Sydney?Australia? doesn't specify MV/EP/SH,
  #the Movie specification is "almost-always" found in the Category field of
  #the MythTV database. So, we'll use that.
  if [[ "$CATEGORY" = 'Movie' ]]; then
    inform "Guide data for '$TITLE' indicates a Movie."
    RECORDING_TYPE='MV'
    if [[ -z "$INPUT_SUBTITLE" && -n "$MDB_SUBTITLE" ]]; then
      warn "${FUNCNAME[0]}(): Guide data indicates that '$TITLE' is a Movie, but has a SUBTITLE: '$SUBTITLE'"
      warn "Resetting SUBTITLE to ''"
      SUBTITLE=''
    fi
  else #For now assume that if it's not a Movie it's an episode of a series
    #TODO: For now we mainly/only record Movies and Episodes of TV series,
    #  so, this is an ok approximation, but should look through more EPG data
    #  and determine whether the Category field reliably distinguishes things
    #  like news, sport, etc
    debug "Recording is not obviously a movie, so assuming episode of series. TODO: Line $LINENO."
    RECORDING_TYPE='EP'
  fi

  #TODO: Check the seriesid field in MythTV-DB & see if we can make more
  #  sensible use of whatever it contains...

  #Try to extract any SUBTITLE or SeasonEpisode info that is in the Plot.
  if [[ "$RECORDING_TYPE" = 'EP' ]]; then
    debug 'The MythTV Guide data Plot before we messed with it:'
    debugcont "Plot:'$Plot'"
    get_sxxexx_from_plot
    remove_sxxexx_from_plot
    #If we haven't set a Subtitle yet, try and get one from $Plot
    if [[ -z "$SUBTITLE" ]]; then
      get_subtitle_from_plot
      #TODO: Only makes sense to call remove_subtitle_from_plot if get_subtitle_from_plot found one.
      remove_subtitle_from_plot
    fi
    debug 'The MythTV Guide data Plot after we messed with it:'
    debugcont "Plot:'$Plot'"
  fi

  #Remove hashtag reference/s from the Plot field #TODO: Will probably need to check and extend this.
  Plot="$(sed 's/\s#\w\{2,16\}//g' <<< "$Plot")"
  #And @mentions, at least SBS2 does this '@SBS2'
  Plot="$(sed 's/\s@\w\{2,16\}//g' <<< "$Plot")"
  #Some channels, particularly ABC, put cast info in the end of the plot field which can mess up fuzzy Plot matching
  remove_cast_from_plot

  #Only keep Alpha-numeric characters, space and the four chars & , . -
  Plot="$(sed -r 's/[^[:alnum:] &,.-]//g' <<< "$Plot")"

  #Strip the Movie: tag that some stations very helpfully put in the title field...
  if [[ "$RECORDING_TYPE" = 'MV' ]]; then
    TITLE="$(sed 's/Movie:\s*//I' <<< "$TITLE")"
  fi

  #TODO: If it's a movie, check Title and Plot for a release year, assuming format (YYYY) seems reasonable.
  #  If we find it, check its between 1942 & ThisYear, then store it (MOVIE_RELEASE_YEAR) and remove it from where we found it,
  #  especially important to remove from Title -- to avoid repetition in NewFileName if we use it to generate that name.

  #Extrapolate data from RECORDING_TYPE
  set_ProgramIDType

  #FTA stations providing a MDB_PROGRAMID use CRID: https://en.wikipedia.org/wiki/Crid
  #Remove the leading CRID://
  SydFTA_ProgramID="$(sed 's#crid://##I' <<< "$MDB_PROGRAMID")"
  #Extract the Authority, ie the station broadcasting the show
  ProgramAuthority="$(cut -f1 -d"/" <<< "$SydFTA_ProgramID")"
  #Extract the show specific information, removing the leading /
  ProgramData="$(sed "s#$ProgramAuthority/##" <<< "$SydFTA_ProgramID")"
  #Populate the SydFTA_ProgramID variable with the ProgramData field of CRID
  SydFTA_ProgramID="$ProgramData"
  #TODO: figure out if anything useful can actually be done with this SydFTA_ProgramID.

  return 0
} #process_mythtvdb_sydfta()

#Convert RECORDING_TYPE into ProgramIDType.
set_ProgramIDType(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "RECORDING_TYPE='$RECORDING_TYPE'"
  case "$RECORDING_TYPE" in
    'SH')
      ProgramIDType='Generic Episode With No Data'
    ;;
    'MV')
      ProgramIDType='Movie'
    ;;
    'EP')
      ProgramIDType='Series With Episode Data'
    ;;
    'SP')
      ProgramIDType='Sports Programming'
      RECORDING_TYPE='SH'
    ;;
    *)
      EXIT_JOB_TYPE='UnrecognisedProgramIDType'
      NOTIFY_MSG="Unrecognised RECORDING_TYPE: '$RECORDING_TYPE'."
      err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
      return 1
      ;;
  esac
  return 0
} #set_ProgramIDType()

#Try and set Sxx and Exx using SEASON and EPISODE.
set_sxxexx_with_season_episode(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "SEASON='$SEASON'"
  debugcont "EPISODE='$EPISODE'"
  debugcont "SeasonEpisode='$SeasonEpisode'"

  if [[ -n "$SEASON" && -n "$EPISODE" ]]; then
    debug 'Using season & episode information from MythTV-DB or command-line.'
    Sxx="$SEASON"
    Exx="$EPISODE"
  else
    debug "No Season & Episode number information is available."
    return 1
  fi
  #Single digit episode and show names are not allowed Ex and Sx replaced with Sxx Exx
  if (( Sxx < 10 )); then Sxx="S0$Sxx"; else Sxx="S$Sxx"; fi
  if (( Exx < 10 )); then Exx="E0$Exx"; else Exx="E$Exx"; fi
  inform "Found Season ($Sxx) & Episode ($Exx) information."
  HasSxxExx='1'
  return 0
} #set_sxxexx_with_season_episode()

#Use regex to check for and make use of SxxExx info in Plot.
get_sxxexx_from_plot(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "SeasonEpisode: '$SeasonEpisode'"
  debugcont "SEASON: '$SEASON'"
  debugcont "EPISODE: '$EPISODE'"
  debugcont "Plot: '$Plot'"
  #If either SEASON or EPISODE have not been set, the season or
  #episode fields from MythTV database or command line, then attempt to extract
  #SeasonEpisode from Plot, SBS is big on including it in the plot/description
  #field instead of where it belongs.
  if [[ -z "$SEASON" || -z "$EPISODE" ]]; then
    debug 'Searching Plot for season & episode information.'
    #The below should work for any of the following forms, assumes season and
    #episode numbers in range 0-99:
    #S01E42 | (01x42) | s01e42 | 1X2 | S1E4 | (S01Ep42) | (S1Ep42) | 42x1 | (S.01Ep.42) | (S.01,Ep.42) | S1 E42
    local pattern='(s\.?[0-9]?[0-9]\,?\s?(e|ep)\.?[0-9][0-9]?)|([0-9]?[0-9]x[0-9][0-9]?)'
    if ! SeasonEpisode="$(grep -E -i --only-matching "$pattern" <<< "$Plot")"; then
      debug "Failed to extract season and episode info from Plot."
      return 1
    else
      debug "Found SeasonEpisode='$SeasonEpisode' in Plot."
      if [[ -n "$SeasonEpisode" ]]; then
        debug 'Using season & episode information extracted from Plot.'
        Sxx="$(grep -E -i --only-matching '(s\.?[0-9]?[0-9])|([0-9]?[0-9]x)' <<< "$SeasonEpisode" | sed 's/s\.\?\|x//I')"
        Exx="$(grep -E -i --only-matching '((e|ep)\.?[0-9][0-9]?)|(x[0-9][0-9]?)' <<< "$SeasonEpisode" | sed 's/\(E\.\?\|Ep\.\?\)\|x//I')"
        #Strip leading zero
        Sxx="${Sxx#0}"
        Exx="${Exx#0}"
        #Make sure SEASON and EPISODE are set consistently with Sxx and Exx.
        SEASON="$Sxx"
        EPISODE="$Exx"
        debugcont "SEASON = '$SEASON'"
        debugcont "EPISODE = '$EPISODE'"
      fi
      #TODO: Maybe add warning in the case of 4x4 in case it's not actually an SxxExx
    fi
  fi
  return 0
} #get_sxxexx_from_plot()

#If we already have season and episode info, remove it from the Plot field.
remove_sxxexx_from_plot(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  if [[ -n "$SeasonEpisode" ]]; then
    #Check if it's in the leading position and if so, remove it

    # local SEregex
    # local SEstring
    # SEregex="'(\(?s\.?[0-9]?[0-9]\,?\s?(e|ep)\.?[0-9][0-9]?\)?)\s*|(\(?[0-9]?[0-9]x[0-9][0-9]?\)?)\s*'"
    # SEstring="$(grep -E -i --only-matching "$SEregex" <<< "$Plot")"

    local SEstring
    SEstring="$(grep -E -i --only-matching '(\(?s\.?[0-9]?[0-9]\,?\s?(e|ep)\.?[0-9][0-9]?\)?)\s*|(\(?[0-9]?[0-9]x[0-9][0-9]?\)?)\s*' <<< "$Plot")"
    if [[ -n "$SEstring" ]]; then
      warn "${FUNCNAME[0]}(): SeasonEpisode found in Plot, removing it to simplify processing."
      Plot="${Plot/$SEstring/}"
      #Also remove any left over leading hyphen, colon, or space
      Plot="$(sed s/^"\s*[-|:]\?\s*"// <<< "$Plot")"
      #Remove any trailing space from the Plot
      Plot="${Plot%%*([[:space:]])}"
    fi
  else
    debug "SeasonEpisode is not currently set:"
    debugcont "So, either it is not there or we have not extracted it yet, not discarding from Plot field."
  fi
} #remove_sxxexx_from_plot()

#Try to extract a subtitle from the plot field (Luv Ya SBS)
get_subtitle_from_plot(){
  #This function works under the assumption that a Subtitle (EpisodeTitle) is prepended to
  #the Plot field of the guide data and that it is separated from the actual plot by either
  #' -' or ':'. This is often the case for FTA guide data from SBS Australia, and occasionally
  #for other Australian stations as well.
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #TODO: Allowing for a colon as well as the hyphen here causes problems for the various "NCIS: some other place"
  #TODO: Probably should do things conditionally based on whether or not we actually managed
  #  to extract a Subtitle. And maybe return failure state.
  SUBTITLE="$(grep -E --only-matching '^((((\w+)(.?\s*))|(\&\s*)){1,7})( -|\:)' <<< "$Plot")"
  #if [[ -n "$SUBTITLE" ]]; then
  #Clean off the trailing " -" or ":" that we're using to identify it
  SUBTITLE="$(grep -E --only-matching '(((\w+)(.?\s*))|(\&\s*)){,7}(\w+)' <<< "$SUBTITLE")"
  debug "Attempt to extract Subtitle from Plot field gave '$SUBTITLE'"
  #TODO: consider calling remove_subtitle_from_plot() from here, instead of return 1 below.
  return 0
  #else
    #inform "No Subtitle extracted from Plot field.
    #return 1
  #fi
} #get_subtitle_from_plot()

#Called after get_subtitle_from_plot(), it uses the same logic to...
remove_subtitle_from_plot(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #TODO: If we extracted a subtitle from Plot variable then remove that text from Plot.
  if [[ -n "$SUBTITLE" ]]; then
    local STstring
    STstring="$(grep -E --only-matching '^((((\w+)(.?\s*))|(\&\s*)){1,7})( -|\:)\s*' <<< "$Plot")"
    if [[ -n "$STstring" ]]; then
      warn "${FUNCNAME[0]}(): Episode subtitle was in the Plot field, removing it to simplify subsequent processing."
      Plot="${Plot/$STstring/}"
    fi
  else
    debug "SUBTITLE is not currently set, so not going to discard it from Plot field."
  fi
} #remove_subtitle_from_plot()

#Some Australian channels (ABC, I'm looking at you), put cast info at the end of the Plot.
remove_cast_from_plot(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local CastString
  CastString="$(grep -iE --only-matching '\.? CAST:? ((\w+)(.?\s*)){1,8}$' <<< "$Plot")"
  if [[ -n "$CastString" ]]; then
    warn "${FUNCNAME[0]}(): Plot field appears to contain Cast information, removing it to simplify subsequent processing."
    debug "Removing: '$CastString' from Plot."
    debugcont "Plot:'$Plot'"
    Plot="${Plot/$CastString/.}"
    debugcont "New Plot:'$Plot'"
  fi
} #remove_cast_from_plot()

############### FUNCTIONS TO BUILD myth2kodi's LOCAL DATABASE ################

#Get an up to date token for accessing TheTVDB v2 API.
get_tvdb_token(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  ((LOGLEVEL > 3)) && debugcont "APIkey: '$APIkey'"
  ((LOGLEVEL > 3)) && debugcont "TVDB_TOKEN: '$TVDB_TOKEN'"
  local curlPOST curlGET
  local current_time
  local token_last_updated=42 #A meaningless low number to start from...
  local token_json=''

  current_time="$(date +%s)"
  #If we already have a token, then load it.
  if [[ -f "$m2kdir/tvdb_token.json" ]]; then
    if ! jq -e 'has("Error")' "$m2kdir/tvdb_token.json" > /dev/null; then
      token_last_updated="$(jq -r '.updated' "$m2kdir/tvdb_token.json")"
      #Load our current local token.
      TVDB_TOKEN="$(jq -r '.token' "$m2kdir/tvdb_token.json")"
      debug "Token last updated: '$(date --date="@$token_last_updated")'"
    else
      debug 'We do not have an existing token.'
    fi
  fi

  #Tokens currently (2017-07-03) are supposed to last 24 hours and refreshing
  #a valid token with a GET is preferred over POSTing to login for a new one.
  if (( (current_time - token_last_updated)/3600 >= 24 )); then
    debug 'Doing full authentication to get a new token.'
    #Get a new token using our APIkey
    curlPOST="curl -s -m '$Timeout' -X POST --header 'Content-Type: application/json' -H 'Accept: application/json' -d"
    data=\'"{\"apikey\": \"$APIkey\"}"\'
    token_json="$(eval "$curlPOST $data 'https://api.thetvdb.com/login'")"
    if jq -e 'has("Error")' <<< "$token_json" > /dev/null; then
      err "${FUNCNAME[0]}(): An error was returned by TheTVDB when attempting to GET a new a token."
      return 1
    fi
  elif (( (current_time - token_last_updated)/3600 > 18 )); then
    debug 'Getting refreshed token using our current one:'
    ((LOGLEVEL > 3)) && debugcont "TVDB_TOKEN: '$TVDB_TOKEN'"
    #Get a refreshed token using our currently valid token (if current is older than 18 hours).
    curlGET="curl -s -m '$Timeout' -X GET --header 'Authorization: Bearer $TVDB_TOKEN' -H 'Accept: application/json'"
    token_json="$(eval "$curlGET 'https://api.thetvdb.com/refresh_token'")"
    if jq -e 'has("Error")' <<< "$token_json" > /dev/null; then
      err "${FUNCNAME[0]}(): An error was returned by TheTVDB when attempting to refresh a token."
      return 1
    fi
  fi

  if [[ -n "$token_json" ]]; then
    debug 'Using new token.'
    #Set the TVDB_TOKEN variable to the new token value.
    TVDB_TOKEN="$(jq -r '.token' <<< "$token_json")"
    if [[ -n "$TVDB_TOKEN" ]]; then
      #Write the new token and the update time to a file.
      jq --arg updated "$(date +%s)" '. + {updated: $updated}' <<< "$token_json" > "$m2kdir/tvdb_token.json"
    else
      err "${FUNCNAME[0]}(): Failed to retrieve a token from TheTVDB."
      return 1
    fi
  else
    debug 'Using existing token.'
  fi
  ((LOGLEVEL > 3)) && debug "TVDB_TOKEN: '$TVDB_TOKEN'."
  return 0
} #get_tvdb_token()

#Search TheTVDB for this recording's show name, then use the response
#to generate temporary text files for subsequent show identification.
download_series_identification(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local tvdbshowname
  #Format Show TITLE for Sending to www.TheTVDB.com
  tvdbshowname="$(sed 's/ /%20/g' <<< "$TITLE" | sed 's/&/%26/g' | sed 's/:/%3A/g' | sed 's/,/%2C/g')"
  local curlGET series_query
  curlGET="curl -s -m '$Timeout' -X GET -H 'Authorization: Bearer $TVDB_TOKEN' -H 'Accept: application/json' -H 'Accept-Language: $Language'"

  #Search TheTVDB and return an XML file with results
  inform "SEARCHING: www.TheTVDB.com for '$TITLE'"
  ((LOGLEVEL > 3)) && debug "QUERY WAS: $curlGET \"https://api.thetvdb.com/search/series?name=$tvdbshowname\""
  series_query="$(eval "$curlGET \"https://api.thetvdb.com/search/series?name=$tvdbshowname\"")"
  #TODO: it is possible to search by zap2itID as well... so consider doing that too.

  if [[ -z "$series_query" ]]; then
    err "${FUNCNAME[0]}(): Could not access info from TheTVDB."
    errcont "Check your internet connection."
  elif jq -e 'has("Error")' <<< "$series_query" > /dev/null; then
    err "${FUNCNAME[0]}(): An error was returned by TheTVDB."
    errcont "Check www.thetvdb.com for '$TITLE'."
    return 1
  fi

  #Create temporary files to hold the show ID and show name
  if ! TMP_SID_FILE="$(mktemp "$M2K_TMPDIR/m2k_sid_$FILE_NAME_NOW"-XXXX)"; then
    err "${FUNCNAME[0]}(): Failed to create temporary sid file."
    return 1
  fi
  if ! TMP_SHN_FILE="$(mktemp "$M2K_TMPDIR/m2k_shn_$FILE_NAME_NOW"-XXXX)"; then
    err "${FUNCNAME[0]}(): Failed to create temporary shn file."
    return 1
  fi
  declare -gr TMP_SID_FILE TMP_SHN_FILE

  #Write the id and seriesName to file for the series returned by our series-query.
  jq -r '.data[] | .id'         <<< "$series_query" > "$TMP_SID_FILE"
  jq -r '.data[] | .seriesName' <<< "$series_query" > "$TMP_SHN_FILE"

  return 0
} #download_series_identification()

#Check whether TheTVDB has updated information relative to myth2kodi's DB.
check_m2k_database_up_to_date(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Return state = 1 means the local database should be updated from TheTVDB
  #Return state = 0 means the local database is up to date with TheTVDB
  local dbdir="$m2kdir/$TVDB_TITLE"
  local tvdb_updates_list_file="$dbdir/tvdb_updates_list.json"
  local -i next_update=0
  local -i current_time=0

  #Do not be so demanding for updates of series that have Ended...
  if [[ -f "$dbdir/$TVDB_TITLE.series_status.txt" ]]; then
    local series_status
    series_status="$(<"$dbdir/$TVDB_TITLE.series_status.txt")"
    debug "The series has status='$series_status'."
    if [[ "${series_status,,}" = 'ended' ]]; then
      debugcont 'So extending the update period to about a month.'
      UpdateDatabase=2419200
      debugcont "NOTE: you can force an update with \"myth2kodi --series-info '$TVDB_TITLE'\"."
    fi
  fi

  #If file exist for last updated time, then get value
  if [[ -f "$dbdir/lastupdated.time" ]]; then
    LastUpdatedTVDB=$(<"$dbdir/lastupdated.time")
  else #no last updated time, so assign a never updated value and update now.
    debug "There is no lastupdated.time file."
    debugcont "So either we've never updated '$TVDB_TITLE' from TheTVDB, or"
    debugcont "an update is being forced with the --series-info flag."
    LastUpdatedTVDB=42 #A meaningless low number to start from...
    return 1
  fi

  #Add Database Update interval to last update time.
  next_update=$((LastUpdatedTVDB + UpdateDatabase))
  current_time="$(date +%s)"

  if ((current_time > next_update)); then
    #It has been longer than UpdateDatabase since our last update.

    #Updated queries return a maximum of 1 week after fromTime.
    if (( (current_time - LastUpdatedTVDB)/3600/24 >= 7 )); then
      inform 'It has been over a week since the last update, so forcing update.'
      return 1
    fi

    local updated_series updates_available list_last_updated

    #Find out when we last grabbed a list of recently updated series.
    if [[ -f "$tvdb_updates_list_file" ]]; then
      list_last_updated="$(jq -r .updated "$tvdb_updates_list_file")"
    else
      debug "Seems we do not have an updates-list from TheTVDB."
      list_last_updated=42 #A meaningless low number to start from...
    fi

    #Get a list of updated series.
    if (( (current_time - list_last_updated) < 3600 )); then
      #It has been less than an hour since we got a list so just use the local one.
      updated_series="$(jq -r . "$tvdb_updates_list_file")"
    else
      #It has been longer than an hour so GET a new list of updated series.
      local curlGET="curl -s -m '$Timeout' -X GET -H 'Authorization: Bearer $TVDB_TOKEN' -H 'Accept: application/json'"
      local updates_site="https://api.thetvdb.com/updated/query?fromTime=$LastUpdatedTVDB"
      updated_series="$(eval "$curlGET '$updates_site'")"
      jq --arg updated "$(date +%s)" '. + {updated: $updated}' <<< "$updated_series" > "$tvdb_updates_list_file"
    fi

    updates_available="$(jq "contains({data: [{id: $TVDB_SERIESID}]})" <<< "$updated_series")"
    if [[ "$updates_available" = 'true' ]]; then
      inform "Updates are available for TVDB_SERIESID: '$TVDB_SERIESID'."
      return 1
    else
      debug "No updates are available for TVDB_SERIESID: '$TVDB_SERIESID'."
      return 0
    fi
  else
    debug "Database maintained. Current: $current_time. Next update: $next_update."
    return 0
  fi
  #some other condition was present. update anyways.
  return 1
} #check_m2k_database_up_to_date()

#Prune entries from the series-list if the directory no-longer exists.
prune_series_list(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local title tvdb_id tvmaze_id line_number=0
  local title_tmp tvdbid_tmp tvmazeid_tmp

  #Create temporary files for our local-db summary info.
  if ! title_tmp="$(mktemp "$M2K_TMPDIR/m2k_title_list_$FILE_NAME_NOW"-XXXX)"; then
    err "${FUNCNAME[0]}(): Failed to create temporary series-title-list file."
    return 1
  fi
  if ! tvdbid_tmp="$(mktemp "$M2K_TMPDIR/m2k_tvdbid_list_$FILE_NAME_NOW"-XXXX)"; then
    err "${FUNCNAME[0]}(): Failed to create temporary series-tvdbid-list file."
    return 1
  fi
  if ! tvmazeid_tmp="$(mktemp "$M2K_TMPDIR/m2k_tvmazeid_list_$FILE_NAME_NOW"-XXXX)"; then
    err "${FUNCNAME[0]}(): Failed to create temporary series-tvmazeid-list file."
    return 1
  fi

  #Check the directory for each entry still exists, if it does not delete the entry.
  if [[ -f "$M2K_DB_LIST_TITLE" ]]; then
    while read -r title ; do
      ((++line_number))
      if [[ -d "$m2kdir/$title" ]]; then
        printf '%s\n' "$title" >> "$title_tmp"
        tvdb_id="$(sed -n "$line_number"'p' "$M2K_DB_LIST_TVDBID")"
        printf '%s\n' "$tvdb_id" >> "$tvdbid_tmp"
        tvmaze_id="$(sed -n "$line_number"'p' "$M2K_DB_LIST_TVMAZEID")"
        printf '%s\n' "$tvmaze_id" >> "$tvmazeid_tmp"
      fi
    done < "$M2K_DB_LIST_TITLE"
  fi
  mv "$title_tmp" "$M2K_DB_LIST_TITLE"
  mv "$tvdbid_tmp" "$M2K_DB_LIST_TVDBID"
  mv "$tvmazeid_tmp" "$M2K_DB_LIST_TVMAZEID"
  return 0
} #prune_series_list()

add_series_list_entry(){
  #Add series-list and seriesid-list entries if we haven't already.
  if ! grep -q "^$TVDB_TITLE$" "$M2K_DB_LIST_TITLE"; then
    printf '%s\n' "$TVDB_TITLE" >> "$M2K_DB_LIST_TITLE"
    printf '%s\n' "$TVDB_SERIESID" >> "$M2K_DB_LIST_TVDBID"
    printf '%s\n' "$TVMAZE_SERIESID" >> "$M2K_DB_LIST_TVMAZEID"
  fi
}

#Download series information from TheTVDB and tvmaze servers for the currently
#matched series, then use that information to generate or update myth2kodi's
#internal database-files for the series.
download_series_info(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  inform "Downloading Series: '$TVDB_SERIESID'"
  local -i new_series_info=0
  local -i new_info_tvdb=0
  local -i new_info_tvmaze=0
  local dbdir="$m2kdir/$TVDB_TITLE"
  local tvdb_series_json="$dbdir/${TVDB_TITLE}_series_info.json"
  local tvdb_episodes_json="$dbdir/${TVDB_TITLE}_tvdb.json"
  local tvmaze_episodes_json="$dbdir/${TVDB_TITLE}_tvmaze.json"
  local curlGET="curl --silent -m '$Timeout' -X GET -H 'Authorization: Bearer $TVDB_TOKEN' -H 'Accept: application/json'"
  local series_data
  local page=1  #Series episode data is returned paged.
  local -i plot_count
  local -i tvdb_episode_count
  local -i tvdb_plot_count
  local -i tvmaze_episode_count
  local -i tvmaze_plot_count

  #Grab information from TheTVDB for the series.
  debug "Accessing the series-level information from TheTVDB for '$TVDB_SERIESID'."
  series_data="$(eval "$curlGET 'https://api.thetvdb.com/series/$TVDB_SERIESID'")"
  jq -r . <<< "$series_data" > "${tvdb_series_json}.temp"
  if jq -e 'has("Error")' <<< "$series_data" > /dev/null; then
    err "${FUNCNAME[0]}(): An error was returned by TheTVDB when accessing series-data."
    errcont "TVDB_SERIESID: '$TVDB_SERIESID'."
    return 1
  fi

  #Check the new info is actually new, if there was no old info then it must be new.
  if [[ -f "$tvdb_series_json" ]]; then
    diff -q <(jq -c -S . "${tvdb_series_json}.temp") <(jq -c -S . "${tvdb_series_json}") &> /dev/null
    new_series_info="$?"
  else
    new_series_info=1
  fi
  if (( new_series_info == 1 )); then #NOTE: No-diff = 0; diff = 1; error = 2
    [[ -f "$tvdb_series_json" ]] && mv "$tvdb_series_json" "$dbdir/${TODAY}_${TVDB_TITLE}_series_info.json"
    mv "${tvdb_series_json}.temp" "$tvdb_series_json"
    #Remove any garbage newline characters -- mainly a problem for "plot" fields.
    sed -i.bak -e 's/\\r/ /g' -e 's/\\n/ /g' "$tvdb_series_json"
    jq -r '.data.status'      "$tvdb_series_json" > "$dbdir/$TVDB_TITLE.series_status.txt"
    jq -r '.data.firstAired'  "$tvdb_series_json" > "$dbdir/$TVDB_TITLE.series_firstaired.txt"
    jq -r '.data.lastUpdated' "$tvdb_series_json" > "$dbdir/$TVDB_TITLE.series_lastupdated.txt"
    jq -r '.data.zap2itId'    "$tvdb_series_json" > "$dbdir/$TVDB_TITLE.series_zap2itid.txt"
    jq -r '.data.overview'  "$tvdb_series_json"  \
        | sed -r 's/[^[:alnum:] &,.-]//g'        \
        | sed -r 's/^null$//'                    \
        | tr -s ' '  > "$dbdir/$TVDB_TITLE.series_overview.txt"
  elif (( new_series_info == 2 )); then
    err "An error occurred while diff-ing: '${tvdb_series_json}.temp' and '$tvdb_series_json'."
  elif (( new_series_info == 0 )); then
    debug 'No new series-level information is available.'
  fi

  #Trust the series level info and only update if it says there are updates.
  if [[ -f "$dbdir/lastupdated.time" && -f "$dbdir/$TVDB_TITLE.series_lastupdated.txt" ]]; then
    if (( $(<"$dbdir/lastupdated.time") > $(<"$dbdir/$TVDB_TITLE.series_lastupdated.txt") )); then
      inform "TheTVDB series.lastUpdated for $TVDB_TITLE was before our last download."
      printf '%s\n' "$(date +%s)" > "$dbdir/lastupdated.time" && chmod 644 "$dbdir/lastupdated.time"
      return 0
    fi
  fi

  #TODO: Should try to get jq to merge the pages rather than the manual hackery below.
  #Download the episode information from TheTVDB for TVDB_SERIESID
  debug "Accessing page '$page' of TheTVDB entry for '$TVDB_SERIESID'."
  series_data="$(eval "$curlGET 'https://api.thetvdb.com/series/$TVDB_SERIESID/episodes?page=$page'")"
  jq -r '.data' <<< "$series_data" | sed 's/]$//' > "${tvdb_episodes_json}.temp"
  if jq -e 'has("Error")' <<< "$series_data" > /dev/null; then
    err "${FUNCNAME[0]}(): An error was returned by TheTVDB."
    errcont "TVDB_SERIESID: '$TVDB_SERIESID'."
    errcont "page: '$page'."
    return 1
  fi
  page="$(jq .links.next <<< "$series_data")"
  while [[ "$page" != 'null' ]]; do
    debug "Accessing page '$page' of TheTVDB entry for '$TVDB_SERIESID'."
    series_data="$(eval "$curlGET 'https://api.thetvdb.com/series/$TVDB_SERIESID/episodes?page=$page'")"
    jq -r '.data' <<< "$series_data" | sed 's/^\[/,/' | sed 's/]$//' >> "${tvdb_episodes_json}.temp"
    if jq -e 'has("Error")' <<< "$series_data" > /dev/null; then
      err "${FUNCNAME[0]}(): An error was returned by TheTVDB."
      errcont "TVDB_SERIESID: '$TVDB_SERIESID'."
      errcont "page: '$page'."
      return 1
    fi
    page="$(jq .links.next <<< "$series_data")"
  done
  printf ']\n' >> "${tvdb_episodes_json}.temp"

  printf '%s\n' "$(date +%s)" > "$dbdir/lastupdated.time" && chmod 644 "$dbdir/lastupdated.time"

  #Check the new info is actually new, if there was no old info then it must be new.
  if [[ -f "$tvdb_episodes_json" ]]; then
    diff -q <(jq -c -S . "${tvdb_episodes_json}.temp") <(jq -c -S . "${tvdb_episodes_json}") &> /dev/null
    new_info_tvdb="$?" #NOTE: No-diff = 0; diff = 1; error = 2
  else
    new_info_tvdb=1
  fi

  if ((new_info_tvdb == 1)); then
    [[ -f "$tvdb_episodes_json" ]] && mv "$tvdb_episodes_json" "$dbdir/${TODAY}_${TVDB_TITLE}_tvdb.json"
    mv "${tvdb_episodes_json}.temp" "$tvdb_episodes_json"
  fi

  #Download the episode information from tvmaze for TVDB_SERIESID.
  if ((TVMAZE_SERIESID != 0)) ; then
    debug "Using TVMAZE_SERIESID: '$TVMAZE_SERIESID'"
    local tvmaze_episodes_site="http://api.tvmaze.com/shows/$TVMAZE_SERIESID/episodes"
    debug "Getting new tvmaze show info from: '$tvmaze_episodes_site'"
    curl -L -s -m"$Timeout" "$tvmaze_episodes_site" > "${tvmaze_episodes_json}.temp"
  else
    warn "Could not identify the TVMAZE_SERIESID for TVDB_SERIESID='$TVDB_SERIESID'."
  fi

  #Check the new info is actually new, if there was no old info then it must be new.
  if [[ -f "$tvmaze_episodes_json" ]]; then
    diff -q <(jq -c -S . "${tvmaze_episodes_json}.temp") <(jq -c -S . "${tvmaze_episodes_json}") &> /dev/null
    new_info_tvmaze="$?" #NOTE: No-diff = 0; diff = 1; error = 2
  else
    new_info_tvmaze=1
  fi

  if ((new_info_tvmaze == 1)); then
    [[ -f "$tvmaze_episodes_json" ]] && mv "$tvmaze_episodes_json" "$dbdir/${TODAY}_${TVDB_TITLE}_tvmaze.json"
    mv "${tvmaze_episodes_json}.temp" "$tvmaze_episodes_json"
  fi

  if ((new_info_tvdb == 2)) || ((new_info_tvmaze == 2)); then
    err "${FUNCNAME[0]}(): Comparing new to old data returned an error for '$TVDB_TITLE'"
    return 1
  elif ((new_info_tvdb == 0)) && ((new_info_tvmaze == 0)); then
    inform "TheTVDB information for $TVDB_TITLE has not changed since last download."
    return 0
  elif ((new_info_tvdb == 1)) || ((new_info_tvmaze == 1)); then
    inform "Downloaded new information for '$TVDB_TITLE'"

    #Remove any garbage newline characters -- mainly a problem for "plot" fields.
    sed -i.bak -e 's/\\r/ /g' -e 's/\\n/ /g' "$tvdb_episodes_json"

    #Parse new information into our local-db files.
    jq -r '.[] | .episodeName'        "$tvdb_episodes_json" > "$dbdir/$TVDB_TITLE.Ename.txt"
    jq -r '.[] | .airedSeason'        "$tvdb_episodes_json" > "$dbdir/$TVDB_TITLE.S.txt"
    jq -r '.[] | .airedEpisodeNumber' "$tvdb_episodes_json" > "$dbdir/$TVDB_TITLE.E.txt"
    jq -r '.[] | .firstAired'         "$tvdb_episodes_json" > "$dbdir/$TVDB_TITLE.FAired.txt"
    jq -r '.[] | .id'                 "$tvdb_episodes_json" > "$dbdir/$TVDB_TITLE.id.txt"

    [[ -f "$dbdir/$TVDB_TITLE.Plot.txt" ]] && rm -f "$dbdir/$TVDB_TITLE.Plot.txt"

    tvdb_episode_count="$(jq -r '.[] | .episodeName' "$tvdb_episodes_json" | wc -l)"
    inform "Local-DB contains '$tvdb_episode_count' entries from TheTVDB for '$TVDB_TITLE'."

    #Extract the overview field and write it to a Plot.txt file, "null" entries
    #become blank lines, keep only alpha-numeric characters and basic punctuation.
    jq -r '.[] | .overview' "$tvdb_episodes_json"   \
        | sed -r 's/[^[:alnum:] &,.-]//g'           \
        | sed -r 's/^null$//'                       \
        | tr -s ' ' > "$dbdir/$TVDB_TITLE.Plot.txt"

    tvdb_plot_count="$(wc -l < "$dbdir/$TVDB_TITLE.Plot.txt")"
    debug "Episode Count: $tvdb_episode_count; Plot Count: $tvdb_plot_count."
    if ((tvdb_episode_count!=tvdb_plot_count)); then
      err "Incompatible number of episodes parsing 'overview' field of '$tvdb_episodes_json'."
      errcont "Episode Count: $tvdb_episode_count; 'Overview' Count: $tvdb_plot_count."
    fi

    #If we also have a json file from tvmaze, then append that info
    if [[ -f "$tvmaze_episodes_json" ]]; then
      #Remove any garbage newline characters -- mainly a problem for "plot" fields.
      sed -i.bak -e 's/\\r/ /g' -e 's/\\n/ /g' "$tvmaze_episodes_json"

      jq -r '.[] | .name'    "$tvmaze_episodes_json" >> "$dbdir/$TVDB_TITLE.Ename.txt"
      jq -r '.[] | .season'  "$tvmaze_episodes_json" >> "$dbdir/$TVDB_TITLE.S.txt"
      jq -r '.[] | .number'  "$tvmaze_episodes_json" >> "$dbdir/$TVDB_TITLE.E.txt"
      jq -r '.[] | .airdate' "$tvmaze_episodes_json" >> "$dbdir/$TVDB_TITLE.FAired.txt"
      jq -r '.[] | .id'      "$tvmaze_episodes_json" >> "$dbdir/$TVDB_TITLE.id.txt"

      tvmaze_episode_count="$(jq -r '.[] | .name' "$tvmaze_episodes_json" | wc -l)"
      inform "Local-DB contains '$tvmaze_episode_count' entries from tvmaze for '$TVDB_TITLE'."

      #Extract the summary field and write it to a Plot.txt file, "null" entries
      #become blank lines, keep only alpha-numeric characters and basic punctuation.
      jq -r '.[] | .summary' "$tvmaze_episodes_json"   \
          | sed -r 's#</?p>##g'                        \
          | sed -r 's/[^[:alnum:] &,.-]//g'            \
          | sed -r 's/^null$//'                        \
          | tr -s ' ' >> "$dbdir/$TVDB_TITLE.Plot.txt"

      plot_count="$(wc -l < "$dbdir/$TVDB_TITLE.Plot.txt")"
      tvmaze_plot_count="$((plot_count-tvdb_plot_count))"
      debug "Episode Count: $tvmaze_episode_count; Plot Count: $tvmaze_plot_count."
      if ((tvmaze_episode_count!=tvmaze_plot_count)); then
        err "Incompatible number of episodes parsing 'overview' field of '$tvmaze_episodes_json'."
        errcont "Episode Count: $tvmaze_episode_count; 'Overview' Count: $tvmaze_plot_count."
      fi
    fi #[[ -f "$tvmaze_episodes_json" ]]

    #Set permission 644 (rw-r--r--)
    chmod 644 "$dbdir/$TVDB_TITLE.Ename.txt"
    chmod 644 "$dbdir/$TVDB_TITLE.S.txt"
    chmod 644 "$dbdir/$TVDB_TITLE.E.txt"
    chmod 644 "$dbdir/$TVDB_TITLE.FAired.txt"
    chmod 644 "$dbdir/$TVDB_TITLE.id.txt"
    chmod 644 "$dbdir/$TVDB_TITLE.Plot.txt"

    #Check that all files were created and have content.
    if [[ -s "$dbdir/$TVDB_TITLE.Ename.txt"  &&
          -s "$dbdir/$TVDB_TITLE.S.txt"      &&
          -s "$dbdir/$TVDB_TITLE.E.txt"      &&
          -s "$dbdir/$TVDB_TITLE.FAired.txt" &&
          -s "$dbdir/$TVDB_TITLE.id.txt"     &&
          -s "$dbdir/$TVDB_TITLE.Plot.txt" ]]; then
      inform "Local database updated: '$dbdir'."
      return 0
    else
      err "${FUNCNAME[0]}(): Failed to update local database for '$dbdir'."
      return 1
    fi
  fi #((new_info_tvdb == 1)) || ((new_info_tvmaze == 1))

  err "${FUNCNAME[0]}(): UNEXPECTED ERROR."
  return 1
} #download_series_info()

#Create myth2kodi's internal database directory for the current show.
make_m2k_database_dir(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  if [[ ! -d "$m2kdir/$TVDB_TITLE" ]]; then
    mkdir "$m2kdir/$TVDB_TITLE"
    #Set permission 755 (rwxr-xr-x)
    chmod 755 "$m2kdir/$TVDB_TITLE"
    inform "Created myth2kodi Database Folder: $m2kdir/$TVDB_TITLE"
  fi
} #make_m2k_database_dir()

############## FUNCTIONS TO PROCESS myth2kodi's LOCAL DATABASE ###############

#Check if we already have local information for this tv-series.
have_series_info(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "TITLE='$TITLE'"

  if grep -q "^$TITLE$" "$M2K_DB_LIST_TITLE"; then
    inform "We have existing info for: '$TITLE'"
    return 0
  else
    inform "No existing info for: '$TITLE'"
    return 1
  fi
} #have_series_info()

identify_series(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "RECORDING_TYPE='$RECORDING_TYPE'"
  debugcont "ONLINE_LOOKUP='$ONLINE_LOOKUP'"
  debugcont "TITLE='$TITLE'"
  debugcont "Zap2itSeriesID='$Zap2itSeriesID'"

  #Check our local list of TV-SERIES for an exact match.
  if have_series_info; then
    TVDB_TITLE="$TITLE"
    ConfidenceReasoning="$ConfidenceReasoning Have existing series info;"
    ((++SeriesConfidenceRating))
    local sln
    sln="$(grep -nix "$TITLE" "$M2K_DB_LIST_TITLE" | grep -m1 -o '^[0-9]*')"
    TVDB_SERIESID="$(sed -n "$sln"'p' "$M2K_DB_LIST_TVDBID")"
    TVMAZE_SERIESID="$(sed -n "$sln"'p' "$M2K_DB_LIST_TVMAZEID")"
    declare -gr TVDB_TITLE TVDB_SERIESID TVMAZE_SERIESID
    return 0
  fi

  #Process as though it's an episode of a tv series.
  if [[ "$ONLINE_LOOKUP" != 'Disabled' ]]; then
    #TODO: consider adding a zap2itId based query here when we have a Zap2ItID
    #Query TheTVDB on TITLE: retrieve fields seriesName and id.
    if download_series_identification; then
      ConfidenceReasoning="$ConfidenceReasoning Attempted Title match on Standard Logic:"
      if get_serieslinenumber_showname; then
        ((++SeriesConfidenceRating))
        ConfidenceReasoning="$ConfidenceReasoning Successful;"
      else
        warn "FAILED to get series line number with standard logic."
        ((--SeriesConfidenceRating))
        ConfidenceReasoning="$ConfidenceReasoning Failed; Attempted Title match on Fuzzy Logic:"
        if get_serieslinenumber_showname_fuzzy; then
          ConfidenceReasoning="$ConfidenceReasoning Successful;"
        else
          ((--SeriesConfidenceRating))
          ConfidenceReasoning="$ConfidenceReasoning Failed; Information not obtainable;"
        fi
      fi
    else
      SeriesConfidenceRating=-3
      ConfidenceReasoning="$ConfidenceReasoning Download series identification: Failed;"
    fi

    #if we have a series line number then translate that into a series id
    if [[ -n "$serieslinenumber" ]] && ((serieslinenumber > 0)); then
      set_tvdb_seriesid_title_from_serieslinenumber
      inform "Found: \"$TVDB_TITLE\" ID#: '$TVDB_SERIESID' with CONFIDENCE:'$SeriesConfidenceRating'"
      #In-case the match was fuzzy, take the title from TheTVDB.
      [[ -n "$TVDB_TITLE" ]] && TITLE="$TVDB_TITLE"
      #Get the tvmaze series-id corresponding to the TVDB_SERIESID.
      TVMAZE_SERIESID="$(curl -L -s -m"$Timeout" http://api.tvmaze.com/lookup/shows?thetvdb="$TVDB_SERIESID" | jq '.id')"
      declare -gr TVMAZE_SERIESID
      inform "Identified TVMAZE_SERIESID='$TVMAZE_SERIESID' for TVDB_SERIESID='$TVDB_SERIESID'."
      return 0
    else
      warn "TVDB_SERIESID could not be determined"
      #If we're not in debug mode then cleanup show identification files.
      [[ -f "$TMP_SID_FILE" ]] && (( LOGLEVEL < 3 )) && rm -f "$TMP_SID_FILE"
      [[ -f "$TMP_SHN_FILE" ]] && (( LOGLEVEL < 3 )) && rm -f "$TMP_SHN_FILE"
      return 1
    fi
  else
    debug 'Series identification via TheTVDB is disabled.'
    return 0
  fi
} #identify_series()

#Attempt to identify an AbsoluteEpisodeNumber based on the information we have.
identify_episode(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "RECORDING_TYPE='$RECORDING_TYPE'"
  debugcont "TVDB_TITLE='$TVDB_TITLE'"
  debugcont "SUBTITLE='$SUBTITLE'"
  debugcont "SEASON='$SEASON'"
  debugcont "EPISODE='$EPISODE'"
  debugcont "Plot='$Plot'"

  if [[ -n "$TVDB_TITLE" ]]; then
    #Try matching against SEASON and EPISODE numbers.
    if [[ "$MATCH_SEASON_EPISODE" != 'Disabled' && -n "$SEASON" && -n "$EPISODE" ]]; then
      ConfidenceReasoning="$ConfidenceReasoning Attempted SEASON and EPISODE match:"
      if set_absolute_episode_number_by_season_episode; then
        ConfidenceReasoning="$ConfidenceReasoning Successful;"
        ((++EpisodeConfidenceRating))
        return 0
      else
        ((--EpisodeConfidenceRating))
        ConfidenceReasoning="$ConfidenceReasoning Failed;"
      fi
    fi

    #Try to match against SUBTITLE (episode-title).
    if [[ "$MATCH_SUBTITLE" != 'Disabled' && -n "$SUBTITLE" ]]; then
      ConfidenceReasoning="$ConfidenceReasoning Attempted SUBTITLE exact match:"
      if set_absolute_episode_number_by_ename; then
        ConfidenceReasoning="$ConfidenceReasoning Successful;"
        ((++EpisodeConfidenceRating))
        return 0
      else
        ConfidenceReasoning="$ConfidenceReasoning Failed; Attempted SUBTITLE fuzzy match:"
        if set_absolute_episode_number_by_ename_fuzzy; then
          #NOTE: for fuzzy matching, multi_match_check() determines whether a
          #      match is reliable enough to increment EpisodeConfidenceRating.
          ConfidenceReasoning="$ConfidenceReasoning Successful;"
          return 0
        else
          ConfidenceReasoning="$ConfidenceReasoning Failed;"
        fi
      fi
    fi

    #Try matching against ORIGINALAIRDATE -- NOTE: this is US specific.
    if [[ "$MATCH_ORIGINALAIRDATE" != 'Disabled' && -n "$ORIGINALAIRDATE" ]]; then
      ConfidenceReasoning="$ConfidenceReasoning Attempted match on ORIGINALAIRDATE:"
      if set_absolute_episode_number_by_airdate; then
        ((++EpisodeConfidenceRating))
        ConfidenceReasoning="$ConfidenceReasoning Successful;"
        return 0
      else
        ((--EpisodeConfidenceRating))
        ConfidenceReasoning="$ConfidenceReasoning Failed."
      fi
    fi

    #Try matching against Plot.
    if [[ "$MATCH_PLOT" = 'Enabled' && -n "$Plot" ]]; then
      ConfidenceReasoning="$ConfidenceReasoning Attempted Plot fuzzy match:"
      if get_absolute_episode_number_fuzzy_plot; then
        #NOTE: for fuzzy matching, multi_match_check() determines whether a
        #      match is reliable enough to increment EpisodeConfidenceRating.
        ConfidenceReasoning="$ConfidenceReasoning Successful;"
        return 0
      else
        ConfidenceReasoning="$ConfidenceReasoning Failed;"
      fi
    fi
    warn "Failed to identify episode."
  else
    err 'Attempted episode match without TVDB_TITLE.'
  fi #[[ -n "$TVDB_TITLE" ]]
  ((EpisodeConfidenceRating -= 4))
  return 1
} #identify_episode()

#Check that the SUBTITLE, SEASON, and EPISODE we have set correspond to the same
#episode in the series table of our local-db.
validate_episode(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "RECORDING_TYPE='$RECORDING_TYPE'"
  debugcont "TVDB_TITLE='$TVDB_TITLE'"
  debugcont "SUBTITLE='$SUBTITLE'"
  debugcont "SEASON='$SEASON'"
  debugcont "EPISODE='$EPISODE'"
  debugcont "Plot='$Plot'"

  if [[ -n "$SUBTITLE" && -n "$SEASON" && -n "$EPISODE" ]]; then
    inform 'We appear to have full episode information, verifying against local-DB.'
  else
    warn "Trying to validate an episode for which we have incomplete information."
  fi

  local aen_backup="$AbsoluteEpisodeNumber"
  local aen_sxxexx aen_ename aen_ename_fuzzy aen_originalairdate
  if set_absolute_episode_number_by_season_episode; then aen_sxxexx="$AbsoluteEpisodeNumber"; fi
  if set_absolute_episode_number_by_ename;          then aen_ename="$AbsoluteEpisodeNumber"; fi
  if set_absolute_episode_number_by_ename_fuzzy;    then aen_ename_fuzzy="$AbsoluteEpisodeNumber"; fi
  if set_absolute_episode_number_by_airdate;        then aen_originalairdate="$AbsoluteEpisodeNumber"; fi
  debug 'Found:'
  debugcont "aen_sxxexx          = '$aen_sxxexx';"
  debugcont "aen_ename           = '$aen_ename';"
  debugcont "aen_ename_fuzzy     = '$aen_ename_fuzzy';"
  debugcont "aen_originalairdate = '$aen_originalairdate'."
  local AENguess=()
  local var
  local i=0
  for var in 'aen_sxxexx' 'aen_ename' 'aen_ename_fuzzy' 'aen_originalairdate'; do
    if [[ -n "${!var}" ]]; then { AENguess[i]="${!var}"; ((++i)); }; fi
  done
  multi_match_check
  local mmc_status="$?"
  [[ "$mmc_status" = '0' ]] && ((EpisodeConfidenceRating += ${#AENguess[@]}-1))
  AbsoluteEpisodeNumber="$aen_backup"
  return "$mmc_status"
} #validate_episode()

#Set the serieslinenumber by fuzzy logic matching the current TITLE
#variable against show names returned by querying TheTVDB.
get_serieslinenumber_showname_fuzzy(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "TITLE: '$TITLE'"
  debugcont "TMP_SHN_FILE: '$TMP_SHN_FILE'"
  debugcont "serieslinenumber: '$serieslinenumber'"
  #Some systems (Ubuntu) have an agrep that limits PATTERN to < 32 characters...
  serieslinenumber=$($M2K_AGREP -iBynk "${TITLE:0:29}" "$TMP_SHN_FILE" | grep -m1 -o '^[0-9]*')
  #Correct for serieslinenumber = ""
  [[ -z "$serieslinenumber" ]] && serieslinenumber=0

  #Get the seriesid based on the showname
  if ((serieslinenumber > 0)); then
    debug "Determined serieslinenumber='$serieslinenumber' for TITLE: '$TITLE'"
    return 0
  fi
  err "${FUNCNAME[0]}(): FAILED to determine serieslinenumber for TITLE: '$TITLE'"
  return 1
} #get_serieslinenumber_showname_fuzzy()

#Set the serieslinenumber by matching the current TITLE variable
#against show names returned by querying TheTVDB.
get_serieslinenumber_showname(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  serieslinenumber="$(grep -nix "$TITLE" "$TMP_SHN_FILE" | grep -m1 -o '^[0-9]*')"

  #Correct for serieslinenumber = ""
  [[ -z "$serieslinenumber" ]] && serieslinenumber=0
  #Get the seriesid based on the showname
  if ((serieslinenumber >= 1)); then return 0; else return 1; fi
} #get_serieslinenumber_showname()

#Sets the TVDB_SERIESID and TVDB_TITLE variables based on serieslinenumber.
set_tvdb_seriesid_title_from_serieslinenumber(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Get the seriesid based on the showname
  TVDB_SERIESID="$(sed -n "$serieslinenumber"'p' "$TMP_SID_FILE" | grep -m1 ^)"
  TVDB_TITLE="$(sed -n "$serieslinenumber"'p' "$TMP_SHN_FILE" | grep -m1 ^)"
  if [[ -n "$TVDB_TITLE" ]]; then
    TVDB_TITLE="${TVDB_TITLE//&amp;/&}"
    declare -gr TVDB_TITLE
  fi

  #If we're not in debug mode then cleanup show identification files.
  [[ -f "$TMP_SID_FILE" ]] && (( LOGLEVEL < 3 )) && rm -f "$TMP_SID_FILE"
  [[ -f "$TMP_SHN_FILE" ]] && (( LOGLEVEL < 3 )) && rm -f "$TMP_SHN_FILE"
} #set_tvdb_seriesid_title_from_serieslinenumber()

#Sets the AbsoluteEpisodeNumber variable by comparing MythTV's ORIGINALAIRDATE
#against the first aired information in myth2kodi's local database.
set_absolute_episode_number_by_airdate(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  AbsoluteEpisodeNumber=''
  if [[ -n "$ORIGINALAIRDATE" ]]; then
    AbsoluteEpisodeNumber="$(grep -n "$ORIGINALAIRDATE" "$m2kdir/$TVDB_TITLE/$TVDB_TITLE.FAired.txt" | grep -m1 -o '^[0-9]*')"
  fi
  #Account for original series airdate
  if [[ -n "$AbsoluteEpisodeNumber" ]] && ((AbsoluteEpisodeNumber > 0)); then
    local NumberOriginalAirdates
    #Account for original show airdate = first air date
    NumberOriginalAirdates=$(grep --count "$ORIGINALAIRDATE" "$m2kdir/$TVDB_TITLE/$TVDB_TITLE.FAired.txt")
    ((NumberOriginalAirdates > 1)) && return 1
    inform "Absolute Exx NR:$AbsoluteEpisodeNumber BASED ON AIRDATE:$ORIGINALAIRDATE"
    return 0
  fi
  return 1
} #set_absolute_episode_number_by_airdate()

#Set the AbsoluteEpisodeNumber by comparing SEASON and EPISODE against the
#series and episode number information in myth2kodi's local database.
set_absolute_episode_number_by_season_episode(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "AbsoluteEpisodeNumber: '$AbsoluteEpisodeNumber'"
  debugcont "TVDB_TITLE: \"$TVDB_TITLE\""
  debugcont "SEASON: '$SEASON'"
  debugcont "EPISODE: '$EPISODE'"

  AbsoluteEpisodeNumber=''
  local -a AENs
  local SxxAENs
  local ExxAENs
  SxxAENs=$(grep -nix "$SEASON"  "$m2kdir/$TVDB_TITLE/$TVDB_TITLE.S.txt" | cut -d':' -f1 )
  ExxAENs=$(grep -nix "$EPISODE" "$m2kdir/$TVDB_TITLE/$TVDB_TITLE.E.txt" | cut -d':' -f1 )
  #With multiple data sources we can get multiple AENs, just take the first data source:
  AENs=($(sort --numeric-sort <<< "$(comm -12 <(sort <<< "$SxxAENs") <(sort <<< "$ExxAENs"))"))
  AbsoluteEpisodeNumber="${AENs[0]}"
  if [[ -n "$AbsoluteEpisodeNumber" ]] && ((AbsoluteEpisodeNumber > 0)); then
    inform "Using SEASON and EPISODE determined AbsoluteEpisodeNumber: $AbsoluteEpisodeNumber"
    return 0
  fi
  warn "${FUNCNAME[0]}(): Failed to determine AbsoluteEpisodeNumber"
  return 1
} #set_absolute_episode_number_by_season_episode()

#Set the AbsoluteEpisodeNumber by matching SUBTITLE against
#the episode names (Ename) in myth2kodi's local database.
set_absolute_episode_number_by_ename(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "TVDB_TITLE = '$TVDB_TITLE'"
  debugcont "SUBTITLE = '$SUBTITLE'"

  [[ -z "$SUBTITLE" ]] && { warn "${FUNCNAME[0]}(): No SUBTITLE."; return 1; }

  AbsoluteEpisodeNumber=''
  AbsoluteEpisodeNumber="$(grep -nix "$SUBTITLE" "$m2kdir/$TVDB_TITLE/$TVDB_TITLE.Ename.txt" | grep -m1 -o '^[0-9]*')"
  if [[ -n "$AbsoluteEpisodeNumber" ]] && ((AbsoluteEpisodeNumber > 0)); then
    return 0
  fi
  return 1
} #set_absolute_episode_number_by_ename()

#Set the AbsoluteEpisodeNumber by fuzzy matching SUBTITLE
#against the episode names (Ename) in myth2kodi's local database.
set_absolute_episode_number_by_ename_fuzzy(){
  #TODO: we need some sort of regex to account for matches like
  #    'The Office' 'The Delivery, Part Two' -guide data
  #    'The Office' 'The Delivery (2)'       -TvDb data
  #  currently, the former would be associated with 'The Delivery (1)'
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "TVDB_TITLE = '$TVDB_TITLE'"
  debugcont "SUBTITLE = '$SUBTITLE'"

  if [[ -z "$SUBTITLE" ]]; then
    warn "${FUNCNAME[0]}(): No SUBTITLE."
    ((--EpisodeConfidenceRating))
    return 1
  fi

  local subtitle subtitle_length
  if $M2K_AGREP --version &> /dev/null ; then #Hacky: works because, so far, the agrep that limits PATTERN length to < 32 also lacks a --version flag.
    subtitle="$SUBTITLE"
  else
    subtitle="${SUBTITLE:0:28}"
  fi
  subtitle_length=$(wc --chars <<< "$subtitle")

  #set IFS to use line break as a delineator -- necessary for separating multiple agrep matches below.
  local IFS=$'\n'
  AbsoluteEpisodeNumber=''
  local -a fuzzy_ename_0=()
  local -a fuzzy_ename_1=()
  local -a fuzzy_ename=()
  local -a cost=()
  local -a all_cost_aen_guess=()
  declare -ga AENguess=()
  #To avoid "special" episodes of the form "Special: Related Episode Name" first
  #try and match the pattern from the start of the line.
  fuzzy_ename_0=($($M2K_AGREP -iByns "^${subtitle}" "$m2kdir/$TVDB_TITLE/$TVDB_TITLE.Ename.txt"))
  #Then, because some shows (eg Gotham) use two part names like "Chapter Name: Episode Name" and
  #guide-data can contain just the "Episode Name" we match without binding to the front of the
  #line. And as the SUBTITLE can contain character with special meanings in regex, we match
  #as a string literal (-k).
  fuzzy_ename_1=($($M2K_AGREP -iBynsk "${subtitle}" "$m2kdir/$TVDB_TITLE/$TVDB_TITLE.Ename.txt"))
  fuzzy_ename=("${fuzzy_ename_0[@]}" "${fuzzy_ename_1[@]}")
  #Extract our guessed AbsoluteEpisodeNumbers
  all_cost_aen_guess=($(cut -f1 -d":" <<< "$(printf '%s\n' "${fuzzy_ename[@]}")"))
  debugcont "$( IFS=','; printf '%s' "AbsoluteEpisodeNumber guesses: ${all_cost_aen_guess[*]}." )"
  cost=($(cut -f2 -d":" <<< "$(printf '%s\n' "${fuzzy_ename[@]}")"))
  debugcont "$( IFS=','; printf '%s' "Cost: ${cost[*]}." )"
  #Determine lowest cost match
  local -i min_cost=42
  for (( i = 0; i < ${#all_cost_aen_guess[@]}; i++ )) ; do
    ((cost[i] < min_cost)) && min_cost="${cost[i]}"
  done
  #Only keep AEN guesses that have the lowest cost
  local -i counter=0
  for (( i = 0; i < ${#cost[@]}; i++ )) ; do
    if ((cost[i] == min_cost)); then
      AENguess[counter]="${all_cost_aen_guess[i]}"
      ((++counter))
    fi
  done
  #Require a cost that is <= 1/3 the subtitle's length.
  if (( min_cost > (subtitle_length / 3) )); then
    warn 'Fuzzy subtitle match too fuzzy.'
    ((--EpisodeConfidenceRating))
    return 1
  fi
  #Check that multiple matches are actually the same episode.
  #NOTE: do not sort as we preferentially want the results of fuzzy_ename_0.
  multi_match_check
  return "$?"
} #set_absolute_episode_number_by_ename_fuzzy()

#Use agrep to match the whole guide-data plot against Plots in myth2kodi-DB.
#Returns: 2 on a failure that indicates $TVDB_TITLE.Plot.txt contains no plots;
#         0 if AbsoluteEpisodeNumber properly set; 1 otherwise.
fuzzy_plot_match(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "TVDB_TITLE: '$TVDB_TITLE'"
  debugcont "Plot: '$Plot'"
  debugcont "PlotLength: '$PlotLength'"
  local -a FuzzyPlot=()
  local -a cost=()
  #Fuzzy guess at plot, prepended with: "AbsoluteEpisodeNumber:cost:"
  FuzzyPlot=($($M2K_AGREP -iBynsk "$Plot" "$m2kdir/$TVDB_TITLE/$TVDB_TITLE.Plot.txt"))
  if [[ -z "${FuzzyPlot[0]}" ]]; then
    #This should only happen when TVDB_TITLE has no Plot info, so no point
    #continuing trying to match Plot.
    warn "${FUNCNAME[0]}(): No fuzzy match on Plot -- Possibly no Plot info for $TVDB_TITLE"
    ((--EpisodeConfidenceRating))
    return 2
  fi
  #Extract our guessed AbsoluteEpisodeNumber
  AENguess=($(cut -f1 -d":" <<< "$(printf '%s\n' "${FuzzyPlot[@]}")"))
  debugcont "$( IFS=','; printf '%s' "AbsoluteEpisodeNumber guesses: ${AENguess[*]}." )"
  cost=($(cut -f2 -d":" <<< "$(printf '%s\n' "${FuzzyPlot[@]}")"))
  debugcont "$( IFS=','; printf '%s' "Cost: ${cost[*]}." )"
  local -a MatchedPlot=()
  for (( i = 0; i < ${#AENguess[@]}; i++ )) ; do
    MatchedPlot[i]="$(sed -n "${AENguess[i]}"'p' "$m2kdir/$TVDB_TITLE/$TVDB_TITLE.Plot.txt")"
    (( $(wc --chars <<< "${MatchedPlot[i]}") < PlotLength )) && warn "${FUNCNAME[0]}(): MatchedPlot $i shorter than Plot."
    debugcont "MatchedPlot $i: ${MatchedPlot[i]}"
  done
  #TODO: Should check that MatchedPlot is longer than PlotLength, which is essentially what we're assuming below.
  #If the cost is less than a 1/3 of characters in the plot we're trying to match
  #then consider that good enough and validate. #TODO: figure out the critical ratio here.
  (( cost[0] <= (PlotLength / 3) )) && { multi_match_check ; return "$?"; }
  ((--EpisodeConfidenceRating))
  return 1
} #fuzzy_plot_match()

#Some agrep can't use a full Plot as a PATTERN. And sometimes full Plot matching
#misses simply because the text is reordered or the middle is chopped out. In
#these cases, something as simple as chopping up the Plot into 5 word blocks,
#overlapping by 3, testing the agrep cost for each chunk, and then taking all
#the chunks that match with a cost < ~20%. If all the matches are for the same
#episode, then we can be fairly confident that it's actually a matching Plot.
chunked_fuzzy_plot_match(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "TVDB_TITLE: '$TVDB_TITLE'"
  debugcont "Plot: '$Plot'"
  local -i PlotWords
  PlotWords=$(wc --words <<< "$Plot")
  local chunk=""
  local -i chunck_size=5
  local -i chunk_overlap=3
  local -i min_chunk_length=23 #Short chunks give false positives.
  local -i inv_error_rate=5 #10=>10%; 9=>~11%; 8=>~12.5%; 7=>~14%; 6=>~16.6%; 5=>20%; 4=>25%; 3=>~33%.
  local -i numchunks
  numchunks=$((PlotWords/(chunck_size-chunk_overlap)))
  local -i max_error_count=3 #Reset below specific per chunk.
  local -a fuzzychunk=()
  local -i good_chunk_count=0
  local -a ChunkGuesses=()
  local -a ChunkCosts=()
  local ChunkLength
  local -a GoodChunkGuesses=()
  debug "Attempting chunked fuzzy match."
  debugcont "PlotWords='$PlotWords'"
  debugcont "chunck_size='$chunck_size'"
  debugcont "chunk_overlap='$chunk_overlap'"
  debugcont "min_chunk_length='$min_chunk_length'"
  debugcont "inv_error_rate='$inv_error_rate'"
  debugcont "numchunks='$numchunks'"
  if ! $M2K_AGREP --version &> /dev/null ; then #Hacky: works because, so far, the agrep that limits PATTERN length to < 32 also lacks a --version flag.
    local truncate='true'
  fi
  local -i Counter=0
  for (( i = 0; i < numchunks; i++ )) ; do
    debugcont "i='$i'"
    n=$(((i)*(chunck_size-chunk_overlap)+1))
    debugcont "n='$n'"
    m=$((n+chunck_size-1))
    debugcont "m='$m'"
    chunk="$(cut -d" " -f$n-$m <<< "$Plot")"
    #Some systems have an agrep that limits PATTERN to < 32 characters...
    [[ "$truncate" = 'true' ]] && chunk="${chunk:0:29}"
    debugcont "chunk='$chunk'"
    ChunkLength=$(wc --chars <<< "$chunk")
    debugcont "ChunkLength='${ChunkLength}'"
    #Short chunks give false positives, so don't try.
    ((ChunkLength < min_chunk_length)) && continue
    max_error_count=$(( ChunkLength / inv_error_rate ))
    fuzzychunk=($($M2K_AGREP -iBynsk -e "$chunk" "$m2kdir/$TVDB_TITLE/$TVDB_TITLE.Plot.txt"))
    debugcont "$( IFS=','; printf '%s' "${FUNCNAME[0]}(): fuzzychunk ${#fuzzychunk[@]}: ${fuzzychunk[*]}." )"
    ChunkGuesses=($(cut -f1 -d":" <<< "$(printf '%s\n' "${fuzzychunk[@]}")"))
    debugcont "$( IFS=','; printf '%s' "${FUNCNAME[0]}(): ChunkGuesses ${#ChunkGuesses[@]}: ${ChunkGuesses[*]}." )"
    ChunkCosts=($(cut -f2 -d":" <<< "$(printf '%s\n' "${fuzzychunk[@]}")"))
    debugcont "$( IFS=','; printf '%s' "${FUNCNAME[0]}(): ChunkCosts ${#ChunkCosts[@]}: ${ChunkCosts[*]}." )"
    #TODO: consider weighting matches ((ChunkLength-ChunkCosts[0])) and having multi_match_check take them into account.
    #We only get multiple matches for multiple equal ChunkCosts, so they're all the same.
    #Generic chunks can potentially match a lot of episodes at low cost, this adds noise that we don't want to count.
    if ((ChunkCosts[0] <= max_error_count)) && ((${#ChunkGuesses[@]} <= 4)) ; then
      ((++good_chunk_count))
      for (( j = 0; j < ${#ChunkGuesses[@]}; j++ )) ; do
        GoodChunkGuesses[Counter]=${ChunkGuesses[j]} && ((++Counter))
      done
    fi
    #Do not use the last chunk if it is just a subset of the second last.
    ((m>=PlotWords)) && break
  done
  debug "$( IFS=','; printf '%s' "${FUNCNAME[0]}(): GoodChunkGuesses ${#GoodChunkGuesses[@]}: ${GoodChunkGuesses[*]}." )"

  #Need to be more conservative with the shorter(5) chunks we're now using, so,
  #require at least 2 chunks to have matches:
  (( good_chunk_count < 2 )) && { ((--EpisodeConfidenceRating)); return 1; }

  #If all ChunkGuess with ChunkCost < 10% are the same Absolute Episode Number
  AENguess=($(printf '%s\n' "${GoodChunkGuesses[@]}" | sort -n ))
  multi_match_check
  return "$?"
} #chunked_fuzzy_plot_match()

#Verify that any absolute-episode-number guesses are either all the same
#episode or if multiple distinct episodes were matched, accept the match
#provided that one episode represents >= 2/3 of the matches.
#Returns: 0 if AbsoluteEpisodeNumber properly set; 1 otherwise.
multi_match_check(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "TVDB_TITLE: '$TVDB_TITLE'"
  debugcont "$( IFS=','; printf '%s' "There are ${#AENguess[@]} AENguesses: ${AENguess[*]}." )"

  local -i match_count
  match_count="${#AENguess[@]}"

  if (( match_count == 0 )); then
    warn "${FUNCNAME[0]}(): Called with empty Absolute Episode Number guess."
    ((--EpisodeConfidenceRating))
    return 1
  elif (( match_count == 1 )) ; then
    debug "Called with only one Absolute Episode Number guess."
    AbsoluteEpisodeNumber="${AENguess[0]}"
    inform "${FUNCNAME[0]}(): Identified AbsoluteEpisodeNumber: $AbsoluteEpisodeNumber using ${FUNCNAME[1]}()."
    ((++EpisodeConfidenceRating))
    return 0
  elif (( match_count > 1 )); then
    debug "Multiple AbsoluteEpisodeNumber guesses matched plot, confirming they're the same episode before using."
    #If we've identified multiple AbsoluteEpisodeNumbers make sure they refer to the same episode.
    local SxxGuess
    local ExxGuess
    local -a SxxExxGuesses=()
    local -a uniqSxxExx=()
    local -i uniq_match_count

    #Gather series and episode numbers for each AENguess.
    for (( i = 0; i < match_count; i++ )) ; do
      ExxGuess="$(sed -n "${AENguess[i]}"'p' "$m2kdir/$TVDB_TITLE/$TVDB_TITLE.E.txt")"
      SxxGuess="$(sed -n "${AENguess[i]}"'p' "$m2kdir/$TVDB_TITLE/$TVDB_TITLE.S.txt")"
      #Single digit episode and show names are not allowed Ex and Sx replaced with Exx Sxx
      if ((ExxGuess < 10)); then ExxGuess="e0$ExxGuess"; else ExxGuess="e$ExxGuess"; fi
      if ((SxxGuess < 10)); then SxxGuess="s0$SxxGuess"; else SxxGuess="s$SxxGuess"; fi
      SxxExxGuesses[i]="${SxxGuess}${ExxGuess}"
    done

    uniqSxxExx=( $(printf '%s\n' "${SxxExxGuesses[@]}" | uniq ) )
    uniq_match_count="${#uniqSxxExx[@]}"
    debug "$( IFS=','; printf '%s' "There are '$uniq_match_count' matching episodes: ${uniqSxxExx[*]}." )"

    #If all matches are the same episode then just use it,
    if ((uniq_match_count == 1)); then
      #With multiple data sources we can get multiple AENs for the same episode, just take the first:
      AbsoluteEpisodeNumber=$(cut -f1 -d" " <<< "${AENguess[0]}")
      inform "${FUNCNAME[0]}(): Identified AbsoluteEpisodeNumber: $AbsoluteEpisodeNumber using ${FUNCNAME[1]}()."
      ((++EpisodeConfidenceRating))
      return 0
    elif (( uniq_match_count > 1 )); then
      local -i uniqSxxExxcount
      local most_common_match
      local -i most_common_match_count=0
      local -i aen_index
      #Get the most commonly occurring match
      for (( i = 0; i < uniq_match_count; i++ )) ; do
        uniqSxxExxcount="$(printf '%s\n' "${SxxExxGuesses[@]}" | grep -c "${uniqSxxExx[i]}")"
        if (( uniqSxxExxcount > most_common_match_count)); then
          most_common_match="${uniqSxxExx[i]}"
          most_common_match_count="$uniqSxxExxcount"
        fi
      done
      debug "most_common_match='$most_common_match'"
      debug "most_common_match_count='$most_common_match_count'"
      #Only accept the most common match if it represents >= 2/3 of the matches.
      #This means all matches if match_count < 3; 1 bad match for 3 <= match_count < 6.
      if (( (match_count*100)/most_common_match_count <= 150 )); then # 150=>2/3; 133=>3/4
        inform "Multiple matches, but $most_common_match_count out of $match_count are the same episode."
        for (( i = 0; i < match_count; i++ )) ; do
          [[ "${SxxExxGuesses[i]}" = "$most_common_match" ]] && { aen_index="$i"; break; }
        done
        debug "aen_index='$aen_index'"
        AbsoluteEpisodeNumber=$(cut -f1 -d" " <<< "${AENguess[$aen_index]}")
        inform "${FUNCNAME[0]}(): Identified AbsoluteEpisodeNumber: $AbsoluteEpisodeNumber using ${FUNCNAME[1]}()."
        #Bump episode confidence if match is greater than 80% consistent. 117=>85%; 125=>80%; 133~>75%.
        (( (match_count*100)/most_common_match_count <= 133 )) && ((++EpisodeConfidenceRating))
        return 0
      else
        debug "The AbsoluteEpisodeNumber guesses were different:"
        debugcont "AENguess = SxxExxGuesses"
        for (( i = 0; i < match_count; i++ )) ; do
          debugcont "${i}: ${AENguess[i]} = '${SxxExxGuesses[i]}'"
        done
        ((--EpisodeConfidenceRating))
        return 1
      fi #>=2/3
    fi #uniq_match_count
  fi #match_count
  #There are no guesses...
  err "${FUNCNAME[1]}():${FUNCNAME[0]}(): Something unexpected went wrong."
  errcont "Maybe accessing Season and Episode numbers failed."
  errcont "$( IFS=','; printf '%s' "There are ${#AENguess[@]} AENguesses: ${AENguess[*]}." )"
  errcont "Season number file:  '$m2kdir/$TVDB_TITLE/$TVDB_TITLE.S.txt'"
  errcont "Episode number file: '$m2kdir/$TVDB_TITLE/$TVDB_TITLE.E.txt'"
  ((--EpisodeConfidenceRating))
  return 1
} #multi_match_check()

#Identify episode by fuzzy matching MythTV-DB Plot against Plots in myth2kodi-DB.
get_absolute_episode_number_fuzzy_plot(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "AbsoluteEpisodeNumber: '$AbsoluteEpisodeNumber'"
  debugcont "TVDB_TITLE: '$TVDB_TITLE'"
  debugcont "Plot: '$Plot'"
  #TODO: Consider either keyword based match or stripping very common words (it, a, an, the, etc.) before current match as they just tend to add noise.
  #      This would require a cleansed plot file be generated for the series as well as cleansing the Plot variable...
  if [[ -z "$Plot" ]]; then
    err 'We do not have any Plot info.'
    ((--EpisodeConfidenceRating))
    return 1
  fi

  if [[ ! -f "$m2kdir/$TVDB_TITLE/$TVDB_TITLE.Plot.txt" ]]; then
    err "Myth2kodi's internal database contains no Plot file for '$TVDB_TITLE'."
    errcont "This probably means we failed to identify a TVDB_SERIESID. Either you need"
    errcont "to add a showTranslations entry, we've mistaken a Movie for an Episode,"
    errcont "or this is a one off showing like news or a sports event."
    ((--EpisodeConfidenceRating))
    return 1
  fi

  AbsoluteEpisodeNumber=''
  #set IFS to use line break as a delineator -- necessary for separating multiple agrep matches below.
  local IFS=$'\n'
  local -i PlotLength
  local -a AENguess=()
  local -i fuzzy_plot_return_status=0
  #Length of the plot we're trying to match
  PlotLength=$(wc --chars <<< "$Plot")
  debugcont "PlotLength: '$PlotLength'"
  #If Plot length is short this really won't work well, so give up #TODO: figure out what length is genuinely too short...
  if ((PlotLength<42)); then
    warn "${FUNCNAME[0]}(): Plot is too short to attempt fuzzy guess."
    ((--EpisodeConfidenceRating))
    return 1
  fi

  #If our agrep supports it, try a full Plot match.
  if $M2K_AGREP --version &> /dev/null ; then #Hacky: works because, so far, the agrep that limits PATTERN length to < 32 also lacks a --version flag.
    if ((PlotLength<=200)); then
      fuzzy_plot_match
      fuzzy_plot_return_status="$?"
      if [[ "$fuzzy_plot_return_status" =~ ^('0'|'2')$ ]]; then
        return "$fuzzy_plot_return_status"
      fi
    else
      inform "Plot too long ($PlotLength) for efficient whole plot match."
    fi
  else
    warn "This version of agrep limits PATTERN to < 32 characters, so cannot do complete Plot match."
  fi

  warn "${FUNCNAME[0]}(): AbsoluteEpisodeNumber guess from full Plot failed or too fuzzy, trying chunked match."

  #Try matching small chunks of the plot.
  if ! chunked_fuzzy_plot_match; then
    warn "${FUNCNAME[0]}(): Chunked Plot match is still too fuzzy, failed to guess AbsoluteEpisodeNumber."
    return 1
  fi
  return 0
} #get_absolute_episode_number_fuzzy_plot()

storagegroup_fallback(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #If it's not tagged as a Movie but lacking SxxExx and then as a fallback check storagegroup in case it's a Movie we missed
  if [[ "$StorageGroupFallback" = 'Enabled' ]]; then
    debug "StorageGroupFallback is Enabled"
    if [[ "$RECORDING_TYPE" != 'MV' && "$HasSxxExx" != '1' ]]; then
      if grep -iq '\(Movies*\|Films*\)' <<< "$MDB_STORAGEGROUP" ; then
        inform "GUESSING that this is a Movie based on being in storagegroup: '$MDB_STORAGEGROUP'"
        RECORDING_TYPE="MV"
        ProgramIDType="Movie"
        ((--ConfidenceRating)) #Decrement confidence, because this is a guess.
        ConfidenceReasoning="$ConfidenceReasoning Possible misidentified Movie, overriding Guide Data, Guess; "
      fi
    fi
  fi
} #storagegroup_fallback()

######################### MESSAGE/REPORT FUNCTIONS ###########################

#Appends an entry to today's DailyReport file for the show just processed.
dailyreport(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  if [[ "$DailyReport" = 'Enabled' ]]; then
    [[ ! -d "$m2kdir/DailyReport" ]] && mkdir "$m2kdir/DailyReport"
    debug "Writing to DailyReport file: ${TODAY}"
    printf '%s\n' "$SCRIPT_START_TIME - $ShowFileName" >> "$m2kdir/DailyReport/${TODAY}"
    return "$?"
  fi
  return 0
} #dailyreport()

#Prints a table summarising the status of important directories.
msg_dir_summary(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  informcont "A summary table of writeable directories: 0='WRITEABLE' ; 1='NOT WRITEABLE'"
  informcont "$(printf '%-18s|%-5s|%-12s|%s\n'     "USER SETTING"      "FLAG"                 "Free Space"               "Folder name"       )"
  informcont "$(printf '%-18s|  %s  | %10s | %s\n' "m2kdir"            "$WorkingDirWritable"  "$WorkingDirFreeSpace MB"  "$m2kdir"           )"
  informcont "$(printf '%-18s|  %s  | %10s | %s\n' "M2K_TMPDIR"        "$TempDirWritable"     "$TempDirFreeSpace MB"     "$M2K_TMPDIR"       )"
  informcont "$(printf '%-18s|  %s  | %10s | %s\n' "ORIGINAL_DIRNAME"   "$OriginalDirWritable" "$OriginalDirFreeSpace MB" "$ORIGINAL_DIRNAME"  )"
  informcont "$(printf '%-18s|  %s  | %10s | %s\n' "MoveDir"           "$MoveDirWritable"     "$MoveDirFreeSpace MB"     "$MoveDir"          )"
  informcont "$(printf '%-18s|  %s  | %10s | %s\n' "AlternateMoveDir"  "$AltMoveDirWritable"  "$AltMoveDirFreeSpace MB"  "$AlternateMoveDir" )"
  informcont "$(printf '%-18s|  %s  | %10s | %s\n' "PrimaryMovieDir"   "$MovieDirWritable"    "$MovieDirFreeSpace MB"    "$PrimaryMovieDir"  )"
  informcont "$(printf '%-18s|  %s  | %10s | %s\n' "AlternateMovieDir" "$AltMovieDirWritable" "$AltMovieDirFreeSpace MB" "$AlternateMovieDir")"
  informcont "$(printf '%-18s|  %s  | %10s | %s\n' "PrimaryShowDir"    "$ShowDirWritable"     "$ShowDirFreeSpace MB"     "$PrimaryShowDir"   )"
  informcont "$(printf '%-18s|  %s  | %10s | %s\n' "AlternateShowDir"  "$AltShowDirWritable"  "$AltShowDirFreeSpace MB"  "$AlternateShowDir" )"
  return 0
} #msg_dir_summary()

#A message summarizing myth2kodi's operation
msg_operation_summary(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  inform "################ OPERATION SUMMARY ################"
  informcont "JOB: myth2kodi '$M2KARG1' \"$M2KARG2\" \"$M2KARG3\" \"$M2KARG4\" '$M2KARG5'"
  debugcont  "m2kVersion=$m2kVersion-"
  informcont "CALLER=$CALLER-"
  debugcont  "m2kdir=$m2kdir-"
  debugcont  "Timeout=$Timeout-"
  ((LOGLEVEL > 3)) && debugcont  "APIkey=$APIkey-"
  informcont "PROCESS_RECORDING_MODE=$PROCESS_RECORDING_MODE-"
  informcont "SYMLINK=$SYMLINK-"
  debugcont "TargetPathIsInputPath=$TargetPathIsInputPath-"
  debugcont "FailSafeMode=$FailSafeMode-"
  debugcont  "FailSafeDir=$FailSafeDir-"
  debugcont  "Notify=$Notify-"

  #Print a summary table of writeable directories.
  ((LOGLEVEL>2)) && msg_dir_summary

  informcont "RECORDING_PATH=$RECORDING_PATH-"
  informcont "TVDB_SERIESID=$TVDB_SERIESID-"
  informcont "TVMAZE_SERIESID=$TVMAZE_SERIESID-"
  informcont "TITLE=$TITLE-"
  debugcont "INPUT_TITLE=$INPUT_TITLE-"
  [[ "$Database" = 'Enabled' ]] && debugcont "MDB_TITLE=$MDB_TITLE-"
  debugcont "TVDB_TITLE=$TVDB_TITLE-"
  informcont "SUBTITLE=$SUBTITLE-"
  debugcont "INPUT_SUBTITLE=$INPUT_SUBTITLE-"
  [[ "$Database" = 'Enabled' ]] && debugcont "MDB_SUBTITLE=$MDB_SUBTITLE-"
  debugcont "TVDB_SUBTITLE=$TVDB_SUBTITLE-"
  informcont "SEASON=$SEASON-"
  debugcont "INPUT_SEASON=$INPUT_SEASON-"
  [[ "$Database" = 'Enabled' ]] && debugcont "MDB_SEASON=$MDB_SEASON-"
  debugcont "TVDB_SEASON=$TVDB_SEASON-"
  informcont "EPISODE=$EPISODE-"
  debugcont "INPUT_EPISODE=$INPUT_EPISODE-"
  [[ "$Database" = 'Enabled' ]] && debugcont "MDB_EPISODE=$MDB_EPISODE-"
  debugcont "TVDB_EPISODE=$TVDB_EPISODE-"
  debugcont "Sxx=$Sxx- Exx=$Exx-"
  debugcont  "LastUpdatedTVDB=$LastUpdatedTVDB-"
  debugcont  "Current Time=$(date +%s)-"
  debugcont  "AbsoluteEpisodeNumber=$AbsoluteEpisodeNumber-"
  debugcont "HasSxxExx=$HasSxxExx-"
  informcont "MoveFileSize=$MoveFileSize MB"
  informcont "ConfidenceRating=$ConfidenceRating-"
  informcont "ConfidenceReasoning=$ConfidenceReasoning-"
  if [[ "$Database" = 'Enabled' ]]; then
    debugcont  "MDB_XMLTVGRABBER=$MDB_XMLTVGRABBER-"
    informcont "MDB_STARTTIME=$MDB_STARTTIME-"
    debugcont  "MDB_AIRDATE=$MDB_AIRDATE-"
    debugcont  "ORIGINALAIRDATE=$ORIGINALAIRDATE-"
    informcont "MDB_PROGRAMID=$MDB_PROGRAMID-"
    debugcont  "MDB_CHANID=$MDB_CHANID-"
    informcont "MDB_RECGROUP=$MDB_RECGROUP-"
    informcont "MDB_STORAGEGROUP=$MDB_STORAGEGROUP-"
    informcont "MDB_CATEGORY=$MDB_CATEGORY-"
    informcont "ProgramIDType=$ProgramIDType-"
    debugcont  "RATING=$RATING-"
    informcont "Zap2itSeriesID=$Zap2itSeriesID-"
    debugcont  "MDB_SERIESID=$MDB_SERIESID-"
    informcont "Plot=$Plot-"
    if [[ -n "$AbsoluteEpisodeNumber" ]]; then
      informcont "Matched Plot=$(sed -n "$AbsoluteEpisodeNumber"'p' "$m2kdir/$TVDB_TITLE/$TVDB_TITLE.Plot.txt")-"
    fi
  fi
  inform "################ END OF OPERATION SUMMARY ################"
  return 0
} #msg_operation_summary()

#An error message when we were called as a MythTV userjob from outside
#MythTV, then exit.
msg_userjob_outside_mythtv_error(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  NOTIFY_MSG="Called as MythTV user job outside of MythTV."
  err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
  errcont "MythTV User Job is only valid when run as a user job by MythTV."
  errcont "When outside MythTV call the file directly, see."
  errcont "  myth2kodi --usage"
  EXIT_JOB_TYPE='InvalidCall'
  return 1
} #msg_userjob_outside_mythtv_error()

#TODO: review this message function... particularly in relation to msg_unable_to_identify_recording() and msg_unrecognised_series()
#A warning message for when RECORDING_TYPE="SH"
msg_show_warning(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  inform     "Recording was tagged as a show, ie, not a movie or a"
  informcont "recognised episode of a series."
  informcont "TYPE: $ProgramIDType- $TITLE, $SUBTITLE"
  warn "RECORDING_TYPE='SH', this can occur due to incomplete guide data."
  return 0
} #msg_show_warning()

#An error message for when information can't be obtained about a recording.
msg_unable_to_identify_recording(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  err     "Operation failed, unable to identify episode info for recording:"
  errcont "     $RECORDING_PATH"
  informcont "This means that insufficient information was provided to myth2kodi"
  informcont "and the missing information could not be determined by other means."
  informcont "If you know the correct information, provide it at the command line,"
  informcont "    see: myth2kodi --usage"
  informcont "Normally myth2kodi can determine this information from:"
  informcont "    your MythTV-DB; TheTVDB; or tvmaze."
  informcont "Check that information on www.TheTVDB.com is complete for this series."
  informcont "#### If not, Please consider helping out and adding to TheTVDB. ####"
  if [[ -n "$TVDB_SERIESID" ]]; then
    informcont "#### http://www.thetvdb.com/?tab=series&amp;id=$TVDB_SERIESID           ####"
  fi
  informcont "To force processing of unrecognised recordings, disable ShowStopper."
  NOTIFY_MSG="Could not fully identify: $TITLE."
} #msg_unable_to_identify_recording()

#
msg_unrecognised_series(){
  ConfidenceReasoning="$ConfidenceReasoning Failed;"
  warn 'TVDB_SERIESID was not found.'
  if [[ "$ONLINE_LOOKUP" != 'Disabled' ]]; then
    warncont 'TheTVDB may be down.'
  else
    warncont "You may lack series-info for '$TITLE'."
  fi
  warncont "Check '$TITLE' on TheTVDB, you may need a showTranslations file."
  printf '%s\n' "$TITLE" >> "$UnrecognizedSeriesFile"
  if [[ "$Database" = 'Enabled' ]]; then
    warncont "RECSTART: '$MDB_STARTTIME'"
    warncont "Air Date: '$MDB_AIRDATE'"
    warncont "Original Air Date: '$MDB_ORIGINALAIRDATE'"
    warncont "Channel ID: '$MDB_CHANID'"
    warncont "Category: '$MDB_CATEGORY'"
    [[ -z "${Exx:2:1}" ]] && Exx=''
  fi
  return 0
} #msg_unrecognised_series()

#A message for when we've successfully moved a recording.
msg_completed_move(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  inform "Move completed."
  informcont "Moved: $RECORDING_PATH"
  informcont "To: $MoveDir/$ShowFileName.$ORIGINAL_EXT"
  if [[ "$SYMLINK" != 'Disabled' ]]; then
    informcont "Added symbolic link from: $RECORDING_PATH"
    informcont "To: $MoveDir/$ShowFileName.$ORIGINAL_EXT"
  fi
  NOTIFY_MSG="myth2kodi Success $ShowFileName moved to $MoveDir"
  EXIT_JOB_TYPE='MoveModeSuccessful'
  return 0
} #msg_completed_move()

#A message for when we've successfully copied a recording.
msg_completed_copy(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  inform "Copy completed."
  informcont "Copied: $RECORDING_PATH"
  informcont "To: $MoveDir/$ShowFileName.$ORIGINAL_EXT"
  NOTIFY_MSG="myth2kodi Success $ShowFileName copied to $MoveDir"
  EXIT_JOB_TYPE='CopyModeSuccessful'
  return 0
} #msg_completed_copy()

#A warning message for when a recording was thought to be an episode but
#no episode information could be obtained.
msg_epishow(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  warn     "SHOW WAS CONSIDERED AN EPISODE BUT INFORMAITON WAS NOT OBTAINABLE"
  warncont "%%%% Please consider helping out and adding to TheTVDB %%%%"
  warncont "HANDLING EPISODE AS GENERAL SHOWING & DUMPING INTO --doover USER JOB"
} #msg_epishow()

#An error message for when the path/file we've been asked to process doesn't exist
msg_invalid_path_error(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local path_to_check="$1"
  err     "OPERATION FAILED, PATH OR FILE DOES NOT EXIST, CHECK NAME AND PERMISSIONS:"
  errcont "'$path_to_check'"
} #msg_invalid_path_error()

#An error message for when the moved file has zero length (either the
#original had zero length or we failed to move it).
msg_wrote_zero_length_file(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  NOTIFY_MSG="$ShowFileName.$ORIGINAL_EXT could not be moved to $MoveDir"
  err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
  EXIT_JOB_TYPE='ZeroLengthFile'
} #msg_wrote_zero_length_file()

#TODO: Consider merging the following three message functions into one function,
#      they're highly redundant.

#An error message for when issues are encountered during moving
msg_permission_error_while_moving(){
  #TODO: review this message, see also check_path_permission()
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  NOTIFY_MSG="MOVE FAILED: $ShowFileName could not be moved to $MoveDir"
  err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
  errcont "Possible permission error while moving $ShowFileName"
  EXIT_JOB_TYPE='MoveFailed'
} #msg_permission_error_while_moving()

#An error message for when issues are encountered during copying
msg_permission_error_while_copying(){
  #TODO: review this message, see also check_path_permission()
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  NOTIFY_MSG="COPY FAILED: $ShowFileName could not be copied to $MoveDir"
  err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
  errcont "Possible permission error while copying $ShowFileName"
  EXIT_JOB_TYPE='CopyFailed'
} #msg_permission_error_while_copying()

#An error message for when we've failed to create a symlink
msg_symlink_not_created(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  NOTIFY_MSG="SYMLINKING FAILED: Failure while creating link. Check permissions."
  err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
  errcont " Possible permission error while linking $ShowFileName"
  errcont "Check that file system supports symlinks: $MoveDir"
  EXIT_JOB_TYPE='LinkingFailed'
} #msg_symlink_not_created()

#--recording-info
msg_recording_info(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  printf '\n%s\n\n' "MythTV-DB information for: $INPUT_PATH_BASENAME"
  printf '%s\n' "  Title=\"$MDB_TITLE\""
  printf '%s\n' "  Subtitle=\"$MDB_SUBTITLE\""
  printf '%s\n' "  Season='$MDB_SEASON'"
  printf '%s\n' "  Episode='$MDB_EPISODE'"
  printf '%s\n' "  Airdate='$MDB_AIRDATE'"
  printf '%s\n' "  Originalairdate='$MDB_ORIGINALAIRDATE'"
  printf '%s\n' "  Category='$MDB_CATEGORY'"
  printf '%s\n' "  Recordinggroup='$MDB_RECGROUP'"
  printf '%s\n' "  Storagegroup='$MDB_STORAGEGROUP'"
  printf '%s\n' "  Stars='$MDB_STARS'"
  printf '%s\n' "  Description=\"$MDB_DESCRIPTION\""
  printf '%s\n' "  Seriesid='$MDB_SERIESID'"
  printf '%s\n' "  Programid='$MDB_PROGRAMID'"
  printf '%s\n' "  Chanid='$MDB_CHANID'"
  printf '%s\n' "  Starttime='$MDB_STARTTIME'"
  if [[ "$CommercialMarkup" = 'Created' ]]; then
    printf '\n%s\n' "Commercial Skip Info"
    tail -n +2 "$MARKUPFRAMES_TMP"
    printf '\n'
  fi
} #msg_recording_info()

#Report the combination of command line input and MythTV-DB data.
msg_merged_input_mythtvdb(){
  debug "Input and MythTV-DB guide data for $INPUT_PATH_BASENAME"
  [[ "$Database" = 'Enabled' ]] && debugcont "RECSTART:'$MDB_STARTTIME'"
  [[ "$Database" = 'Enabled' ]] && debugcont "DATE:'$MDB_AIRDATE' '$ORIGINALAIRDATE'"
  [[ "$Database" = 'Enabled' ]] && debugcont "PROGRAMID:'$MDB_PROGRAMID'"
  [[ "$Database" = 'Enabled' ]] && debugcont "CATEGORY:'$CATEGORY'"

  local var value
  for var in 'TITLE' 'SUBTITLE' 'SEASON' 'EPISODE'; do
    if [[ -n "${!var}" ]]; then value="${!var}"; else value='UNKNOWN'; fi
    debugcont "$var:'$value'"
  done

  [[ "$Database" = 'Enabled' ]] && debugcont "Plot: \"$Plot\""
} #msg_merged_input_mythtvdb()

#A warning message about performing maintenance that waits on user input
#before proceeding
maintenance_warning(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local yesorno=""
  warn "  --You have entered Maintenance mode."
  warncont "  myth2kodi will perform maintenance on its records."
  warncont "  Please ensure that All network attached storage and removable"
  warncont "  storage drives are connected and mounted properly before continuing"
  read -r -n1 -p "Do you want myth2kodi to perform maintenance? y/(n)>" yesorno
  printf '\n'
  if [[ "$yesorno" != 'y' ]]; then
    inform "You must press 'y' to continue"
    return 1
  fi
  return 0
} #maintenance_warning()

cleanse_warning(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local yesorno=""
  inform "  --You have requested myth2kodi's working directory to be cleansed."
  informcont "  myth2kodi will PERMANENTLY REMOVE archived log files, myth2kodi"
  informcont "  database files, and daily report files older than specified by"
  informcont "  the user settings: LOG_LIFE; M2K_DB_LIFE; and DAILYREPORT_LIFE."
  read -r -n1 -p "Do you want myth2kodi to cleanse its working directory? y/(n)>" yesorno
  printf '\n'
  if [[ "$yesorno" != 'y' ]]; then
    inform "You must press 'y' to continue"
    return 1
  fi
  return 0
} #cleanse_warning()

target_directory_not_writeable(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local target_type="$1"
  FailSafeState=1
  NOTIFY_MSG="$target_type target directories not writeable."
  EXIT_JOB_TYPE='PermissionError'
  err "${FUNCNAME[1]}() CALLED FROM: ${FUNCNAME[2]}(): $NOTIFY_MSG"
} #target_directory_not_writeable()

target_file_exists(){
  err "FILE NAME ALREADY EXISTS:"
  errcont "FILE NAME:$MoveDir/$ShowFileName.$ORIGINAL_EXT"
  errcont "CALLED AS: myth2kodi '$M2KARG1' \"$M2KARG2\" \"$M2KARG3\" \"$M2KARG4\" '$M2KARG5'"
  errcont "TITLE: $TITLE"
  errcont "SUBTITLE: $SUBTITLE"
  errcont "SEASON: $SEASON"
  errcont "EPISODE: $EPISODE"
  errcont "Plot: $Plot"

  EXIT_JOB_TYPE='FileAlreadyExists'
  local -i recording_name_return_state

  #Identify any MythTV file name associated with the already existing move target.
  set_recording_name "$MoveDir/$ShowFileName.$ORIGINAL_EXT"
  recording_name_return_state="$?"

  if [[ "$recording_name_return_state" = '0' && -n "$RECORDING_NAME" ]]; then
    if [[ "$RECORDING_NAME" = "$INPUT_PATH_BASENAME" ]]; then
      err "This is because we've already processed this recording."
      NOTIFY_MSG="Recording has already been processed: $INPUT_PATH_BASENAME"
      return 0
    else
      inform "The recording we're processing is different to the one associated"
      informcont "with the already existing file. Meaning, either we've rerecorded"
      informcont "the same episode/movie or our file name generation is too generic."
    fi
  else
    inform "Cannot tell if this is due to reprocessing a recording or there was"
    informcont "just already a copy of this episode/movie in our media library."
  fi
  warn "Adding an entry identifying this recording as a possible duplicate."
  #Write an entry in the duplicates file, for easy check/removal of duplicates.
  printf '"%s" "%s" "%s" "%s"\n' "$TITLE" "$MDB_STARTTIME" "$RECORDING_PATH" "$ShowFileName" >> "$DuplicatesFile"
  NOTIFY_MSG="Recording identified as possible duplicate of: $MoveDir/$ShowFileName.$ORIGINAL_EXT"
  return "$recording_name_return_state"
} #target_file_exists()

############################### HELP MESSAGES ################################

#A message about what myth2kodi is, including current version and authors.
msg_about(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  printf ' %s\n\n' "$m2kVersion"
  printf ' %s\n' "myth2kodi automates the mapping of MythTV recordings to a Kodi library."
  printf ' %s\n\n' "It is a modified version of mythicalLibrarian."
  printf ' %s\n' "mythicalLibrarian Author: Adam Outler adamoutler(at)gmail.com"
  printf ' %s\n\n' "myth2kodi Author: Stuart Knock"
} #msg_about()

#A message describing the basic call patterns.
msg_usage(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  printf '\n %s\n' "myth2kodi usage:"
  printf '   %s\n' "myth2kodi 'path/to/file' [\"title\"] [\"subtitle\"] ['season-number' 'episode-number']"
  printf '   %s\n' "myth2kodi --mode [parameter] [parameter]"
  printf ' %s\n\n' "items in brackets are [context sensitive]."
  printf ' %s\n' "Before first use, check that myth2kodi's settings are"
  printf ' %s\n' "configured correctly for your system and be sure to run:"
  printf '   %s\n' "myth2kodi --diagnostics"
  printf ' %s\n\n' "before running in --scan mode or as a MythTV UserJob."
  printf ' %s\n' "For more information type:"
  [[ "$M2KARG1" =~ ^('-h'|'--help')$ ]] || printf '   %s\n' "myth2kodi --help"
  printf '   %s\n' "myth2kodi --config-help"
  printf '   %s\n\n' "myth2kodi --confidence"
} #msg_usage()

#A message listing all the --option flags.
msg_options(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #TODO: Consider creating more detailed help messages for individual options,
  #      so that they can be called something like:
  #      myth2kodi --help maintenance
  printf '%s\n'   "myth2kodi mode flags:"
  printf '\n%s\n' "  --diagnostics"
  printf '%s\n'   "    Tests the functionality of myth2kodi"
  printf '%s\n'   "    eg. myth2kodi --diagnostics"
  printf '\n%s\n' "  --scan filetype /path/to/folder"
  printf '%s\n'   "    Creates a Kodi library from an entire folder"
  printf '%s\n'   "    eg. myth2kodi --scan mpg /home/mythtv/videos"
  printf '\n%s\n' "  --maintenance"
  printf '%s\n'   "    Removes any orphaned support files or empty directories"
  printf '%s\n'   "    we created for any previously processed recordings."
  printf '%s\n'   "    Also cleans-up myth2kodi's working directory."
  printf '%s\n'   "    eg. myth2kodi --maintenance"
  printf '\n%s\n' "  --doover"
  printf '%s\n'   "    Reruns previously run jobs for which we successfully moved"
  printf '%s\n'   "    and/or linked a recording despite a lack of confidence."
  printf '%s\n'   "    eg. myth2kodi --doover"
  printf '\n%s\n' "  --unmanned_doover"
  printf '%s\n'   "    Same as --doover but for use without human intervention"
  printf '%s\n'   "    eg. myth2kodi --unmanned_doover"
  printf '\n%s\n' "  --undo '/path/to/file'|'all'"
  printf '%s\n'   "    Returns either a specified recording or 'all' processed"
  printf '%s\n'   "    recordings to their original state. NOTE: Recordings"
  printf '%s\n'   "    successfully processed with SYMLINK='Disabled' cannot be"
  printf '%s\n'   "    undone, as MythTV-DB info has been deleted. Also, recordings"
  printf '%s\n'   "    that have been deleted or disconnected cannot be undone."
  printf '%s\n'   "    eg. myth2kodi --undo '/home/mythtv/recordings/1099_20151210093000.mpg'"
  printf '\n%s\n' "  --series-info 'Series Name'"
  printf '%s\n'   "    Updates our local database tables for a specified series,"
  printf '%s\n'   "    ignoring lastupdated.time. Information is obtained from"
  printf '%s\n'   "    TheTVDB and tvmaze."
  printf '%s\n'   "    eg. myth2kodi --series-info 'Black Books'"
  printf '\n%s\n' "  --recording-info 'filename'"
  printf '%s\n'   "    Print the MythTV database information for the specified"
  printf '%s\n'   "    recording. "
  printf '%s\n'   "    eg. myth2kodi --recording-info '1099_20151210093000.mpg'"
  printf '\n%s\n' "  --movie 'filename' [Movie Title]"
  printf '%s\n'   "    Specifies that the recording being processed is a movie."
  printf '%s\n'   "    eg. myth2kodi --movie '1099_20151210093000.mpg'"
  printf '\n%s\n' "  --delete '/path/to/file'"
  printf '%s\n'   "    Delete the file, any links to it and the associated database entry."
  printf '%s\n'   "    eg. myth2kodi --delete '/home/mythtv/recordings/1099_20151210093000.mpg'"
  printf '\n%s\n' "  --rerecord '/path/to/file'"
  printf '%s\n'   "    Same as --delete, but, a 'rerecord' flag is added to the"
  printf '%s\n'   "    associated oldrecorded entry."
  printf '%s\n'   "    eg. myth2kodi --rerecord '/home/mythtv/recordings/1099_20151210093000.mpg'"
  printf '\n%s\n' "  --disconnect '/path/to/file'"
  printf '%s\n'   "    removes file & links from undo, doover, created.tracking,"
  printf '%s\n'   "    removes links from mythtv filename to moved filename, or"
  printf '%s\n'   "    if only 'moved' in LINK mode then actually move"
  printf '%s\n'   "    remove database entry"
  printf '%s\n'   "    eg. myth2kodi --disconnect '/home/mythtv/recordings/1099_20151210093000.mpg'"
  printf '\n%s\n' "  --log 'filename'"
  printf '%s\n'   "    Identify and display the log entries for the recording."
  printf '%s\n'   "    eg. myth2kodi --log '1099_20151210093000.mpg'"
  printf '\n%s\n' "  --comskip /path/to/folder/or/file [extention]"
  printf '%s\n'   "    Regenerates the comskip file for recordings that have"
  printf '%s\n'   "    already been moved. First argument can be either a single"
  printf '%s\n'   "    recording or a directory containing already moved recordings."
  printf '%s\n'   "    The optional second argument applies when the first arg is a"
  printf '%s\n'   "    directory and specifies file extension to process (DEFAULT: 'mpg')."
  printf '%s\n'   "    eg. myth2kodi --comskip '/home/mythtv/recordings/1099_20151210093000.mpg'"
  printf '%s\n'   "    eg. myth2kodi --comskip '/home/mythtv/recordings'"
  printf '%s\n'   "    eg. myth2kodi --comskip '/home/mythtv/recordings' 'mpg'"
  printf '\n%s\n' "  -h|--help"
  printf '%s\n'   "    Displays this message"
  printf '%s\n'   "    example: myth2kodi --help"
  printf '\n%s\n' "  --config-help"
  printf '%s\n'   "    Special Help, displays extended configuration help."
  printf '%s\n'   "    example: myth2kodi --config-help"
  printf '\n%s\n' "   --confidence"
  printf '%s\n'   "    Confidence Help, displays information on improving confidence"
  printf '%s\n\n' "    example: myth2kodi --confidence"
} #msg_options()

#A message about myth2kodi configuration files
msg_config(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  printf '%s\n' " ======showTranslations====="
  printf '%s\n' " If you are having problems with incorrect guide data such"
  printf '%s\n' " as improper titling, use showTranslations."
  printf '%s\n' " showTranslations can be applied by creating a file called:"
  printf '%s\n' " $m2kdir/showTranslations"
  printf '%s\n' " ##############################################################"
  printf '%s\n' " #My Guide Show Title = www.TheTVDB.com Show Title            #"
  printf '%s\n' " #Battlestar Gallactica = Battlestar Gallactica (2003)        #"
  printf '%s\n' " #The Office = The Office (US)                                #"
  printf '%s\n' " #Millionaire = Who Wants To Be A Millionaire                 #"
  printf '%s\n' " #Aqua teen Hungerforce = Aqua Teen Hunger Force              #"
  printf '%s\n\n' " ##############################################################"
  printf '%s\n' "======titleIgnore======"
  printf '%s\n' " If wish to ignore all shows with a specific title, use titleIgnore"
  printf '%s\n' " titleIgnore can be applied by creating a file called:"
  printf '%s\n' " $m2kdir/titleIgnore"
  printf '%s\n' " ##############################################################"
  printf '%s\n' " #Show to ignore                                              #"
  printf '%s\n' " #Battlestar Gallactica                                       #"
  printf '%s\n' " #The Office                                                  #"
  printf '%s\n' " #Millionaire                                                 #"
  printf '%s\n' " #Aqua teen Hungerforce                                       #"
  printf '%s\n\n' " ##############################################################"
  printf '%s\n' "======categoricIgnore======"
  printf '%s\n' " If you wish to ignore all shows with a specific category, use"
  printf '%s\n' " categoricIgnore"
  printf '%s\n' " categoricIgnore can be applied by creating a file called:"
  printf '%s\n' " $m2kdir/categoricIgnore"
  printf '%s\n' " ##############################################################"
  printf '%s\n' " #Category to ignore                                          #"
  printf '%s\n' " #Sports                                                      #"
  printf '%s\n' " #Sports Talk                                                 #"
  printf '%s\n' " #College Sports                                              #"
  printf '%s\n' " #Comedy                                                      #"
  printf '%s\n\n' " ##############################################################"
  printf '%s\n' "======myth2kodi.conf====="
  printf '%s\n' " myth2kodi.conf allows you to take almost any setting from the"
  printf '%s\n' " top of the myth2kodi file and override it. Your settings will"
  printf '%s\n' " remain static when you replace the myth2kodi script with a"
  printf '%s\n\n' " newer version."
  printf '%s\n' " myth2kodi.conf can be applied by creating a file called:"
  printf '%s\n' "   $m2kdir/myth2kodi.conf"
  printf '%s\n' " ##############################################################"
  printf '%s\n' " #SYMLINK=Disabled                                            #"
  printf '%s\n' " #AlternateMoveDir=/media/usbDrive                            #"
  printf '%s\n' " #NotifyUserName=adam                                         #"
  printf '%s\n' " #KODIIPs=( user:password@192.168.1.110:8080 )                #"
  printf '%s\n' " #Database=Disabled                                           #"
  printf '%s\n\n' " ##############################################################"
} #msg_config()

#A message about enabling Kodi to access the RSS feed generated by myth2kodi
msg_rss(){
  printf '%s\n' "======myth2kodi-rss====="
  printf '%s\n' "  myth2kodi generates an RSS file that can be accessed as a feed"
  printf '%s\n' "  from within Kodi. It essentially contains a list of the most"
  printf '%s\n\n' "  recent successfully completed jobs."
  printf '%s\n' "  To access myth2kodi's RSS feed, you will need to edit:"
  printf '%s\n' "    /home/<kodi-user>/.kodi/userdata/RssFeeds.xml"
  printf '%s\n' "  and add myth2kodi's feed. If the Kodi instance is on the same"
  printf '%s\n' "  machine running myth2kodi then just replace or add to Kodi's"
  printf '%s\n' "  default feeds with something like:"
  printf '%s\n' "    <feed updateinterval=\"30\">/var/www/myth2kodi-rss/rss.xml</feed>"
  printf '%s\n' "  If you want to access it from a different machine than the one"
  printf '%s\n' "  running myth2kodi then you'll need a webserver enabled on the"
  printf '%s\n' "  myth2kodi machine and the entry should look something like:"
  printf '%s\n\n' "    <feed updateinterval=\"30\">http://[youripaddress]/myth2kodi-rss/rss.xml</feed>"
} #msg_rss()

#A message explaining how to improve confidence ratings for your recordings.
msg_improve_confidence(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  printf '%s\n\n' "About Confidence ratings:"
  printf '%s\n' " Confidence Ratings are used by myth2kodi."
  printf '%s\n' " These ratings serve as a guide to the probability of a"
  printf '%s\n' " perfect match. Ratings range from +4 to -6.  Any rating"
  printf '%s\n\n' " at or above 0 should be considered a good match."
  printf '%s\n' "How can I improve my Confidence Rating?"
  printf '%s\n' " 1. myth2kodi --config-help provides information on how"
  printf '%s\n' "    to improve Episode matching confidence by using a"
  printf '%s\n' "    showTranslations file to compensate for bad guide data."
  printf '%s\n' " 2. Add your favorite show's Zap2it ID to TheTVDB.com."
  printf '%s\n' " 3. Add your favorite show's OriginalAirdate to TheTVDB.com."
  printf '%s\n\n' " 4. Add your favorite show's proper Title to TheTVDB.com"
} #msg_improve_confidence()

#################### FUNCTIONS FOR PROCESSING RECORDINGS #####################

#Set the name for episode & movie recordings when making them accessible to Kodi
set_show_file_name(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Format Episodes showname=show name Sxx=season number Exx=episode number SUBTITLE=episode name
  if [[ -n "$Sxx" && -n "$Exx" ]]; then
    debug "Naming as episode"
    ShowFileName="$TITLE $Sxx$Exx ($SUBTITLE)$SHOW_FILE_NAME_APPEND"
  #Format Movies
  elif [[ "$RECORDING_TYPE" = 'MV' ]]; then
    debug 'Naming as movie.'
    Exx='Movie'
    #TODO: If adding a year then we really want original release date so the Kodi metadata lookup works reliably.
    #      Add a MOVIE_RELEASE_YEAR to the processing functions for guide-data that provide this.
    if [[ -n "$MOVIE_RELEASE_YEAR" ]]; then
      warn "${FUNCNAME[0]}(): Currently forcing bypass of adding MOVIE_RELEASE_YEAR to Movie file names."
      ShowFileName="$TITLE$SHOW_FILE_NAME_APPEND" # ShowFileName="$TITLE ($MOVIE_RELEASE_YEAR)$SHOW_FILE_NAME_APPEND"
    else
      ShowFileName="$TITLE$SHOW_FILE_NAME_APPEND"
    fi
  #Format generic Shows
  else
    debug "Naming as generic show"
    Exx="Generic"
    ShowFileName="$TITLE S0E0 ($SUBTITLE Recorded $STARTTIME on $MDB_CHANID)$SHOW_FILE_NAME_APPEND"
    RequiresNFO=1
    [[ "$RECORDING_TYPE" = 'EP' ]] && RequiresDoover=1
  fi
  inform "Set file name as: $ShowFileName"
} #set_show_file_name()

#Set the name for special recording "Categories": 'NEWS'; 'SPORT'; etc
set_show_file_name_categoric(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local -i testedmethod
  #Method1 - use airdate for season
  if [[ "${ORIGINALAIRDATE:0:4}" != '0000' && -n "${ORIGINALAIRDATE:0:4}" && "$UseMethod2" != '1' ]]; then
    EventYear="${ORIGINALAIRDATE:0:4}"
    Sxx="$EventYear"
    EventMonthDay="$(echo "${ORIGINALAIRDATE:5:5}" | tr -d "-" | sed 's/0*//')"
    Exx="$EventMonthDay"
    [[ -z "$TVDB_TITLE" ]] && TVDB_TITLE="$TITLE"
  else #Flag failure of Method1
    testedmethod=0
  fi
  #Slight further testing of Method1 results
  if [[ -n "$EventMonthDay" ]] && ((EventYear > 1900)) && ((EventMonthDay > 0)); then
    testedmethod=1
  else
    testedmethod=0
  fi

  #Method2 -
  if ((testedmethod != 1)); then
    if [[ "${MDB_STARTTIME:0:4}" != 0000 && -n "${MDB_STARTTIME:0:4}" ]]; then
      EventYear="${MDB_STARTTIME:0:4}"
      EventMonthDay="$(echo "${MDB_STARTTIME:5:5}" | tr -d "-" | sed 's/0*//')"
    fi
    Exx="$EventMonthDay"
    Sxx="$EventYear"
    #TODO: Check validity of Method2
  fi

  #Test final result and assign ShowFileName
  if ((EventYear > 1900)) && ((EventMonthDay > 0)); then
    ShowFileName="$TVDB_TITLE S$EventYear""E$EventMonthDay ($SUBTITLE Recorded $STARTTIME)$SHOW_FILE_NAME_APPEND"
  fi

  RequiresNFO=1
  HasSxxExx=1
  inform "Set file name as: $ShowFileName"
} #set_show_file_name_categoric()

#Set the move location for the current recording, using Alternate directories
#when main directories unavailable, setting FailSafe flag when Alternate
#directories unavailable, and, in worst case, when original directory is not
#writeable return an error state.
set_move_location(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"

  #Episode & uncategorised handling: Determine where File will fit
  if [[ -z "$RECORDING_TYPE" || "$RECORDING_TYPE" = 'EP' ]]; then
    if [[ "$MoveDirWritable" != '0' && "$AltMoveDirWritable" = '0' ]]; then
      MoveDir="$AlternateMoveDir"
    elif [[ "$MoveDirWritable" != '0' && "$AltMoveDirWritable" != '0' ]]; then
      target_directory_not_writeable "Move"
    fi
  #Movie handling: Determine where file will fit
  elif [[ "$RECORDING_TYPE" = 'MV' ]]; then
    if [[ "$MovieDirWritable" = '0' ]]; then
      MoveDir="$PrimaryMovieDir"
    elif [[ "$AltMovieDirWritable" = '0' ]]; then
      MoveDir="$AlternateMovieDir"
    else
      target_directory_not_writeable "Movie"
    fi
  #Show Handling: Determining Where File will fit
  elif [[ "$RECORDING_TYPE" = 'SH' ]]; then
    if [[ "$ShowDirWritable" = '0' ]]; then
      MoveDir="$PrimaryShowDir"
    elif [[ "$AltShowDirWritable" = '0' ]]; then
      MoveDir="$AlternateShowDir"
    else
      target_directory_not_writeable "Show"
    fi
  fi

  #Return an error state if there is nowhere to write to.
  if (( FailSafeState == 1 )) && [[ "$OriginalDirWritable" != '0' ]]; then
    NOTIFY_MSG='Cannot set move location, there are no writeable target directories.'
    EXIT_JOB_TYPE='NoTargetPathAvailable'
    err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
    return 1
  fi

  # Append recgroup from the MythTV-DB to our target directory, if requested.
  if [[ "$GROUP_BY_RECGROUP" = 'Enabled' ]]; then
    if [[ -n "$MDB_RECGROUP" ]]; then
      MoveDir="$MoveDir/$MDB_RECGROUP"
      if [[ ! -d "$MoveDir" ]]; then
        inform "Creating recgroup directory: '$MoveDir'"
        mkdir "$MoveDir"
        chmod 775 "$MoveDir"
        [[ "$TRACKING" != 'Disabled' ]] && printf '%s\n' "$MoveDir" >> "$m2kdir/dir.tracking"
      fi
    else
      warn "GROUP_BY_RECGROUP='Enabled', but MythTV-DB recgroup is empty, using default target directory."
    fi
  fi

  return 0
} #set_move_location()

#Make the directory we'll move recording to if it doesn't already exist.
make_show_dir(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "MoveDir: '$MoveDir'"
  debugcont "TITLE: '$TITLE'"
  debugcont "SEASON: '$SEASON'"
  debugcont "Notify: '$Notify'"
  debugcont "NotifyUserName: '$NotifyUserName'"
  debugcont "FailSafeDir: '$FailSafeDir'"

  #If specified, make $MoveDir = $MoveDir/show name
  if [[ -n "$TITLE" ]]; then
    MoveDir="$MoveDir/$TITLE"
    if [[ ! -d "$MoveDir" ]]; then
      [[ "$RECORDING_TYPE" = 'EP' ]] && inform "Creating series folder: '$MoveDir'"
      [[ "$RECORDING_TYPE" = 'MV' ]] && inform "Creating movie folder: '$MoveDir'"
      [[ "$RECORDING_TYPE" = 'SH' ]] && inform "Creating showing folder: '$MoveDir'"
      [[ "$TRACKING" != 'Disabled' ]] && printf '%s\n' "$MoveDir" >> "$m2kdir/dir.tracking"
      mkdir "$MoveDir"
      chmod 775 "$MoveDir"
      [[ "$RECORDING_TYPE" != 'MV' ]] && generate_series_nfo
    fi

    #Make the Season folder if it is applicable and does not exist
    if [[ -n "$SEASON" ]]; then
      MoveDir="$MoveDir/Season $SEASON"
      if [[ ! -d "$MoveDir" ]]; then
        inform "Creating season folder: '$MoveDir'"
        mkdir "$MoveDir"
        chmod 775 "$MoveDir"
        [[ "$TRACKING" != 'Disabled' ]] && printf '%s\n' "$MoveDir" >> "$m2kdir/dir.tracking"
      fi
    fi
  fi

  #Error message if folder was not created
  if [[ ! -d "$MoveDir" ]]; then
    NOTIFY_MSG="Could not create '$MoveDir' - failsafe mode activated."
    EXIT_JOB_TYPE='PermissionError'
    err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
    FailSafeState=1
    return 1
  else
    inform "MOVE DIRECTORY SET AS: '$MoveDir'"
    return 0
  fi
} #make_show_dir()

#If TargetPathIsInputPath is set, then this changes MoveDir to original dir.
set_target_dir_as_input_path_dir(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #For directory names: No trailing / is accepted eg. "~/videos" not "~/videos/"
  #MoveDir is the folder which myth2kodi will move the file.
  MoveDir="$ORIGINAL_DIRNAME/Episodes"
  [[ -d "$MoveDir" ]] || mkdir "$MoveDir"
  #AlternateMoveDir will act as a secondary MoveDir if the primary MoveDir fails.
  AlternateMoveDir="$ORIGINAL_DIRNAME/Episodes"
  [[ -d "$AlternateMoveDir" ]] || mkdir "$AlternateMoveDir"
  #Primary Movie Dir. myth2kodi will attempt to move to this dir first.
  PrimaryMovieDir="$ORIGINAL_DIRNAME/Movies"
  [[ -d "$PrimaryMovieDir" ]] || mkdir "$PrimaryMovieDir"
  #AlternateMovieDir will act as a Secondary move dir if the primary move dir fails.
  AlternateMovieDir="$ORIGINAL_DIRNAME/Movies"
  [[ -d "$AlternateMovieDir" ]] || mkdir "$AlternateMovieDir"
  #PrimaryShowDir is where generic episodes will be placed.
  PrimaryShowDir="$ORIGINAL_DIRNAME/Showings"
  [[ -d "$PrimaryShowDir" ]] || mkdir "$PrimaryShowDir"
  #AlternateShowDir will act as a Secondary Show Dir if the primary show dir fails.
  AlternateShowDir="$ORIGINAL_DIRNAME/Showings"
  [[ -d "$AlternateShowDir" ]] || mkdir "$AlternateShowDir"
} #set_target_dir_as_input_path_dir()

#Create a comskip.txt file from MythTV database information for use by Kodi.
generate_comskip(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local -i Counter=0
  local StartData
  local StopData
  if ! MARKUPFRAMES_TMP="$(mktemp "$M2K_TMPDIR/m2k_markupframes_$FILE_NAME_NOW"-XXXX)"; then
    err "${FUNCNAME[0]}(): Failed to create temporary markupframes file."
    return 1
  fi
  debug "Created a temporary comskip markupframes file: '$MARKUPFRAMES_TMP'"
  declare -gr MARKUPFRAMES_TMP
  #Set up comskip file
  {
    printf '%s\n' "FILE PROCESSING COMPLETE"
    printf '%s\n' "------------------------"
  } > "$MARKUPFRAMES_TMP"

  while read -r StopData ; do
    ((++Counter))
    StartData=$(sed -n "$Counter"p "$MARKUPSTART_TMP")
    if [[ ! -z "$StopData" ]]; then
      printf '%s\n' "$StartData $StopData" >> "$MARKUPFRAMES_TMP"
      CommercialMarkup="Created"
      debug "COMMERCIAL DATA START:'$StartData' STOP:'$StopData'"
    fi
  done < "$MARKUPSTOP_TMP"

  #If we're not in debug mode then remove the temporary files we just processed.
  if (( LOGLEVEL < 3 )); then
    rm -f "$MARKUPSTART_TMP"
    rm -f "$MARKUPSTOP_TMP"
  else
    debug "Not removing the temporary markup files: '$MARKUPSTART_TMP'; '$MARKUPSTOP_TMP'."
  fi
  return 0
} #generate_comskip()

#Create a series NFO file based on information we have for the current series
generate_series_nfo(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local dbdir="$m2kdir/$TVDB_TITLE"
  {
    printf '%s\n' '<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>'
    printf '%s\n' '<tvshow>'
    printf '%b\n' "\t<title>$TVDB_TITLE</title>"
    if [[ -f "$dbdir/$TVDB_TITLE.series_overview.txt" ]]; then
      printf '%b\n' "\t<plot>$(sed 's/\&/\&amp;/g' "$dbdir/$TVDB_TITLE.series_overview.txt")</plot>"
    fi
    if [[ -f "$dbdir/$TVDB_TITLE.series_status.txt" ]]; then
      printf '%b\n' "\t<status>$(<"$dbdir/$TVDB_TITLE.series_status.txt")</status>"
    fi
    printf '%b\n' "\t<episodeguide>"

    if [[ -n "$TVDB_SERIESID" ]]; then
      local webaddrs #TODO: This needs to be updated... With new Token based system accessing the API won't work.
      webaddrs="http://www.thetvdb.com/api/$APIkey/series/$TVDB_SERIESID/all/$Language.zip"
      printf '%b\n' "\t\t<url cache=\"$TVDB_SERIESID.xml\">$webaddrs</url>"
    fi

    printf '%b\n' "\t</episodeguide>"
    [[ -n "$TVDB_SERIESID" ]] && printf '%b\n' "\t<id>$TVDB_SERIESID</id>"
    printf '%b\n' "\t<dateadded>$(date --rfc-3339=seconds)</dateadded>"
    if [[ -f "$dbdir/$TVDB_TITLE.series_firstaired.txt" ]]; then
      printf '%b\n' "\t<premiered>$(<"$dbdir/$TVDB_TITLE.series_firstaired.txt")</premiered>"
    fi
    printf '%s\n' '</tvshow>'
  } > "$MoveDir/tvshow.nfo"
  inform "Generated series NFO file: $MoveDir/tvshow.nfo"
  return 0
} #generate_series_nfo()

#Create an episode NFO file based on information we have for the current episode
generate_episode_nfo(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  {
    printf '%s\n' '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
    printf '%s\n' '<episodedetails>'
  } > "$MoveDir/$ShowFileName.nfo"
  #TODO: reconsider this title specification.
  local basetitle="<title>$SUBTITLE Recorded $STARTTIME"
  if [[ -z "$NamingConvention" ]]; then
    if [[ "${DOOVER_ADDED,,}" = 'true' ]]; then #TODO: review me...
      printf '%b\n' "\t$basetitle -Episode in --doover Queue</title>" >> "$MoveDir/$ShowFileName.nfo"
    elif [[ -n "$SUBTITLE" ]]; then #TODO: review me...
      printf '%b\n' "\t$basetitle -Episode</title>" >> "$MoveDir/$ShowFileName.nfo"
    else
      printf '%b\n' "\t$basetitle -Showing</title>" >> "$MoveDir/$ShowFileName.nfo"
    fi
  else
    printf '%b\n' "\t$basetitle -Categoric</title>" >> "$MoveDir/$ShowFileName.nfo"
  fi

  if [[ "$HasSxxExx" = '1' ]]; then
    {
      printf '%b\n' "\t<season>$Sxx</season>"
      printf '%b\n' "\t<episode>$Exx</episode>"
    } >> "$MoveDir/$ShowFileName.nfo"
  else
    {
      printf '%b\n' "\t<season>0</season>"
      printf '%b\n' "\t<episode>0</episode>"
    } >> "$MoveDir/$ShowFileName.nfo"
  fi

  {
    printf '%b\n' "\t<rating>$RATING</rating>"
    printf '%b\n' "\t<plot>$Plot</plot>"
    printf '%b\n' "\t<genre>$CATEGORY</genre>"
    printf '%b\n' "\t<aired>${MDB_STARTTIME%% *}</aired>"
    printf '%b\n' "\t<dateadded>$(date --rfc-3339=seconds)</dateadded>"
    printf '%s\n' '</episodedetails>'
  } >> "$MoveDir/$ShowFileName.nfo"

  if [[ "$TRACKING" != 'Disabled' ]]; then
    printf '%s\n' "\"$MoveDir/$ShowFileName.nfo\" \"$MoveDir/$ShowFileName.$ORIGINAL_EXT\"" >> "$m2kdir/created.tracking"
  fi
  inform "Generated episode NFO file: $MoveDir/$ShowFileName.nfo"
  return 0
} #generate_episode_nfo()

#Processes the title and categoric ignore lists
process_ignore_lists(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local ignoreTest=""
  #Test if the title is in the titleIgnore file
  if [[ -f "$m2kdir/titleIgnore" ]]; then
    ignoreTest="$(grep "$TITLE" "$m2kdir/titleIgnore")"
    if [[ "$TITLE" = "$ignoreTest" ]]; then
      EXIT_JOB_TYPE='titleIgnore'
      return 1
    fi
  fi
  #Test if the Category is in the categoricIgnore file
  if [[ -f "$m2kdir/categoricIgnore" ]]; then
    ignoreTest="$(grep "$CATEGORY" "$m2kdir/categoricIgnore")"
    if [[ "$CATEGORY" = "$ignoreTest" ]]; then
      EXIT_JOB_TYPE='categoricIgnore'
      return 1
    fi
  fi
  return 0
} #process_ignore_lists()

#Get show translations if the $m2kdir/showTranslations file exists.
#The show title will be replaced by the one in the user created showTranslations file
show_translation(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debug "Checking for translations in: '$m2kdir/showTranslations'."
  if [[ -f "$m2kdir/showTranslations" && -n "$TITLE" ]]; then
    TITLE_TRANSLATION="$(grep "^$TITLE = " "$m2kdir/showTranslations" | sed "s/$TITLE = //g")"
    if [[ -n "$TITLE_TRANSLATION" ]]; then
      inform "USER TRANSLATION: '$TITLE' => '$TITLE_TRANSLATION'"
      TITLE="$TITLE_TRANSLATION"
    elif [[ -z "$TITLE_TRANSLATION" ]]; then
      debug "No translation entry for '$TITLE'."
      TITLE_TRANSLATION='Inactive'
    fi
  else
    [[ -f "$m2kdir/showTranslations" ]] || debug 'No showTranslations file.'
    [[ -n "$TITLE" ]] || debug 'No TITLE to translate.'
  fi
  return 0
} #show_translation()

#On successful processing this function is called to: move any comskip file
#into place; generate NFO; communicate with Kodi; add undo and doover entries;
#generate a dailyreport entry; and generate an RSS entry.
success_postprocessing(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"

  #Move comskip data to proper folder and add created.tracking entry.
  if [[ "$CommercialMarkup" = 'Created' ]]; then
    mv "$MARKUPFRAMES_TMP" "$MoveDir/$ShowFileName.txt" 2>&1 | err_pipe "${FUNCNAME[0]}(): "
    chmod 664 "$MoveDir/$ShowFileName.txt" 2>&1 | err_pipe "${FUNCNAME[0]}(): "
    if [[ "$TRACKING" != 'Disabled' ]]; then
      printf '%s\n' "\"$MoveDir/$ShowFileName.txt\" \"$MoveDir/$ShowFileName.$ORIGINAL_EXT\"" >> "$m2kdir/created.tracking"
    fi
  fi

  #Additional features: undo; doover; NFO; notifications; daily report; rss.
  add_undo
  [[ "$RequiresDoover" = '1' && "$TRACKING" != 'Disabled' ]] && add_doover
  [[ "$RequiresNFO" = '1' ]] && generate_episode_nfo #Must be called after add_doover
  kodi_newshow
  dailyreport
  [[ "$CREATE_RSS" = 'Enabled' ]] && generaterss
  if [[ "$PROCESS_RECORDING_MODE" = 'MOVE' && "$SYMLINK" = 'Disabled' ]]; then
    set_group_permission
  fi
} #success_postprocessing()

#Adds an entry to doover.sh for the current job.
add_doover(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "M2KARG1: '$M2KARG1'"
  debugcont "M2KARG2: '$M2KARG2'"
  debugcont "M2KARG3: '$M2KARG3'"
  debugcont "M2KARG4: '$M2KARG4'"
  debugcont "M2KARG5: '$M2KARG5'"
  debugcont "m2kdir: '$m2kdir'"
  debugcont "RECORDING_PATH: '$RECORDING_PATH'"
  debugcont "MoveDir: '$MoveDir'"
  debugcont "ShowFileName: '$ShowFileName'"
  debugcont "ORIGINAL_EXT: '$ORIGINAL_EXT'"
  debugcont "RequiresDoover: '$RequiresDoover'"
  debugcont "PROCESS_RECORDING_MODE: '$PROCESS_RECORDING_MODE'"
  debugcont "SYMLINK: '$SYMLINK'"

  #Create the doover.sh file if it doesn't already exist.
  if [[ ! -f "$m2kdir/doover.sh" ]]; then
    printf '%s\n' "rm -f '$m2kdir/doover.sh'" >> "$m2kdir/doover.sh"
    chmod 644 "$m2kdir/doover.sh"
  fi

  if (( RequiresDoover == 1 )); then
    inform "Writing job to doover queue: $m2kdir/doover.sh"
    if [[ "$PROCESS_RECORDING_MODE" = 'MOVE' && "$SYMLINK" = 'Enabled' ]]; then
      {
        #Write doover.sh line that removes link:
        printf '%s'    "test -f \"$MoveDir/$ShowFileName.$ORIGINAL_EXT\" &&"
        printf ' %s'   "test -L \"$RECORDING_PATH\" &&"
        printf ' %s'   "rm -f \"$RECORDING_PATH\" &&"
        printf ' %s\n' "echo Moving \"$RECORDING_PATH\" to original location"
        #Write doover.sh line that moves already-moved-file back to original location:
        printf '%s'    "test -f \"$MoveDir/$ShowFileName.$ORIGINAL_EXT\" &&"
        printf ' %s\n' "mv \"$MoveDir/$ShowFileName.$ORIGINAL_EXT\" '$RECORDING_PATH'"
      } >> "$m2kdir/doover.sh"
    elif [[ "$PROCESS_RECORDING_MODE" = 'LINK' ]] || [[ "$PROCESS_RECORDING_MODE" = 'HARDLINK' ]]; then
      {
        #Write doover.sh line that removes a link to a recording:
        printf '%s'    "test -L \"$MoveDir/$ShowFileName.$ORIGINAL_EXT\" &&"
        printf ' %s'   "rm -f \"$MoveDir/$ShowFileName.$ORIGINAL_EXT\" &&"
        printf ' %s\n' "echo removed link \"$MoveDir/$ShowFileName.$ORIGINAL_EXT\""
      } >> "$m2kdir/doover.sh"
    else
      err "${FUNCNAME[0]}(): PROCESS_RECORDING_MODE not equal to 'LINK' or 'MOVE' with 'SYMLINK'ing 'Enabled'."
      return 1
    fi
    DOOVER_ADDED='true'
    #Write doover.sh line that recalls myth2kodi in the same way it was originally called:
    printf '%s\n' "myth2kodi '$M2KARG1' \"$M2KARG2\" \"$M2KARG3\" \"$M2KARG4\" '$M2KARG5'" >> "$m2kdir/doover.sh"
    return "$?"
  else
    err "${FUNCNAME[0]}(): should only be called if job requires doover."
    errcont "RequiresDoover: $RequiresDoover"
    return 1
  fi
} #add_doover()

#Adds an entry to undo.sh for the current job.
add_undo(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "m2kdir: '$m2kdir'"
  debugcont "RECORDING_PATH: '$RECORDING_PATH'"
  debugcont "MoveDir: '$MoveDir'"
  debugcont "ShowFileName: '$ShowFileName'"
  debugcont "ORIGINAL_EXT: '$ORIGINAL_EXT'"
  debugcont "PROCESS_RECORDING_MODE: '$PROCESS_RECORDING_MODE'"
  debugcont "SYMLINK: '$SYMLINK'"

  #Create the undo.sh file if it doesn't already exist.
  if [[ ! -f "$m2kdir/undo.sh" ]]; then
    printf '%s\n' "rm -f '$m2kdir/undo.sh'" >> "$m2kdir/undo.sh"
    chmod 644 "$m2kdir/undo.sh"
  fi

  if [[ "$PROCESS_RECORDING_MODE" = 'MOVE' && "$SYMLINK" = 'Enabled' ]]; then
    {
      #Write undo.sh line that removes link:
      printf '%s'    "test -L \"$RECORDING_PATH\" &&"
      printf ' %s'   "rm -f \"$RECORDING_PATH\" &&"
      printf ' %s\n' "echo removed link \"$RECORDING_PATH\""
      #Write undo.sh line that moves already-moved-file back to original location:
      printf '%s'    "test -f \"$MoveDir/$ShowFileName.$ORIGINAL_EXT\" &&"
      printf ' %s'   "mv \"$MoveDir/$ShowFileName.$ORIGINAL_EXT\" \"$RECORDING_PATH\" &&"
      printf ' %s\n' "echo moved \"$MoveDir/$ShowFileName.$ORIGINAL_EXT\" to \"$RECORDING_PATH\""
    } >> "$m2kdir/undo.sh"
  elif [[ "$PROCESS_RECORDING_MODE" = 'LINK' ]] || [[ "$PROCESS_RECORDING_MODE" = 'HARDLINK' ]]; then
    {
      #Write undo.sh line that removes link:
      printf '%s'    "test -L \"$MoveDir/$ShowFileName.$ORIGINAL_EXT\" &&"
      printf ' %s'   "rm -f \"$MoveDir/$ShowFileName.$ORIGINAL_EXT\" &&"
      printf ' %s\n' "echo removed link \"$MoveDir/$ShowFileName.$ORIGINAL_EXT\""
    } >> "$m2kdir/undo.sh"
  elif [[ "$PROCESS_RECORDING_MODE" = 'MOVE' && "$SYMLINK" = 'Disabled' && "$RequiresDoover" != '1' ]]; then
    debug "'MOVE' mode with SYMLINK=Disabled and does not require doover, so MythTV-DB info has been removed."
    inform "No undo.sh entry will be added for this recording:"
    informcont "File Name: '$MoveDir/$ShowFileName.$ORIGINAL_EXT'"
  fi
} #add_undo()

failsafe(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  warn "FAILSAFE FLAG WAS SET:"
  warncont "This means there was a permission error or drive full or offline."
  warncont "Check your permissions, disk usage, and network connection to NAS."
  if [[ "$FailSafeMode" = 'Enabled' &&  "$SYMLINK" = 'Enabled' ]]; then
    warn "ATTEMPTING SYMLINK TO FAILSAFE DIR: $FailSafeDir"
    inform "FailSafe link name set as: '$FailSafeDir/$ShowFileName.$ORIGINAL_EXT'"
    ln -s "$RECORDING_PATH" "$FailSafeDir/$ShowFileName.$ORIGINAL_EXT"
    if [[ -f "$FailSafeDir/$ShowFileName.$ORIGINAL_EXT" ]]; then
      inform "FAILSAFE MODE COMPLETE: SYMLINK CREATED"
      #Do post processing as a successful LINK mode move, but require doover.
      MoveDir="$FailSafeDir"
      inform "${FUNCNAME[0]}() MOVE DIRECTORY SET AS: $MoveDir"
      PROCESS_RECORDING_MODE='LINK'
      warn "${FUNCNAME[0]}(): Recordings processed in FAILSAFE MODE will be added to the doover queue."
      RequiresDoover=1
      #Generate supporting files, add undo and doover entries, notify Kodi.
      success_postprocessing
      EXIT_JOB_TYPE='FailSafeModeComplete'
      NOTIFY_MSG="FAILSAFE mode active See '$LOGFILE' for more information"
      return 0
    else
      err "${FUNCNAME[0]}(): FAILSAFE MODE FAILURE CHECK PERMISSIONS AND FREE SPACE IN '$FailSafeDir'"
      return 1
    fi
  else
    inform "FailSafeMode or SYMLINK Disabled, we will not try and make a link as a fallback."
    return 0
  fi
  return 0
} #failsafe()

anti_clobber(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  if [[ -f "$MoveDir/$ShowFileName.$ORIGINAL_EXT" ]]; then
    if [[ "$FORCE_PROCESS" = 'Enabled' ]]; then
      increment_target_file_name
    else
      target_file_exists
      return 1
    fi
  fi
  return 0
} #anti_clobber()

#Called when SYMLINK is Disabled, adds read and write permission for the group
set_group_permission(){
  #TODO: review... Why?
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Set permission 664 (rw-rw-r--)
  chmod 664 "$MoveDir/$ShowFileName.$ORIGINAL_EXT"
  return "$?"
} #set_group_permission()

naming_checks(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #If no episode data and it's not a test
  if [[ "$HasSxxExx" != '1' && "$RECORDING_PATH" != "$M2K_TEST_FILE" ]]; then
    if [[ "$RECORDING_TYPE" = 'EP' ]]; then
      NOTIFY_MSG="Episode could not be matched with supplied information."
      warn "$NOTIFY_MSG"
      EXIT_JOB_TYPE='NameCouldNotBeAssigned'
      return 1
    elif [[ "$RECORDING_TYPE" = 'MV' ]]; then
      #Ensures the doover value was not set for the movie.
      RequiresDoover=0
    #If user has determined that they do not want unrecognisable tv shows in their library.
    elif [[ "$ShowStopper" = 'Enabled' ]]; then
      msg_unable_to_identify_recording
      EXIT_JOB_TYPE='NameCouldNotBeAssigned'
      return 1
    elif [[ "$RECORDING_TYPE" = 'SH' ]]; then
      msg_show_warning
    else
      msg_epishow
    fi
  fi

  #Set MoveDir, using alternates if necessary, falling back to FailSafeState, and
  #finally exit if there is nowhere to write to.
  if ! set_move_location; then return 1; fi

  #Only keep Alpha-numeric characters, space, parenthesis and the six chars & , . : ' -
  TITLE="$(sed -r "s/[^[:alnum:] &,.)(:'-]//g" <<< "$TITLE")"
  #Only keep Alpha-numeric characters, space, parenthesis and the four chars & , . -
  SUBTITLE="$(sed -r 's/[^[:alnum:] &,.)(-]//g' <<< "$SUBTITLE")"

  return 0
} #naming_checks()

format_filename(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  if [[ -z "$NamingConvention" ]]; then
    set_show_file_name
  else
    set_show_file_name_categoric
  fi
  return 0
} #format_filename()

#If target file exists then this function makes a new name for it.
increment_target_file_name(){
  local counter=0
  local name_check=0
  while (( name_check == 0 )); do
    ((++counter))
    #If file does not exist, then it is a valid target
    if [[ ! -e "$MoveDir/$ShowFileName-$counter.$ORIGINAL_EXT" ]]; then
      name_check=1
      ShowFileName="$ShowFileName-$counter"
      warn "FILE NAME EXISTS. FILE WILL BE KNOWN AS: $ShowFileName"
    fi
  done
} #increment_target_file_name()

#Process a recording file in MOVE mode.
move_mode_handling(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Send notifications, Move the file and rename
  debug "MOVING FILE: '$RECORDING_PATH' to '$MoveDir/$ShowFileName.$ORIGINAL_EXT'"
  mv "$RECORDING_PATH" "$MoveDir/$ShowFileName.$ORIGINAL_EXT" 2>&1 | err_pipe "'MOVE' mode: "

  #Check and report if file was moved
  if [[ -e "$MoveDir/$ShowFileName.$ORIGINAL_EXT" ]]; then
    if [[ -f "$MoveDir/$ShowFileName.$ORIGINAL_EXT" ]]; then
      #Make symlink back to original file
      if [[ "$SYMLINK" = 'Enabled' ]]; then
        inform "Creating symlink in move mode."
        ln -s "$MoveDir/$ShowFileName.$ORIGINAL_EXT" "$RECORDING_PATH"
        [[ -L "$RECORDING_PATH" ]] || err "Failed to Create symlink: FILESYSTEM MAY NOT SUPPORT SYMLINKS"
      #If SYMLINK=Disabled, remove database entries
      elif [[ "$SYMLINK" = 'Disabled' ]]; then
        #Set permissions as rw-rw-r-- (664)
        chmod 664 "$MoveDir/$ShowFileName.$ORIGINAL_EXT"
        if [[ "$RequiresDoover" != '1' ]]; then
          if [[ "$Database" = 'Enabled' ]]; then
            debug "SYMLINK='Disabled' and does not require doover, so MythTV-DB info will be removed."
            RECORDING_NAME="$INPUT_PATH_BASENAME" #Set here so we won't needlessly run identify_recording_files().
            if ! delete_recording_from_mythtv; then return 1; fi
          else
            warn "Moved recording file with SYMLINK='Disabled' and Database='Disabled'."
            warncont "If this was a MythTV recording file, then the MythTV-DB will now"
            warncont "reference a recording for which the file no longer exists. You will"
            warncont "need to set Database='Enabled' and then run:"
            warncont "    RECORDING_NAME='$INPUT_PATH_BASENAME'"
            warncont "    myth2kodi --delete '$INPUT_PATH_BASENAME'"
            warncont "to remove the MythTV-DB entry. You should rethink your settings."
          fi
        else
          warn "Job requires doover, so attempting to create symlink in SYMLINK='Disabled' mode."
          ln -s "$MoveDir/$ShowFileName.$ORIGINAL_EXT" "$RECORDING_PATH"
          if [[ ! -L "$RECORDING_PATH" ]]; then
            err "Failed to Create symlink: FILESYSTEM MAY NOT SUPPORT SYMLINKS"
          elif [[ -L "$RECORDING_PATH" ]]; then
            debug "Symlink Successfully created."
            warn "Setting SYMLINK='Enabled' for subsequent processing."
            SYMLINK='Enabled'
          fi
        fi
      else
        err "SYMLINK must be set as 'Enabled' or 'Disabled', but SYMLINK='$SYMLINK'"
      fi

      #Generate supporting files, add undo and doover entries, notify Kodi.
      success_postprocessing

      #We've successfully moved the recording -- notify then exit.
      msg_completed_move
      return 0

    #if file was not moved (has zero size), then fail
    elif [[ ! -s "$MoveDir/$ShowFileName.$ORIGINAL_EXT" ]]; then
      rm -f "$MoveDir/$ShowFileName.$ORIGINAL_EXT"
      msg_wrote_zero_length_file
      return 1
    fi
  elif [[ ! -f "$MoveDir/$ShowFileName.$ORIGINAL_EXT" ]]; then
    msg_permission_error_while_moving
    return 1
  fi
} #move_mode_handling()

#Process a recording file in LINK mode.
link_mode_handling(){
  debug "Creating link in LINK mode with CONFIDENCE:'$ConfidenceRating'"

  ln -s "$RECORDING_PATH" "$MoveDir/$ShowFileName.$ORIGINAL_EXT"

  #if file was created
  if [[ -L "$MoveDir/$ShowFileName.$ORIGINAL_EXT" ]]; then
    inform "Symlink created: $MoveDir/$ShowFileName.$ORIGINAL_EXT"
    if [[ "$TRACKING" != 'Disabled' ]]; then
      printf '%s\n' "\"$MoveDir/$ShowFileName.$ORIGINAL_EXT\" \"$RECORDING_PATH\"" >> "$m2kdir/created.tracking"
    fi

    #Generate supporting files, add undo and doover entries, notify Kodi.
    success_postprocessing

    #We've successfully linked the recording -- notify then exit.
    NOTIFY_MSG="$ShowFileName linked to $MoveDir"
    EXIT_JOB_TYPE='LinkModeSuccessful'
    return 0

  #If link failure, send notification and fail
  elif [[ ! -L "$MoveDir/$ShowFileName.$ORIGINAL_EXT" ]]; then
    msg_symlink_not_created
    return 1
  fi
} #link_mode_handling()

#Process a recording file in HARDLINK mode.
hardlink_mode_handling(){
  debug "Creating link in HARDLINK mode with CONFIDENCE:'$ConfidenceRating'"

  ln "$RECORDING_PATH" "$MoveDir/$ShowFileName.$ORIGINAL_EXT"

  #if file was created
  if [[ -e "$MoveDir/$ShowFileName.$ORIGINAL_EXT" ]]; then
    inform "Hardlink created: $MoveDir/$ShowFileName.$ORIGINAL_EXT"
    if [[ "$TRACKING" != 'Disabled' ]]; then
      printf '%s\n' "\"$MoveDir/$ShowFileName.$ORIGINAL_EXT\" \"$RECORDING_PATH\"" >> "$m2kdir/created.tracking"
    fi

    #Generate supporting files, add undo and doover entries, notify Kodi.
    success_postprocessing

    #We've successfully linked the recording -- notify then exit.
    NOTIFY_MSG="$ShowFileName linked to $MoveDir"
    EXIT_JOB_TYPE='LinkModeSuccessful'
    return 0

  #If link failure, send notification and fail
elif [[ ! -e "$MoveDir/$ShowFileName.$ORIGINAL_EXT" ]]; then
    msg_symlink_not_created
    return 1
  fi
} #hardlink_mode_handling()

#Process a recording file in COPY mode.
copy_mode_handling(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Send notifications, Move the file and rename
  debug "COPYING FILE: '$RECORDING_PATH' to '$MoveDir/$ShowFileName.$ORIGINAL_EXT'"
  cp -L "$RECORDING_PATH" "$MoveDir/$ShowFileName.$ORIGINAL_EXT"
  #Check and report if file was moved
  if [[ -e "$MoveDir/$ShowFileName.$ORIGINAL_EXT" ]]; then
    if [[ -f "$MoveDir/$ShowFileName.$ORIGINAL_EXT" ]]; then

      #Generate supporting files, add undo and doover entries, notify Kodi.
      success_postprocessing

      #We've successfully copied the recording -- notify then exit.
      msg_completed_copy
      return 0
    #if file was not moved (has zero size), then fail
    elif [[ ! -s "$MoveDir/$ShowFileName.$ORIGINAL_EXT" ]]; then
      rm -f "$MoveDir/$ShowFileName.$ORIGINAL_EXT"
      msg_wrote_zero_length_file
      return 1
    fi
  elif [[ ! -f "$MoveDir/$ShowFileName.$ORIGINAL_EXT" ]]; then
    msg_permission_error_while_copying
    return 1
  fi
} #copy_mode_handling()

######################## KODI COMMUNICATION FUNCTIONS ########################

#Request Kodi remove any no-longer reachable files from its library.
kodi_cleanup(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "m2kScanMode: '$m2kScanMode'"
  debugcont "KODIClean: '$KODIClean'"
  debugcont "$( printf 'KODIIPs: %s' "${KODIIPs[*]/%/ ;}." )"
  if [[ "$m2kScanMode" != 'True' ]]; then
    if [[ "$KODIClean" = 'Enabled' ]]; then
      local data=""
      local curlPOST=""
      curlPOST='curl --silent --max-time 8 --connect-timeout 5 -H "Content-Type: application/json;" --data-binary'
      data=\''{"jsonrpc": "2.0", "method": "VideoLibrary.Clean", "id": "myth2kodi"}'\'
      #Send VideoLibrary.Clean request to Kodi instances specified in user settings (KODIIPs).
      for KODIIP in "${KODIIPs[@]}" ; do
        inform "Sending VideoLibrary.Clean request to: ${KODIIP##*@}"
        (( LOGLEVEL > 3 )) && debug "Kodi Access: '$KODIIP'"
        eval "$curlPOST $data http://$KODIIP/jsonrpc" > /dev/null 2>&1
      done
    else
      debug 'VideoLibrary.Clean request to Kodi disabled.'
    fi
  else
    debug 'Scan Mode: Skipping Kodi VideoLibrary.Clean request.'
  fi
  return 0
} #kodi_cleanup()

#Send a GUI notification to Kodi and request it update its library.
kodi_newshow(){
  #TODO: there must be a better way to do this neatly than using eval...
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "m2kScanMode: '$m2kScanMode'"
  debugcont "KODINotify: '$KODINotify'"
  debugcont "KODIUpdate: '$KODIUpdate'"
  debugcont "$( printf 'KODIIPs: %s' "${KODIIPs[*]/%/ ;}." )"
  debugcont "TITLE: '$TITLE'"
  local data=""
  local curlPOST=""
  #SEE: http://kodi.wiki/view/HOW-TO:Remotely_update_library and 'man curl'
  curlPOST='curl --silent --max-time 8 --connect-timeout 5 -H "Content-Type: application/json;" --data-binary'

  #Send notification to KODI
  if [[ "$KODINotify" = 'Enabled' ]]; then
    data=\''{"jsonrpc": "2.0",
             "method": "GUI.ShowNotification",
             "params": {"title": "myth2kodi added", "message": "'"$TITLE"'"},
             "id": "myth2kodi"}'\'
    for KODIIP in "${KODIIPs[@]}" ; do
      inform "Sending GUI.ShowNotification request to: ${KODIIP##*@}"
      (( LOGLEVEL > 3 )) && debug "Kodi Access: '$KODIIP'"
      eval "$curlPOST $data http://$KODIIP/jsonrpc" > /dev/null 2>&1
      debug "SENT: GUI.ShowNotification for '$TITLE'"
    done
  else
    debug 'Kodi notification is disabled.'
  fi

  #Send Update Library request to KODI
  if [[ "$m2kScanMode" != 'True' ]]; then
    if [[ "$KODIUpdate" = 'Enabled' ]]; then
      data=\''{"jsonrpc": "2.0", "method": "VideoLibrary.Scan", "id": "myth2kodi"}'\'
      for KODIIP in "${KODIIPs[@]}" ; do
        inform "Sending VideoLibrary.Scan request to: ${KODIIP##*@}"
        (( LOGLEVEL > 3 )) && debug "Kodi Access: '$KODIIP'"
        eval "$curlPOST $data http://$KODIIP/jsonrpc" > /dev/null 2>&1
        debug 'SENT: VideoLibrary.Scan request.'
      done
    else
      debug 'Kodi library updates are disabled.'
    fi
  else
    debug 'Scan Mode: Skipping Kodi VideoLibrary.Scan request.'
  fi
  return 0
} #kodi_newshow()

#Generate an RSS feed for processed recordings, Kodi can be set to view this feed.
generaterss(){
  #Big thanks to barney_1!
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Only called when RSS generation is enabled, so we want some entries:
  ((RSSmaxItems == 0)) && RSSmaxItems=8 #maximum number of items to read into the feed

  #script settings
  local OLDrssFile='rss.xml'
  local TEMPrssFile='rss.temp'

  #HTML line break code for nice formatting
  local lineBreak='&lt;br /&gt;'

  local rss_title rss_subtitle rss_plot
  local myip mythicalGUID

  #test if rssFile directory is writeable
  if [[ ! -w "$RSS_DIRECTORY" ]]; then #TODO: Consider using if ! check_path_permission "$RSS_DIRECTORY" 'rwx'; then ...; fi
    err "${FUNCNAME[0]}(): RSS generation failed: Directory not writeable ($RSS_DIRECTORY)"
    return 5
  fi

  #test if rssFile is writeable #TODO: Consider using if ! check_path_permission "$RSS_DIRECTORY/$OLDrssFile" 'rw'; then ...; f
  if [[ -e "$RSS_DIRECTORY/$OLDrssFile" && ! -w "$RSS_DIRECTORY/$OLDrssFile" ]]; then
    err "${FUNCNAME[0]}(): RSS generation failed: File exists but is not writeable: $RSS_DIRECTORY/$OLDrssFile"
    return 6
  fi

  #Setup the rss file
  {
    printf '%b\n' '<?xml version="1.0" encoding="ISO-8859-1" ?>'
    printf '%b\n' '<rss version="2.0">'
    printf '%b\n' '<channel>'
    printf '%b\n' '\t<title>Recently added by myth2kodi</title>'
    printf '%b\n' '\t<link>http://kodi.tv</link>'
    printf '%b\n' '\t<description>myth2kodi Daily Report Information</description>'
  } > "$RSS_DIRECTORY/$TEMPrssFile"

  #TODO: Need to make the call to ifconfig more portable, maybe just revert to straight call and add /sbin to librarians path.
  #  The below assumed the first inet addr was the correct one, but that can lead to the loopback, using m2 and removing 127.0.0.1 avoids this problem,
  #  though it's probably better to just set myip in the configuration at top of file. #ifconfigpath="$(command -v ifconfig)"
  which /sbin/ifconfig >/dev/null && myip="$(/sbin/ifconfig | grep 'inet addr' -m2 | cut -d: -f2 | awk '{ print $1}' | grep -v "127.0.0.1")"
  rss_subtitle="${SUBTITLE//&/&amp;}"
  rss_title="${TITLE//&/&amp;}"
  rss_plot="${Plot//&/&amp;}"
  mythicalGUID="$(sed 's/(/%28/g' <<< "$CALLER@$myip$MoveDir/$ShowFileName.$ORIGINAL_EXT" | sed 's/)/%29/g' | sed 's/ /%20/g')"

  #write current recording information to first item.
  {
    printf '%b\n' "\t\t<item>"
    printf '%b\n' "\t\t\t<title>$rss_title $Sxx$Exx $rss_subtitle</title>"
    if [[ "$RECORDING_TYPE" = 'EP' ]]; then
      printf '%b\n' "\t\t\t<link>http://www.thetvdb.com/?tab=series&amp;id=$TVDB_SERIESID</link>"
    elif [[ "$RECORDING_TYPE" = 'MV' ]]; then
      printf '%b\n' "\t\t\t<link>http://www.imdb.com/search/title?release_date=,$MOVIE_RELEASE_YEAR&amp;title=$TITLE&amp;title_type=feature</link>"
    else
      local tvdotcomshowname
      tvdotcomshowname="$(sed 's/ /%20/g' <<< "$TITLE" | sed 's/&/%26/g' | sed 's/:/%3A/g' | sed 's/,/%2C/g')"
      printf '%b\n' "\t\t\t<link>http://www.tv.com/search.php?type=11&amp;stype=all&amp;tag=search%3Bfrontdoor&amp;qs=$tvdotcomshowname </link>" #TODO: This tv.com API does not seem to exist any more...
    fi
    printf '%b\n' "\t\t\t<guid>sftp://$mythicalGUID</guid>"
    printf '%b\n' "\t\t\t<pubDate>$(date -R -d "$MDB_STARTTIME")</pubDate>"
    printf '%b\n' "\t\t\t<description>"
    printf '%b\n' "\t\t\t\tEpisode Title: $rss_subtitle$lineBreak"
    printf '%b\n' "\t\t\t\tProgram: $rss_title$lineBreak"
    printf '%b\n' "\t\t\t\tSeason: $Sxx$lineBreak"
    printf '%b\n' "\t\t\t\tEpisode: $Exx$lineBreak$lineBreak"
    printf '%b\n' "\t\t\t\tPlot: $rss_plot"
    printf '%b\n' "\t\t\t</description>"
    printf '%b\n' "\t\t</item>"
  } >> "$RSS_DIRECTORY/$TEMPrssFile"

  #If there is an old RSS file
  if [[ -e "$RSS_DIRECTORY/$OLDrssFile" ]]; then
    local RssItemCount itemLimit firstLine lastLine old_rss_data

    #test for number of </item> tags using grep
    RssItemCount="$(grep -c '</item>' "$RSS_DIRECTORY/$OLDrssFile")"

    #if $RSSmaxItems is greater than this number
    if ((RSSmaxItems > RssItemCount)); then
      #set a variable to track this number + 1 for the new entry
      itemLimit=$((RssItemCount+1))
    else
      #set tracking variable to $RSSmaxItems
      itemLimit="$RSSmaxItems"
    fi

    #get the line number for the first <item> tag
    firstLine="$(grep -n -m 1 '<item>' "$RSS_DIRECTORY/$OLDrssFile" | cut -d ":" -f 1)"
    #get the line number for our last </item> tag
    lastLine="$(grep -n -m $((itemLimit-1)) '</item>' "$RSS_DIRECTORY/$OLDrssFile" | tail -n1 | cut -d ":" -f 1)"
    #set IFS to use line break as a delineator
    local IFS=$'\n'
    #Read in the old RSS file
    declare -a old_rss_data=( $(<"$RSS_DIRECTORY/$OLDrssFile") )
    #iterate through the array
    for index in $(seq $((firstLine-1)) $((lastLine-1))) ; do
      printf '%s\n' "${old_rss_data[$index]}" >> "$RSS_DIRECTORY/$TEMPrssFile"
    done
  fi

  #Write close of entry to the file.
  {
    printf '%b\n' '</channel>'
    printf '%b\n' '</rss>'
  } >> "$RSS_DIRECTORY/$TEMPrssFile"

  #move fully formed temp file on top of the old file
  mv "$RSS_DIRECTORY/$TEMPrssFile" "$RSS_DIRECTORY/$OLDrssFile" 2>&1 | err_pipe "${FUNCNAME[0]}(): "
  inform "RSS ENTRY SUCCESSFULLY CREATED: $RSS_DIRECTORY/$OLDrssFile"
  return 0
} #generaterss()

##################### COMMAND SWITCH RELATED FUNCTIONS #######################

#An error message for failure to call --scan correctly
#A single input arg, specifying the type of error, is prepended to the message.
msg_scan_usage(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Log the input arg ($1) as an ERROR message and append usage for --scan to the log.
  err "$1."
  errcont '  usage: myth2kodi --scan "ext" "/path/to/folder"'
  errcont '  example: myth2kodi --scan "mpg" "/home/mythtv/videos"'
} #msg_scan_usage()

#This function will scan a folder and process the entire library
m2k_scan(){
  #TODO: Need to go through this function line-by-line and make sure it can be run without causing damage.
  [[ "$LOGTYPE" = 'file' ]] && printf '%s\n' "WARNING: Recommend setting LOGTYPE='filestderr', before proceeding.."
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local yesorno=""
  local dooverstatus
  #Map myth2kodi input variables to local variables for our current purpose.
  local checkext="$M2KARG2"
  local scanpath="${M2KARG3%*/}" #Strip any trailing / from the directory name.
  debug "Running ${FUNCNAME[0]}() on '$checkext' files in '$scanpath'"

  #Do some basic checks before we get started.
  if [[ -z "$checkext" ]]; then
    NOTIFY_MSG='Cannot process blank file extensions'
    msg_scan_usage "$NOTIFY_MSG"
    EXIT_JOB_TYPE='InvalidCall'
    return 1
  elif [[ "${checkext:0:1}" = '.' ]]; then
    NOTIFY_MSG='Please do not prepend a "." to the file extension'
    msg_scan_usage "$NOTIFY_MSG"
    EXIT_JOB_TYPE='InvalidCall'
    return 1
  elif [[ -z "$scanpath" ]]; then
    NOTIFY_MSG='Please supply a path'
    msg_scan_usage "$NOTIFY_MSG"
    EXIT_JOB_TYPE='InvalidCall'
    return 1
  elif [[ ! -d "$scanpath" ]]; then
    NOTIFY_MSG="This folder does not exist: $scanpath"
    msg_scan_usage "$NOTIFY_MSG"
    EXIT_JOB_TYPE='FileOrPathDoesNotExist'
    return 1
  elif [[ "${scanpath:0:1}" != '/' ]]; then
    NOTIFY_MSG='Please specify the full path to the file'
    msg_scan_usage "$NOTIFY_MSG"
    EXIT_JOB_TYPE='InvalidCall'
    return 1
  fi

  #Check that we have the permissions we need for scanpath.
  if [[ "$PROCESS_RECORDING_MODE" =~ ^(LINK|COPY)$ ]]; then
    #We do not typically need to write to scanpath in LINK and COPY modes.
    if ! check_path_permission "$scanpath" 'rx'; then return 1; fi
  else
    if ! check_path_permission "$scanpath" 'rwx'; then return 1; fi
  fi

  warn "--You have entered scan Mode."
  warncont "myth2kodi will conduct a scan of the folder:"
  warncont "  '$scanpath'"
  warncont "searching for file types: '$checkext'. Each file will be processed"
  warncont "through myth2kodi. This mode will only work when database access"
  warncont "is functional."
  warncont "Please scan a single file to test myth2kodi before running in"
  warncont "scan mode. That is, use the following form to test operation:"
  warncont "  myth2kodi '/path/to/file.ext'"
  warncont "In scan mode, myth2kodi will first run the doovers to prevent"
  warncont "clobbering and creation of unnecessary links."
  warncont "All myth2kodi operations can be reversed using the following command:"
  warncont "  myth2kodi --undo"
  warn "Data loss can occur if this operation is interrupted."
  debug "WARNING: RUNNING A SCAN WITH DEBUG LEVEL LOGGING. CONSIDER USING Info(2) LEVEL."
  read -r -n1 -p "  Would you like myth2kodi to conduct a scan? y/(n)>" yesorno
  printf '\n'
  #Default to safety, ie do nothing.
  [[ -z "$yesorno" ]] && yesorno="n"
  if [[ "$yesorno" = 'y' ]]; then
    #Explicitly check for interrupted undo jobs here and call m2k_maintenance(),
    #as it's blocked in subsequent calls to myth2kodi from scan mode.
    [[ -f "$m2kdir/undo.lock" && ! -f "$m2kdir/undo.sh" ]] && mv "$m2kdir/undo.lock" "$m2kdir/undo.sh"
    m2k_maintenance
    myth2kodi --doover
    dooverstatus="$?" #TODO: This only catches the exit state of the final myth2kodi call... Need to review doover.
    if [[ "$dooverstatus" != 0 ]]; then
      err "${FUNCNAME[0]}(): Doover failed or was aborted by user, not continuing with scan."
      #TODO: Temp hack: return status can be non-zero when it's not a problem,
      #                 eg, all processed correctly, but it's a duplicate. Need to review doover generally and myth2kodi exit status...
      read -r -n1 -p "  ERROR DURING DOOVER: Continue with the scan? y/(n)>" yesorno
      printf '\n' ; [[ -z "$yesorno" ]] && yesorno="n"
      [[ "$yesorno" != 'y' ]] && return "$dooverstatus"
    fi
    local scan_file
    if ! scan_file="$(mktemp "$M2K_TMPDIR/m2k_scan_$FILE_NAME_NOW"-XXXX)"; then
      err "${FUNCNAME[0]}(): Failed to create temporary scan file."
      return 1
    fi
    debug "Created a temporary scan file: '$scan_file'"
    ls -1 "$scanpath"/*."$checkext" > "$scan_file"
    inform "Scanning '$scanpath' for '$checkext' files."
    while read -r line ; do
      debug "Attempting to envoke myth2kodi on '$line'"
      if [[ ! -L "$line" && ! -S "$line" && ! -d "$line" ]]; then
        myth2kodi "$line"
      else
        debug "Either we have already moved that or it is a directory. Either way, moving on."
      fi
    done < "$scan_file"
    inform "Completed scan of '$scanpath' for '$checkext' files."
    #If we're not in debug mode then remove the scan file we just processed.
    if (( LOGLEVEL < 3 )); then
      rm -f "$scan_file"
    else
      debug "Not removing the temporary scan file: '$scan_file'"
    fi
    return 0
  else
    inform "You must press 'y' to scan, aborting."
    return 0
  fi
  return 1
} #m2k_scan()

#A special exit point for when we're processing our diagnostics test file.
testfile_exit(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  printf '%s\n' "@@@@ COMPLETE: $(date --rfc-3339=seconds) @@@@" >> "$LOGFILE"
  [[ "$Exx" != 'E07' ]] && err "${FUNCNAME[0]}(): FUZZY FAILURE" && exit 1
  [[ -d ./Episodes ]] && [[ -n "$(find ./Episodes -prune -empty)" ]] && rmdir ./Episodes
  [[ -d ./Movies ]]   && [[ -n "$(find ./Movies   -prune -empty)" ]] && rmdir ./Movies
  [[ -d ./Showings ]] && [[ -n "$(find ./Showings -prune -empty)" ]] && rmdir ./Showings
  exit 0
} #testfile_exit()

#This function provides basic testing of myth2kodi's functionality.
m2k_diagnostics(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local PKGNAME_LIBMYTH_PYTHON=''
  local PKGNAME_PYTHON_LXML=''
  local PKGNAME_CURL=''
  local PKGNAME_AGREP=''
  local PKGNAME_LIBNOTIFY=''
  local PKGNAME_PYTHON=''
  local PKGNAME_JQ=''
  local PKGNAME_REALPATH=''
  local PKGPATH_CURL=''
  local PKGPATH_AGREP=''
  local PKGPATH_LIBNOTIFY=''
  local PKGPATH_JQ=''
  local PKGPATH_REALPATH=''
  local PKGPATH_PYTHON=''
  local python_version='' #Python Version information
  local pyver=0 #An integer representing first 2 points of python version, ie 2.6.3 => 26
  local packagecheck=''
  local DBTest=''
  local notifytest=''
  local PythonBindingsCheck=''
  local exitstatus
  local filesystem_state
  inform "Diagnostic mode entered: $(date)"
  inform "myth2kodi will now conduct a series of tests."
  read -r -n1 -p "press any key to verify installed packages..."
  printf '\n'

  local -i bashlogging_file=0
  local -i mythdb_access_file=0
  local -i mythdb_access_exec=0
  local -i m2k_notify_file=0
  local -i m2k_notify_exec=0
  local -i our_scripts=0
  #Test if our own scripts are where they need to be and, if necessary, executable.
  if [[ -f "$binpath/bashlogging" ]]; then
    inform "Found: $binpath/bashlogging"
  else
    err "Cannot Find: $binpath/bashlogging"
    bashlogging_file=1
  fi
  if [[ -f "$binpath/mythdb_access" ]]; then
    inform "Found: $binpath/mythdb_access"
    [[ -x "$binpath/mythdb_access" ]] || mythdb_access_exec=1
    if ((mythdb_access_exec==0)); then
      inform "Executable: $binpath/mythdb_access"
    else
      err "Not Executable: $binpath/mythdb_access"
    fi
  else
    err "Cannot Find: $binpath/mythdb_access"
    mythdb_access_file=1
    mythdb_access_exec=1
  fi
  if [[ -f "$binpath/m2k_notify" ]]; then
    inform "Found: $binpath/m2k_notify"
    [[ -x "$binpath/m2k_notify" ]] || m2k_notify_exec=1
    if ((m2k_notify_exec==0)); then
      inform "Executable: $binpath/m2k_notify"
    else
      err "Not Executable: $binpath/m2k_notify"
    fi
  else
    err "Cannot Find: $binpath/m2k_notify"
    m2k_notify_file=1
    m2k_notify_exec=1
  fi

  our_scripts=$((bashlogging_file+mythdb_access_file+mythdb_access_exec+m2k_notify_file+m2k_notify_exec))
  ((our_scripts!=0)) && err "Checks for our own scripts ***FAILED***"

  #Test if required packages are installed and accessible to caller.
  PKGPATH_CURL=$(command -v curl)             || PKGNAME_CURL='curl'
  PKGPATH_AGREP="$M2K_AGREP"                  || PKGNAME_AGREP='agrep or tre-agrep'
  PKGPATH_LIBNOTIFY=$(command -v notify-send) || PKGNAME_LIBNOTIFY='libnotify-bin'
  PKGPATH_JQ=$(command -v jq)                 || PKGNAME_JQ='jq'
  PKGPATH_REALPATH=$(command -v realpath)     || PKGNAME_REALPATH='coreutils or realpath'
  if [[ "$DATABASE_ACCESS" = 'PythonBindings' ]]; then
    PKGPATH_PYTHON=$(command -v python) || PKGNAME_PYTHON='python'
    if [[ -z "$PKGNAME_PYTHON" ]]; then
      python_version="$(python --version 2>&1)"  #Python returns version info to stderr
      pyver="$(echo "$python_version" | sed 's/python\s*//I' | cut -f1-2 -d"." | tr -d '.')"
      if ! python -c "from MythTV import MythDB ; exit()" &> /dev/null; then
        PKGNAME_LIBMYTH_PYTHON='libmyth-python'
      fi
      if ! python -c "import lxml ; exit()" &> /dev/null; then
        PKGNAME_PYTHON_LXML='python-lxml'
      fi
    fi
  fi

  #Provide feedback on package checks
  packagecheck="$PKGNAME_CURL$PKGNAME_AGREP$PKGNAME_LIBNOTIFY$PKGNAME_JQ$PKGNAME_REALPATH"
  printf '\n' | tee -a "$DIAGNOSTICS_FILE"
  [[ -n "$PKGPATH_CURL" ]]      && inform "package 'curl' found: $PKGPATH_CURL"
  [[ -n "$PKGPATH_CURL" ]]      && debug "$("$PKGPATH_CURL" --version)"
  [[ -n "$PKGPATH_AGREP" ]]     && inform "package 'agrep' or 'tre-agrep' found: $PKGPATH_AGREP"
  [[ -n "$PKGPATH_AGREP" ]]     && debug "$("$PKGPATH_AGREP" --version)"
  [[ -n "$PKGPATH_LIBNOTIFY" ]] && inform "package 'libnotify-bin' found: $PKGPATH_LIBNOTIFY"
  [[ -n "$PKGPATH_LIBNOTIFY" ]] && debug "$("$PKGPATH_LIBNOTIFY" --version)"
  [[ -n "$PKGPATH_JQ" ]]        && inform "package 'jq' found: $PKGPATH_JQ"
  [[ -n "$PKGPATH_JQ" ]]        && debug "$("$PKGPATH_JQ" --version)"
  [[ -n "$PKGPATH_REALPATH" ]]  && inform "package 'realpath' found: $PKGPATH_REALPATH"
  [[ -n "$PKGPATH_REALPATH" ]]  && debug "$("$PKGPATH_REALPATH" --version)"
  if [[ "$DATABASE_ACCESS" = 'PythonBindings' ]]; then
    packagecheck="$packagecheck$PKGNAME_PYTHON$PKGNAME_LIBMYTH_PYTHON$PKGNAME_PYTHON_LXML"
    [[ -n "$PKGPATH_PYTHON" ]] && inform "package 'python' found: $PKGPATH_PYTHON"
    if [[ -z "$PKGNAME_PYTHON" ]] && ((pyver < 27 || pyver >= 30)); then
      warn "Python 3 and Python older than 2.7 are not supported."
      warncont "You'll need to set: DATABASE_ACCESS='MySQL' in user settings."
    fi
    [[ -z "$PKGNAME_LIBMYTH_PYTHON" ]] && inform "package 'libmyth-python' found."
    [[ -z "$PKGNAME_PYTHON_LXML" ]] && inform "package 'python-lxml' found."
  fi
  if [[ -n "$packagecheck" ]]; then
    packagecheck='***FAILED***'
    err "Installed packages check ***FAILED***"
    errcont "Missing packages are: $PKGNAME_CURL $PKGNAME_AGREP $PKGNAME_LIBNOTIFY $PKGNAME_JQ $PKGNAME_REALPATH $PKGNAME_PYTHON $PKGNAME_LIBMYTH_PYTHON $PKGNAME_PYTHON_LXML"
    errcont "If packages are already installed, check your path settings."
    if [[ "$m2kPlatform" != "Darwin" ]]; then
      errcont "Please install: '$PKGNAME_CURL $PKGNAME_AGREP $PKGNAME_LIBNOTIFY $PKGNAME_JQ $PKGNAME_REALPATH $PKGNAME_PYTHON $PKGNAME_LIBMYTH_PYTHON $PKGNAME_PYTHON_LXML' or equivalent."
    else
      errcont "Please obtain MacPorts and install $PKGNAME_CURL $PKGNAME_AGREP $PKGNAME_LIBNOTIFY $PKGNAME_JQ $PKGNAME_REALPATH $PKGNAME_LIBMYTH_PYTHON $PKGNAME_PYTHON_LXML"
      [[ -n "$PKGNAME_PYTHON" ]] && errcont "Python is missing, please install Python, or make sure it is in your path."
    fi
  else
    packagecheck='***PASSED***'
    inform 'Installed packages check ***PASSED***'
  fi

  #If we're not on Mac OS X, check that user notification is working.
  if [[ "$m2kPlatform" != 'Darwin' ]]; then
    read -r -n1 -p "Press any key to perform Desktop Message test..."
    printf '\n'
    inform 'Performing m2k_notify test'
    informcont "This test verifies that the message was sent to the DBUS."
    informcont "This test does not verify the user has a valid desktop open."
    [[ -f "$m2kdir/myth2kodi.png" ]] || informcont "Remember to copy myth2kodi.png into $m2kdir/"
    [[ -f "$m2kdir/myth2kodi_failed.png" ]] || informcont "Remember to copy myth2kodi_failed.png into $m2kdir/"
    sudo -u "$NotifyUserName" "$binpath/m2k_notify" "myth2kodi test" "Testing Desktop Communications" "$m2kdir/myth2kodi.png"
    if [[ "$?" = '0' ]]; then
      notifytest='***PASSED***'
      inform "Desktop Notifications test $notifytest"
    else
      notifytest='***FAILED***'
      warn "Desktop Notifications test $notifytest"
    fi
  else
    notifytest="   N/A"
  fi

  #If we'll be using MythTV python bindings, check that they're functioning.
  if [[ "$DATABASE_ACCESS" = 'PythonBindings' ]]; then
    read -r -n1 -p "Press any key to perform a test of the MythTV Database python bindings..."
    printf '\n'
    inform "Performing MythTV Python Bindings database test."
    if [[ -z "$PKGNAME_PYTHON" ]]; then
      inform "Python: $PKGPATH_PYTHON"
      inform "Version: $python_version"
    fi

    #If checks above found python-lxml & libmyth-python, do a more thorough testing of MythTV python bindings
    if [[ -z "$PKGNAME_PYTHON$PKGNAME_LIBMYTH_PYTHON$PKGNAME_PYTHON_LXML" ]]; then
      #Use mythdb_access's internal diagnostics function
      "$binpath"/mythdb_access --verbosity="$((LOGLEVEL<3?LOGLEVEL:3))" \
                               --Diagnostic                             \
                               --DBHostName="$DBHostName"               \
                               --DBName="$MySQLMythDb"                  \
                               --DBUserName="$MySQLuser"                \
                               --DBPassword="$MySQLpass"                \
                               --SecurityPin="$DBPin" 2>&1 | err_pipe "mythdb_access: "
      if [[ "${PIPESTATUS[0]}" = '0' ]]; then
        PythonBindingsCheck="OK"
      else
        PythonBindingsCheck="FAILED"
      fi
      if [[ "$PythonBindingsCheck" = 'OK' ]]; then
        inform "MythTV Python Bindings are installed properly."
        DBTest='***PASSED***'
        inform "MythTV Database Test $DBTest"
      else
        err "MythTV PythonBindings are not installed properly"
        errcont "there was a problem connecting to the database, check MythDatabase package."
        DBTest='***FAILED***'
        err "MythTV Database Test $DBTest"
      fi
    else
      DBTest="COULD NOT COMPLETE, SEE MISSING PACKAGES MENTIONED ABOVE."
      err "MythTV Database Test $DBTest"
    fi
  fi

  #Test communication with Kodi
  read -r -n1 -p "Press any key to perform KODI Notification test..."
  printf '\n'
  local curlPOST
  local KODINotifyTestMessage
  local data
  local KODIresp
  local -i KODI_COMM_FAILURES=0
  local GOOD_KODI_RESPONSE
  GOOD_KODI_RESPONSE='{"id":"myth2kodi","jsonrpc":"2.0","result":"OK"}'
  curlPOST='curl --silent --max-time 8 --connect-timeout 5 -H "Content-Type:application/json;" --data-binary'
  KODINotifyTestMessage="KODI Notification test..."
  data=\''{"jsonrpc": "2.0",
           "method": "GUI.ShowNotification",
           "params": {"title": "myth2kodi Test", "message": "'"$KODINotifyTestMessage"'"},
           "id": "myth2kodi"}'\'

  inform "Performing KODI Notification tests..."
  for KODIIP in "${KODIIPs[@]}" ; do
    inform "SENDING REQUESTED COMMANDS TO: ${KODIIP##*@}"
    (( LOGLEVEL > 3 )) && debug "Kodi Access: '$KODIIP'"
    #SEE: http://kodi.wiki/view/HOW-TO:Remotely_update_library and 'man curl'
    KODIresp=$( eval "$curlPOST $data http://$KODIIP/jsonrpc" 2>&1 )
    debugcont "RESPONSE: $KODIresp"
    if [[ -n "$KODIresp" ]]; then
      if [[ "$(printf '%s' "$KODIresp")" = "$GOOD_KODI_RESPONSE" ]]; then
        inform "KODI Communications ***PASSED***"
      else
        err "KODI Communications ***FAILED***"
        errcont "Expected response: '$GOOD_KODI_RESPONSE'"
        errcont "Got response: '$KODIresp'"
        ((++KODI_COMM_FAILURES))
      fi
    else
      err "COMMUNICATIONS NOT ESTABLISHED: ${KODIIP##*@}"
      errcont "This may just mean that the Kodi instance is not running."
      (( LOGLEVEL > 3 )) && debug "Kodi Access: '$KODIIP'"
      ((++KODI_COMM_FAILURES))
    fi
  done
  if ((KODI_COMM_FAILURES==0)); then
    KODIcomm='***PASSED***'
  else
    KODIcomm='***FAILED***'
    err "Communication failed for $KODI_COMM_FAILURES of ${#KODIIPs[@]} Kodi instances."
  fi

  #A minimal RSS check.
  local RSSchecks=''
  if [[ "$CREATE_RSS" = 'Enabled' ]]; then
    if check_path_permission "$RSS_DIRECTORY" 'rwx'; then
      RSSchecks='***PASSED***'
    else
      RSSchecks='***FAILED***'
    fi
  fi

  #Check file system permissions
  read -r -n1 -p "Press any key to test file system permissions..."
  printf '\n'
  inform "Testing file system permissions"

  #Use current directory as a place-holder for a recording's original dir.
  ORIGINAL_DIRNAME="$(pwd)"
  if [[ "$TargetPathIsInputPath" = 'Enabled' ]]; then
    inform "TargetPathIsInputPath is selected. Testing with current folder."
    set_target_dir_as_input_path_dir
  fi

  #Check write permissions and free space for Move and Working directories.
  check_filesystem
  filesystem_state="$?"

  #Print a summary table of writeable directories.
  msg_dir_summary

  if ((filesystem_state == 0)) ; then
    folderchecks='***PASSED***'
    inform "Critical Filesystem checks $folderchecks"
  else
    folderchecks='***FAILED***'
    err "Critical Filesystem checks $folderchecks"
  fi
  if [[ "$packagecheck" = '***PASSED***' && "$folderchecks" = '***PASSED***' ]]; then
    overallchecks='***PASSED***'
  else
    overallchecks='***FAILED***'
  fi
  if [[ "$overallchecks" = '***PASSED***' ]]; then
    read -r -n1 -p "press any key to test myth2kodi..."
    printf '\n'

    #Create a dummy recording file for testing.
    export M2K_TEST_FILE="$m2kdir/6666_20420101084242.tst"
    touch "$M2K_TEST_FILE"

    inform "Recordings Database is not used for testing."
    informcont "Performing fuzzy logic lookup on database file. Please wait."
    informcont "It may take a moment to build the myth2kodi database files."
    informcont "Executing: myth2kodi '$M2K_TEST_FILE' 'mister rogers' 'show 1332'"
    informcont "Testing exit status..."

    #TODO: the expectation is that myth2kodi is in the caller's path, otherwise
    #      supplemental functionality like doover won't work. While we could add
    #      $binpath here and in doover, etc, that would mean doover would break
    #      on reinstall to a new location... So, probably best to just add a
    #      diagnostic warning/error if myth2kodi is not in caller's path so that
    #      it is considered part of a proper configuration...
    #Run myth2kodi against the dummy file
    myth2kodi "$M2K_TEST_FILE" 'mister rogers' 'show 1332'
    exitstatus="$?"
    informcont  "exited with status $exitstatus"

    #Clean-up the dummy recording file.
    [[ -f "$M2K_TEST_FILE" ]] && rm -f "$M2K_TEST_FILE"
    unset M2K_TEST_FILE

    if [[ "$exitstatus" = '0' ]]; then
      mythicaltest='***PASSED***'
    else
      err "OVERALL FAILURE -- checks passed, but test run failed."
      mythicaltest="COULD NOT COMPLETE"
      overallchecks='***FAILED***'
    fi
  else
    err "OVERALL FAILURE"
    mythicaltest="COULD NOT COMPLETE"
  fi
  read -r -n1 -p "press any key to continue on to the final results..."
  printf '\n'
  inform "RESULTS SUMMARY:"
  [[ "$DATABASE_ACCESS" = 'PythonBindings' ]] && informcont "MythTV Database Test: $DBTest"
  informcont "Installed Packages:   $packagecheck $PKGNAME_LIBMYTH_PYTHON $PKGNAME_PYTHON_LXML $PKGNAME_CURL $PKGNAME_AGREP $PKGNAME_LIBNOTIFY $PKGNAME_JQ $PKGNAME_REALPATH"
  informcont "Notifications Test:   $notifytest"
  informcont "KODI Communications:  $KODIcomm"
  informcont "File System Checks:   $folderchecks"
  informcont "myth2kodi Testing:    $mythicaltest"

  informcont "Overall Readiness:    $overallchecks"
  informcont "-----End of diagnostics-----"
  printf '\n' | tee -a "$DIAGNOSTICS_FILE"

  #Logging for failure messages
  if [[ "$DBTest" = '***FAILED***' ]]; then
    err "Database tests failed"
    errcont "When interfacing MythTV >=0.24, myth2kodi can use MythTV's Python"
    errcont "Bindings. These must be configured and working for proper access"
    errcont "to data required by myth2kodi."
    errcont "Could not connect to the database. Check username and password."
    printf '\n' | tee -a "$DIAGNOSTICS_FILE"
  fi

  if [[ "$notifytest" = '***FAILED***' ]]; then
    err "Notify tests failed"
    errcont "Notifications to the DBUS have failed. myth2kodi relies upon"
    errcont "m2k_notify and package lib-notify to display messages on"
    errcont "GNOME desktop interface. These messages will not be displayed. "
    printf '\n' | tee -a "$DIAGNOSTICS_FILE"
  fi

  if [[ "$KODIcomm" = '***FAILED***' ]]; then
    err "Kodi communication tests failed: $KODI_COMM_FAILURES of ${#KODIIPs[@]}."
    errcont "This will not prevent myth2kodi from functioning, it just means"
    errcont "that myth2kodi can not send messages or library update requests"
    errcont "to Kodi. There are a few possible causes for this problem:"
    errcont "    1. One or more of the Kodi instances you specified in KODIIPs"
    errcont "       is not currently running. Start Kodi."
    errcont "    2. One or more of the Kodi instances is not configured to accept"
    errcont "       external network commands. See,"
    errcont "         Kodi->System->Settings->Services->Remote Control."
    errcont "         Kodi->System->Settings->Services->Web Server."
    errcont "    3. The settings you provided in KODIIPs are incorrect. Check"
    errcont "       that the IP addresses are correct. If you've set a user and"
    errcont "       password for http access in Kodi, make sure that you've also"
    errcont "       prepended them to the ip addresses in KODIIPs"
    errcont "         user:password@192..."
    errcont ""
    printf '\n' | tee -a "$DIAGNOSTICS_FILE"
  fi

  if [[ "$RSSchecks" = '***FAILED***' ]]; then
    err "RSS tests failed"
    errcont "This either means the RSS_DIRECTORY: '$RSS_DIRECTORY'"
    errcont "does not exist, or you do not have sufficient permissions to write"
    errcont "to it. If you want to generate an RSS feed, then either ceate the"
    errcont "directory and give it rwxr-xr-x permissions, or set RSS_DIRECTORY"
    errcont "to a directory that exists and that you have write permission for."
    errcont "If you do not want an RSS feed then set CREATE_RSS='Disabled'."
    printf '\n' | tee -a "$DIAGNOSTICS_FILE"
  fi

  if [[ "$folderchecks" = '***FAILED***' ]]; then
    err "The filesystem checks failed."
    errcont "First check that the Librarian user setting is correct, and that"
    errcont "you're running myth2kodi as that user. Currently Librarian='$Librarian'."
    errcont "The user '$Librarian' will need permission to read and write to all"
    errcont "relevant directories. If Librarian is the same user running MythTV, try:"
    errcont "  sudo chown -R $Librarian /Name/of/My_failed_folder"
    errcont "  chmod -R u+rw /Name/of/My_failed_folder"
    printf '\n' | tee -a "$DIAGNOSTICS_FILE"
    errcont "If you've set the myth2kodi Librarian to a different user than the one"
    errcont "running MythTV then, while the above will work for myth2kodi specific"
    errcont "directories, for MythTV recording directories you'll need to add the"
    errcont "appropriate group to your myth2kodi Librarian and enable read/write."
    printf '\n' | tee -a "$DIAGNOSTICS_FILE"
    errcont "It is also possible that the directory does not exist, in that case try:"
    errcont "  mkdir /Name/of/My_failed_folder"
    printf '\n' | tee -a "$DIAGNOSTICS_FILE"
  fi

  if [[ "$mythicaltest" != '***PASSED***' ]]; then
    err "Test run of myth2kodi failed."
    errcont "myth2kodi has encountered an error. This may be due to a"
    errcont "lack of network connection. If the problem persists, try"
    errcont "reading then asking at: http://forum.kodi.tv/showthread.php?tid=301925"
    printf '\n' | tee -a "$DIAGNOSTICS_FILE"
  fi

  if [[ "$overallchecks" = '***FAILED***' ]]; then
    inform "The issues mentioned above must be corrected for myth2kodi to perform correctly."
  fi

  inform "Diagnostic mode completed: $(date)"
  debug "A diagnostics log file was written to: $LOGFILE"

  [[ "$overallchecks" = '***FAILED***' ]] && return 1

  return 0
} #m2k_diagnostics()

#This function provides an easy way to redo failed jobs.
m2k_doover(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  [[ "$LOGTYPE" = 'file' ]] && printf '%s\n' "WARNING: Recommend setting LOGTYPE='filestderr', before proceeding.."
  local yesorno=''
  local dooverstatus

  warn "--You have entered doover mode."
  warncont "In this mode of operation, myth2kodi will be rerun against all"
  warncont "files which were moved in the past despite having low confidence."
  warncont "It is important that this process is not interrupted or data loss may occur."
  ((DoOverBypass != 1)) && read -r -n1 -p "  Doover requested -- 'y' to continue, 'n' to exit... y/(n):>" yesorno && printf '\n'
  ((DoOverBypass == 1)) && yesorno='y'

  if [[ "$yesorno" = 'y' && -f "$m2kdir/doover.sh" ]]; then
    debug "Running doover.sh"
    #NOTE: The first command in doover.sh is to delete the file doover.sh.
    cp "$m2kdir/doover.sh" "$m2kdir/doover_${FILE_NAME_NOW}.sh"
    chmod +x "$m2kdir/doover.sh"
    #TODO: Need to fix err_pipe for subcalls to myth2kodi # 2>&1 | err_pipe "doover: "
    "$m2kdir/doover.sh"
    dooverstatus="$?" #Change back if address above TODO: "${PIPESTATUS[0]}"
    #TODO: The dooverstatus is most likely the myth2kodi exit status for the
    #      last recording processed by doover.sh...
    if [[ "$dooverstatus" != 0 ]]; then
      err "${FUNCNAME[0]}(): Doover failed or was aborted by user."
    else
      inform "Finished running doover.sh."
      kodi_cleanup
    fi
    return "$dooverstatus"
  else
    if [[ -f "$m2kdir/doover.sh" ]]; then
      inform "You must press y to execute Doover."
      return 1
    else
      inform "No Doover jobs exist."
      return 0
    fi
  fi
  return 1
} #m2k_doover()

#This function provides an easy way to undo all myth2kodi jobs
m2k_undo_all(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  [[ "$LOGTYPE" = 'file' ]] && printf '%s\n' "WARNING: Recommend setting LOGTYPE='filestderr', before proceeding..."
  #TODO: Add permission checking.
  warn "--You have entered undo mode."
  warncont " In this mode of operation, myth2kodi will reverse"
  warncont " file changes created by the current user while running."
  warncont " myth2kodi. It is important that this process is not"
  warncont " interrupted or data loss may occur."
  local yesorno=""
  read -r -n1 -p "  Press 'y' to continue or 'n' to exit..... y/(n):>" yesorno
  printf '\n'
  if [[ "$yesorno" = 'y' ]]; then
    local undostatus
    warn "Running undo.sh DO NOT INTERRUPT THIS PROCESS OR DATA LOSS MAY OCCUR."
    cp "$m2kdir/undo.sh" "$m2kdir/undo.lock"
    if [[ -f "$m2kdir/undo.sh" ]]; then
      cp "$m2kdir/undo.sh" "$m2kdir/undo_${FILE_NAME_NOW}.sh"
      chmod +x "$m2kdir/undo.sh"
      "$m2kdir/undo.sh" 2>&1 | err_pipe "undo: "
      undostatus="${PIPESTATUS[0]}"
      if [[ "$undostatus" != 0 ]]; then
        err "${FUNCNAME[0]}(): undo failed or was aborted by user."
        return "$undostatus"
      else
        inform "Finished running undo.sh."
      fi
    fi
    rm -f "$m2kdir/undo.lock"

    #If we've undone everything then our doover.sh is no longer valid.
    if [[ -f "$m2kdir/doover.sh" ]]; then
      debug "Moving doover.sh to 'doover_${FILE_NAME_NOW}.sh'."
      mv "$m2kdir/doover.sh" "$m2kdir/doover_${FILE_NAME_NOW}.sh"
    fi

    #If all processing was successfully undone, then calling the maintenance
    #routine should clean-up all files and dirs we were tracking.
    myth2kodi --maintenance

    #Our Kodi instances will still show entries in their video libraries for
    #all the shows we just 'unmoved', so request them to perform cleanup.
    kodi_cleanup

    return 0
  else
    inform "You must press y to execute undo"
    return 0
  fi
  return 1
} #m2k_undo_all()

remove_undo_doover_entries(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "m2kdir='$m2kdir'"
  debugcont "RECORDING_LINK='$RECORDING_LINK'"
  debugcont "RECORDING_LINK_OWNER='$RECORDING_LINK_OWNER'"
  debugcont "RECORDING_NAME='$RECORDING_NAME'"

  local -i undo_entry_remove_status=0
  local -i doover_entry_remove_status=0

  #NOTE: In LINK mode, RECORDING_LINK => myth2kodi file name;
  #      In MOVE with SYMLINKing='Enabled', RECORDING_LINK => MythTV file name.
  debug "Removing lines mentioning '$RECORDING_LINK' from '$m2kdir/undo.sh'"
  sed -i.bak "\#$RECORDING_LINK#d" "$m2kdir/undo.sh" 2>&1 | err_pipe "ERROR: ${FUNCNAME[0]}(): Line $LINENO: "
  undo_entry_remove_status="${PIPESTATUS[0]}"
  debug "undo_entry_remove_status='$undo_entry_remove_status'"
  (( LOGLEVEL < 3 )) && rm -f "$m2kdir/undo.sh.bak"

  #Delete doover.sh entries associated with $RECORDING_NAME
  if [[ -f "$m2kdir/doover.sh" && -n "$RECORDING_NAME" ]]; then
    debug "Removing lines related to '$RECORDING_NAME' == '$RECORDING_LINK' from '$m2kdir/doover.sh'"
    if [[ "$RECORDING_LINK_OWNER" = 'myth2kodi' ]]; then
      #Was processed in LINK mode, so find and delete LINK removal line
      sed -i.bak "\#$RECORDING_LINK#d" "$m2kdir/doover.sh" 2>&1 | err_pipe "ERROR: ${FUNCNAME[0]}(): Line $LINENO: "
      (( doover_entry_remove_status+=PIPESTATUS[0] ))
      debug "doover_entry_remove_status='$doover_entry_remove_status'"
      (( LOGLEVEL < 3 )) && rm -f "$m2kdir/doover.sh.bak"
    fi
    #Find and delete all lines in MOVE mode or just the myth2kodi line in LINK mode
    sed -i.bak "\#$RECORDING_NAME#d" "$m2kdir/doover.sh" 2>&1 | err_pipe "ERROR: ${FUNCNAME[0]}(): Line $LINENO: "
    (( doover_entry_remove_status+=PIPESTATUS[0] ))
    debug "doover_entry_remove_status='$doover_entry_remove_status'"
    (( LOGLEVEL < 3 )) && rm -f "$m2kdir/doover.sh.bak"
  else
    warn "The MythTV-recording-file name was not identified, so we cannot remove doover entries."
    warncont "This should only occur for --undo of non-MythTV files, and in that case there should not"
    warncont "be any associated doover entries anyway. If you think this is a MythTV-recording then you"
    warncont "may have encountered a bug, so check your logs."
  fi
  return "$(( undo_entry_remove_status + doover_entry_remove_status ))"
} #remove_undo_doover_entries()

#Provides a mechanism to undo processing of a specified recording.
m2k_undo_rec(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #We can only undo recordings that we have successfully processed. Every
  #recording we have successfully processed has an entry in the auto generated
  #undo.sh script. So just extract the entry from undo, run it and the remove
  #it from undo if we were successful...

  #Identify the recording file, recording link, and who owns what.
  if identify_recording_files "$1" && [[ -n "$RECORDING_LINK" ]]; then
    local recording_undo_file
    recording_undo_file="$(mktemp "$M2K_TMPDIR/m2k_recording_undo_$FILE_NAME_NOW"-XXXX)"

    #Try and extract the undo entries associated with $RECORDING_LINK from undo.sh
    #NOTE: In LINK mode, RECORDING_LINK => myth2kodi file name;
    #      In MOVE with SYMLINKing='Enabled', RECORDING_LINK => MythTV file name.
    sed -n "\#$RECORDING_LINK#p" "$m2kdir/undo.sh" > "$recording_undo_file"

    #If we did not find matching lines then return error state.
    if [[ ! -s "$recording_undo_file" ]]; then
      err "${FUNCNAME[0]}(): Failed to find undo entry for '$1'"
      return 1
    fi

    #We found matching lines, so process them.
    chmod +x "$recording_undo_file"
    local undostatus
    "$recording_undo_file" 2>&1 | err_pipe "undo: "
    undostatus="${PIPESTATUS[0]}"
    (( LOGLEVEL < 3 )) && rm -f "$recording_undo_file"

    if [[ "$undostatus" = '0' ]]; then
      #Remove the undo and doover entries associated with the recording.
      remove_undo_doover_entries
      #TODO: Consider whether we should be running maintenance here...
      return "$?"
    fi
    err "${FUNCNAME[0]}(): Failed executing undo commands: $1"
    return 1
  else
    err "${FUNCNAME[0]}(): Unprocessed or MOVEed with SYMLINKing='Disabled', cannot undo: $1"
    return 1
  fi
} #m2k_undo_rec()

#Update the myth2kodi database tables for a specified Series.
get_series_info(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "TVDB_SERIESID='$TVDB_SERIESID'"
  debugcont "TVDB_TITLE='$TVDB_TITLE'"
  if [[ "$ONLINE_LOOKUP" != 'Disabled' && -n "$TVDB_SERIESID" ]]; then
    make_m2k_database_dir
    if ! check_m2k_database_up_to_date; then
      if ! download_series_info; then
        warn "Could not download up-to-date information from TheTVDB! Requiring doover."
        RequiresDoover=1
        return 1
      fi
    fi
    #Add series-list and seriesid-list entries if we haven't already.
    add_series_list_entry
  fi
  return 0
} #get_series_info()

#Delete: the recording file and any links to it; associated database entry and
#        thumbnails; any undo, doover or created.tracking entries; and any
#        associated support files (comskip, NFO).
delete_recording_from_mythtv(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  debugcont "RECORDING_NAME='$RECORDING_NAME'"
  debugcont "DATABASE_ACCESS='$DATABASE_ACCESS'"
  debugcont "RERECORD='$RERECORD'"

  local inputarg="$1"

  #If we haven't already...
  if [[ -z "$RECORDING_NAME" ]]; then
    #Identify file, link, who owns what, and the MythTV path and basename.
    if ! identify_recording_files "$inputarg"; then return 1; fi
  fi

  #Cannot sensibly delete a recording from MythTV that is not a MythTV recording.
  if [[ -z "$RECORDING_NAME" ]]; then
    err "${FUNCNAME[1]}():${FUNCNAME[0]}(): Cannot delete non-MythTV file."
    return 1
  fi

  if [[ "$Database" = 'Enabled' ]]; then
    #Delete the recording file and its associated DB entry
    case "$DATABASE_ACCESS" in
      MySQL)
        if [[ "$RERECORD" = 'Enabled' ]]; then
          err "${FUNCNAME[0]}(): NotImplemented: You need to use PythonBindings for --rerecord."
          return 1
        else
          #Delete the recording file and any link to it.
          [[ -L "$RECORDING_LINK" ]] && rm -f "$RECORDING_LINK"
          if [[ -z "$DISCONNECT" && -f "$RECORDING_FILE" ]]; then
            if ! rm -f "$RECORDING_FILE"; then
              NOTIFY_MSG="Failed deleting recording file."
              err "${FUNCNAME[1]}():${FUNCNAME[0]}(): $NOTIFY_MSG"
              EXIT_JOB_TYPE='RemoveFailed'
              return 1
            fi
          fi

          #Delete the associated database entry and thumbnails.
          if ! delete_mythtv_database_entry_mysql; then
            NOTIFY_MSG="Failed deleting MythTV-DB entry using MySQL."
            err "${FUNCNAME[1]}():${FUNCNAME[0]}(): $NOTIFY_MSG"
            EXIT_JOB_TYPE='MythTVdatabaseFailure'
            return 1
          fi
        fi
        ;;
      PythonBindings)
        local mtv_recinfo_file
        if ! mtv_recinfo_file="$(mktemp "$M2K_TMPDIR/m2k_delrecinfo_$FILE_NAME_NOW"-XXXX)"; then
          err "${FUNCNAME[0]}(): Failed to create temporary delrecinfo file."
          return 1
        fi
        debug "Deleted recording info will be stored in temporary file: '$mtv_recinfo_file'"

        if [[ "$RERECORD" = 'Enabled' ]]; then
          #Ask mythbackend to delete and rerecord the recording.
          "$binpath"/mythdb_access --verbosity="$((LOGLEVEL<3?LOGLEVEL:3))" \
                                   --filename="$RECORDING_NAME"             \
                                   --SecurityPin="$DBPin"                   \
                                   --DBHostName="$DBHostName"               \
                                   --DBName="$MySQLMythDb"                  \
                                   --DBUserName="$MySQLuser"                \
                                   --DBPassword="$MySQLpass"                \
                                   --output="$mtv_recinfo_file"             \
                                   --writeFile                              \
                                   --force                                  \
                                   --rerecord 2>&1 | err_pipe "mythdb_access: "
          returnstatus="${PIPESTATUS[0]}"
        else
          #Ask mythbackend to delete the recording (there can be a delay of 5-10 min).
          "$binpath"/mythdb_access --verbosity="$((LOGLEVEL<3?LOGLEVEL:3))" \
                                   --filename="$RECORDING_NAME"             \
                                   --SecurityPin="$DBPin"                   \
                                   --DBHostName="$DBHostName"               \
                                   --DBName="$MySQLMythDb"                  \
                                   --DBUserName="$MySQLuser"                \
                                   --DBPassword="$MySQLpass"                \
                                   --output="$mtv_recinfo_file"             \
                                   --writeFile                              \
                                   --force                                  \
                                   --delete 2>&1 | err_pipe "mythdb_access: "
          returnstatus="${PIPESTATUS[0]}"
        fi
        if [[ "$returnstatus" != '0' ]]; then
          NOTIFY_MSG="Failed deleting recording with Python-bindings."
          err "${FUNCNAME[1]}():${FUNCNAME[0]}(): $NOTIFY_MSG"
          EXIT_JOB_TYPE='MythTVdatabaseFailure'
          return "$returnstatus"
        fi
        ;;
      *)
        NOTIFY_MSG="DATABASE_ACCESS incorrectly specified."
        err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
        EXIT_JOB_TYPE='UserSettingError'
        return 1
        ;;
    esac
  else
    NOTIFY_MSG="Trying to delete a recording with Database='Disabled'."
    err "${FUNCNAME[0]}() CALLED FROM: ${FUNCNAME[1]}(): $NOTIFY_MSG"
    EXIT_JOB_TYPE='InsufficientInformationProvided'
    return 1
  fi

  #Remove the undo and doover entries associated with the recording. If there
  #was no RECORDING_LINK found then there should not be undo or doover entries.
  [[ -n "$RECORDING_LINK" ]] && remove_undo_doover_entries
  #TODO: ?capture return state here?

  #TODO: Should try to determine if there are any other recordings in the directory
  #      containing this recording and if not remove any associated dir.tracking entry.

  #Delete created.tracking entries associated with recording.
  if [[ "$RECORDING_FILE_OWNER" = 'myth2kodi' ]]; then
    debug "File tracked by myth2kodi."
    debug "Removing lines mentioning '$RECORDING_FILE' from '$m2kdir/created.tracking'"
    sed -i.bak "\#$RECORDING_FILE#d" "$m2kdir/created.tracking" 2>&1 | err_pipe "ERROR: ${FUNCNAME[0]}(): Line $LINENO: "
  elif [[ "$RECORDING_LINK_OWNER" = 'myth2kodi' && -n "$RECORDING_LINK" ]]; then
    debug "Link tracked by myth2kodi."
    debug "Removing lines mentioning '$RECORDING_LINK' from '$m2kdir/created.tracking'"
    sed -i.bak "\#$RECORDING_LINK#d" "$m2kdir/created.tracking" 2>&1 | err_pipe "ERROR: ${FUNCNAME[0]}(): Line $LINENO: "
  fi
  (( LOGLEVEL < 3 )) && [[ -f "$m2kdir/created.tracking.bak" ]] && rm -f "$m2kdir/created.tracking.bak"

  return 0
} #delete_recording_from_mythtv()

#Called from myth2kodi --delete and myth2kodi --rerecord.
switch_delete_recording(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  warn "Attempting to delete recording: '$1'"
  warncont "This will PERMANENTLY delete the recording, associated files"
  warncont "and the associated MythTV database entry."
  warncont "Are you sure you want to continue?"
  local yesorno=""
  if [[ "$RERECORD" = 'Enabled' ]]; then
    read -r -n1 -p "  Requested deletion with rerecord: 'y' to continue or 'n' to exit... y/(n):>" yesorno
  else
    read -r -n1 -p "  Requested permanent deletion: 'y' to continue or 'n' to exit... y/(n):>" yesorno
  fi
  printf '\n'
  [[ "$yesorno" != 'y' ]] && { inform "You must press 'y' to continue, aborting."; return 1 ; }

  if ! delete_recording_from_mythtv "$1"; then return 1; fi

  #Delete any comskip or NFO files associated with the recording.
  if [[ "$RECORDING_FILE_OWNER" = 'myth2kodi' ]]; then
    rm -f "${RECORDING_FILE%.*}.nfo"
    rm -f "${RECORDING_FILE%.*}.txt"
  elif [[ "$RECORDING_LINK_OWNER" = 'myth2kodi' ]]; then
    rm -f "${RECORDING_LINK%.*}.nfo"
    rm -f "${RECORDING_LINK%.*}.txt"
  fi
  return 0
} #switch_delete_recording()

disconnect_recording(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  warn "Attempting to disconnect recording: '$1'"
  warncont "This will PERMANENTLY disconnect the recording from MythTV,"
  warncont "deleting the associated MythTV database entry."
  warncont "Are you sure you want to continue?"
  local yesorno=""
  read -r -n1 -p "  Requested permanent disconnection: 'y' to continue or 'n' to exit... y/(n):>" yesorno
  printf '\n'
  [[ "$yesorno" != 'y' ]] && { inform "You must press 'y' to continue, aborting."; return 1 ; }

  local inputarg="$1"

  #Identify file, link, who owns what, and the MythTV path and basename.
  if ! identify_recording_files "$inputarg"; then return 1; fi

  #Cannot sensibly "disconnect" a recording that has not been processed or has
  #already been disconnected.
  if [[ -z "$RECORDING_LINK" ]]; then
    err "${FUNCNAME[1]}():${FUNCNAME[0]}(): Cannot disconnect unprocessed or already disconnected recording."
    return 1
  fi

  #Cannot sensibly "disconnect" a recording from MythTV that is not a MythTV recording.
  if [[ -z "$RECORDING_NAME" ]]; then
    err "${FUNCNAME[1]}():${FUNCNAME[0]}(): Cannot disconnect non-MythTV file."
    return 1
  fi

  #Remove link associated with recording.
  if [[ -L "$RECORDING_LINK" ]]; then
    if ! rm -f "$RECORDING_LINK"; then
      err "${FUNCNAME[1]}():${FUNCNAME[0]}(): Failed deleting recording link."
      return 1
    fi
  fi

  #If recording file still has a MythTV name ('moved' in LINK mode) then
  #actually move it to myth2kodi name.
  if [[ "$RECORDING_FILE_OWNER" = 'MythTV' ]]; then
    local mv_status
    inform "Recording was processed in 'LINK' mode, actually moving file now..."
    mv "$RECORDING_FILE" "$RECORDING_LINK" 2>&1 | err_pipe "${FUNCNAME[0]}(): "
    mv_status="${PIPESTATUS[0]}"
    if [[ "$mv_status" != 0 ]]; then
      err "${FUNCNAME[0]}(): FAILED: mv '$RECORDING_FILE' '$RECORDING_LINK'"
      return "$mv_status"
    fi
  fi

  declare -g DISCONNECT='true'
  if ! delete_recording_from_mythtv "$inputarg"; then return 1; fi

  return 0
} #disconnect_recording()

#Displays the log entries for processing of a specified recording file.
recording_log(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  #Process all the log files in our working directory and:
  #  Select only recording processing entries;
  #  Make each recording processing entry into an awk 'record';
  #  Print only records containing RECORDING_NAME, slightly formatted:
  #    two blank lines between records;
  #    prepend each record with the name of the log file it came from.
  local proc='@@@@ PROCESSING RECORDING:'
  local comp='@@@@ COMPLETE:'
  local logfile_pattern="${LogFileName}_20[0-9][0-9]-[0-1][0-9]-[0-3][0-9]*.gz"
  local log_file
  local logfilelist_file
  local templog_file
  #Find the MythTV recording file name and its path.
  if ! set_recording_name "$1"; then return 1; fi
  debug "RECORDING_PATH: '$RECORDING_PATH'"
  debug "RECORDING_NAME: '$RECORDING_NAME'"
  if ! logfilelist_file="$(mktemp "$M2K_TMPDIR"/m2k_logfilelist-XXXX)"; then
    err "${FUNCNAME[0]}(): Failed to create temporary logfilelist file."
    return 1
  fi
  debug "Created a temporary list of logfiles file: '$logfilelist_file'"
  if ! templog_file="$(mktemp "$M2K_TMPDIR"/m2k_templog-XXXX)"; then
    err "${FUNCNAME[0]}(): Failed to create temporary templog file."
    return 1
  fi
  debug "Created a temporary recording-specific log file: '$templog_file'"
  #Start a log file list with the current log file
  printf '%s\n' "$LOGFILE" > "$logfilelist_file"
  #Add archived log files to the list, most recent first
  find "$m2kdir" -maxdepth 1 -type f -name "$logfile_pattern" | sort -r >> "$logfilelist_file"
  #Create a temporary log file for this recording
  printf '%s\n\n' "#### Log entries for: $RECORDING_NAME ####" > "$templog_file"
  while read -r log_file ; do
    if [[ "${log_file##*.}" = 'gz' ]]; then
      if gzip -dc "$log_file" 2>/dev/null | grep -q "$proc" ; then
        debug "Searching for relevant entries in: '$log_file'"
        awk '/'"$proc"'/,/'"$comp"'/ {print $0}' <(gzip -dc "$log_file") \
          | awk -v RS="$proc" -v OFS='\n' -v ORS='\n\n'                  \
              '$0~/'"${RECORDING_NAME%%.}"'/{print "'"$log_file"'",RS$0}' >> "$templog_file"
      fi
    elif [[ "${log_file##*.}" = 'log' ]]; then
      #Confirm the log file actually contains a process recording entry
      if grep -q "$proc" "$log_file" ; then
        debug "Searching for relevant entries in: '$log_file'"
        awk '/'"$proc"'/,/'"$comp"'/ {print $0}' "$log_file" \
          | awk -v RS="$proc" -v OFS='\n' -v ORS='\n\n'      \
              '$0~/'"${RECORDING_NAME%%.}"'/{print "'"$log_file"'",RS$0}' >> "$templog_file"
      fi
    else
      warn "${FUNCNAME[0]}(): Unrecognised log file match: $log_file"
    fi
  done < "$logfilelist_file"
  (( LOGLEVEL < 3 )) && rm -f "$logfilelist_file"
  #
  if (( $(wc --lines < "$templog_file") > 2 )); then
    debug "Viewing log entries for '$RECORDING_NAME' in less."
    less "$templog_file"
    debug "Finished viewing."
    (( LOGLEVEL < 3 )) && rm -f "$templog_file"
    return 0
  else
    inform "There do not appear to be any processing entries for: $1"
    printf '%s\n' "#### NO ENTRIES FOUND ####" >> "$templog_file"
    return 1
  fi
} #recording_log()

#Creates a comskip file for a recording or all recordings in a directory.
#Actual file generation is done by generate_comskip()
recreate_comskip(){
  debug "ENTERING: ${FUNCNAME[0]}() ; CALLED FROM: ${FUNCNAME[1]}()"
  local inputarg="$1"
  local checkext="$2"
  if [[ -f "$inputarg" ]]; then
    inform "Regenerating comskip file for $inputarg"

    #Identify file, link, who owns what, and the MythTV path and basename.
    if ! identify_recording_files "$inputarg"; then return 1; fi

    #Identify the target for the comskip file
    if [[ "$RECORDING_FILE_OWNER" = 'myth2kodi' ]]; then
      ShowComSkip="${RECORDING_FILE%.*}.txt"
    elif [[ "$RECORDING_LINK_OWNER" = 'myth2kodi' ]]; then
      ShowComSkip="${RECORDING_LINK%.*}.txt"
    else
      err "${FUNCNAME[0]}(): Neither the identified link nor file are owned by myth2kodi."
      return 1
    fi

    #Get the MythTV-DB info, which includes the comskip info.
    if ! get_mythtvdb_info; then return 1; fi

    #Move the comskip file into place
    inform "Moving new comskip file to: ${ShowComSkip}"
    mv "$MARKUPFRAMES_TMP" "$ShowComSkip" 2>&1 | err_pipe "${FUNCNAME[0]}(): "
    #Set permission 664 (rw-rw-r--)
    chmod 664 "$ShowComSkip" 2>&1 | err_pipe "${FUNCNAME[0]}(): "
    return "${PIPESTATUS[0]}"

  elif [[ -d "$inputarg" ]]; then
    local yesorno='no' #Default to safety, ie do nothing.
    warn "YOU ARE ABOUT TO SCAN THE DIRECTORY: $inputarg"
    warncont "AND REGENERATE COMSKIP FILES FOR ALL PREVIOUSLY MOVED RECORDINGS."
    read -r -n1 -p "  Do you want myth2kodi to regenerate all comskip files? y/(n)>" yesorno
    printf '\n'
    #Default to safety, ie do nothing.
    if [[ "$yesorno" = 'y' ]]; then
      local scanpath
      #Default to mpg extension
      [[ -z "$checkext" ]] && checkext='mpg'
      #Strip any trailing / from  inputarg
      scanpath="${inputarg%*/}"
      debug "Checking for files with names of the form: '$scanpath/filename.$checkext'"
      local comskip_scan_file
      if ! comskip_scan_file="$(mktemp "$M2K_TMPDIR/m2k_comskip_scan_$FILE_NAME_NOW"-XXXX)"; then
        err "${FUNCNAME[0]}(): Failed to create temporary comskip-scan file."
        return 1
      fi
      debug "Created a temporary comskip_scan file: '$comskip_scan_file'"
      ls -1 "$scanpath"/*."$checkext" > "$comskip_scan_file"
      inform "Scanning $scanpath for already moved $checkext files"
      while read -r line ; do
        debug "Attempting to regenerate comskip file for '$line'"
        myth2kodi --comskip "$line"
      done < "$comskip_scan_file"

      #If we're not in debug mode then remove the comskip scan file we just processed.
      if (( LOGLEVEL < 3 )); then
        rm -f "$comskip_scan_file"
      else
        debug "Not removing the temporary comskip scan file: '$comskip_scan_file'"
      fi
      return 0
    else
      inform "You must press 'y' to scan, aborting."
      return 0
    fi
  else
    EXIT_JOB_TYPE='FileOrPathDoesNotExist'
    NOTIFY_MSG="Provided arg is neither a file nor a directory: '$inputarg'"
    err "${FUNCNAME[0]}(): $NOTIFY_MSG"
    return 1
  fi
} #recreate_comskip()

############################## MAIN FUNCTION #################################

#The main myth2kodi function...
main(){
  #Initial setup: override defaults with myth2kodi.conf; initialise logging system.
  if ! m2k_init; then return 1; fi
  #NOTE: m2k_init() exits directly for errors that come to early for exit_job() to run.

  #Basic tests to make sure we were called correctly.
  if ! validate_args; then return 1; fi

  #If the first arg is a command line switch, figure out what to do.
  if [[ "${M2KARG1:0:1}" = '-' ]]; then
    if parse_command_flags; then return 0; else return 1; fi
  fi
  debug "No command flag set. Processing as recording."

  #From time-to-time check created.tracking, dir.tracking, and remove orphans.
  #NOTE: This can take some time, so do not do it before parse_command_flags()
  #      as some of those are small quick things.
  periodic_maintenace

  #No flags, so inputs should be for processing a recording.
  INPUT_PATH="$M2KARG1"
  INPUT_TITLE="$M2KARG2"
  INPUT_SUBTITLE="$M2KARG3"
  INPUT_SEASON="$M2KARG4"
  INPUT_EPISODE="$M2KARG5"
  #Make them read-only so we can't accidentally modify them.
  declare -gr INPUT_PATH INPUT_TITLE INPUT_SUBTITLE INPUT_SEASON INPUT_EPISODE

  #Extract components of the file we're processing.
  INPUT_PATH_BASENAME="$(basename "$INPUT_PATH")" #"${INPUT_PATH##*/}"
  ORIGINAL_EXT="${INPUT_PATH_BASENAME##*.}"
  if ! set_recording_name "$INPUT_PATH"; then return 1; fi
  ORIGINAL_DIRNAME="$(dirname "$RECORDING_PATH")"

  #Reset move paths if TargetPathIsInputPath is active, creating dirs as needed.
  if [[ "$TargetPathIsInputPath" = 'Enabled' ]]; then
    inform "TargetPathIsInputPath=Enabled. Resetting paths, creating directories."
    set_target_dir_as_input_path_dir
  fi

  #Initial log entry for the processing of recording, regardless of LOGLEVEL.
  {
    printf '%s\n' "@@@@ PROCESSING RECORDING: $(date --rfc-3339=seconds) @@@@"
    printf '%s\n' "$m2kVersion on $m2kPlatform"
  } >> "$LOGFILE"
  PROCESSING_RECORDING='True'
  inform "Processing: $RECORDING_PATH"

  #Initialise key variables with command line args, necessary if Database='Disabled'.
  TITLE="$INPUT_TITLE"
  SUBTITLE="$INPUT_SUBTITLE"
  SEASON="$INPUT_SEASON"
  EPISODE="$INPUT_EPISODE"

  #As long as we're not in diagnostics mode, gather info from MythTV-DB.
  if [[ "$M2K_DIAGNOSTICS_MODE" != 'True' ]]; then
    if ! process_mythtvdb; then return 1; fi
  elif [[ "$Database" = 'Enabled' ]]; then
    inform 'Temporarily disabling access to MythTV-DB -- for diagnostics.'
    Database='Disabled'
    RECORDING_TYPE='EP'
  fi
  msg_merged_input_mythtvdb

  #At this point we should have an initial TITLE, if not then abort.
  if [[ -z "$TITLE" ]]; then
    msg_usage
    NOTIFY_MSG="Unable to set TITLE."
    EXIT_JOB_TYPE='GenericUnspecifiedError'
    return 1
  fi

  #Check for and process Title translations relating to the show in question.
  show_translation

  #Do not process files listed in categoricIgnore or titleIgnore, just exit.
  if ! process_ignore_lists; then return 1; fi

  #Only keep Alpha-numeric characters, space, parenthesis and the six chars & , . : ' -
  TITLE="$(sed -r "s/[^[:alnum:] &,.)(:'-]//g" <<< "$TITLE")"
  #Only keep Alpha-numeric characters, space, parenthesis and the four chars & , . -
  SUBTITLE="$(sed -r 's/[^[:alnum:] &,.)(-]//g' <<< "$SUBTITLE")"

  #If we think it's an episode try and identify the series and episode.
  if [[ "$RECORDING_TYPE" = 'EP' ]]; then
    identify_series
    if ((SeriesConfidenceRating < 0)); then
      warn "Low series-confidence-rating ($SeriesConfidenceRating), requiring doover."
      RequiresDoover=1
    fi
    get_series_info
    if identify_episode; then
      if ((LOGLEVEL>=3)) && ! validate_episode; then
        warn 'Episode validation indicates inconsistent data, requiring doover.'
        RequiresDoover=1
      fi
      #Use the AbsoluteEpisodeNumber to access TheTVDB information.
      TVDB_SUBTITLE="$(sed -n "$AbsoluteEpisodeNumber"'p' "$m2kdir/$TVDB_TITLE/$TVDB_TITLE.Ename.txt")"
      TVDB_SEASON="$(  sed -n "$AbsoluteEpisodeNumber"'p' "$m2kdir/$TVDB_TITLE/$TVDB_TITLE.S.txt")"
      TVDB_EPISODE="$( sed -n "$AbsoluteEpisodeNumber"'p' "$m2kdir/$TVDB_TITLE/$TVDB_TITLE.E.txt")"
      #Use TheTVDB info as our recording info.
      [[ -n "$TVDB_SUBTITLE" ]] && SUBTITLE="$TVDB_SUBTITLE"
      [[ -n "$TVDB_SEASON" ]]   && SEASON="$TVDB_SEASON"
      [[ -n "$TVDB_EPISODE" ]]  && EPISODE="$TVDB_EPISODE"
    fi
    if ((EpisodeConfidenceRating < 0)); then
      warn "Low episode-confidence-rating ($EpisodeConfidenceRating), requiring doover."
      RequiresDoover=1
    fi
    #Update confidence total.
    ((ConfidenceRating = EpisodeConfidenceRating + SeriesConfidenceRating))

    #Try to set Sxx and Exx using SEASON, EPISODE.
    set_sxxexx_with_season_episode

    storagegroup_fallback #In-case it is actually a movie

    #Warn if we have not obtained a TVDB_SERIESID and still think it's an 'EP'.
    [[ -z "$TVDB_SERIESID" && "$RECORDING_TYPE" = 'EP' ]] && msg_unrecognised_series
  fi

  #Determine write permissions and free space for Move and Working directories.
  check_filesystem
  #Report a summary of the recording identification process.
  msg_operation_summary

  #Checks before setting the new file-name.
  if ! naming_checks; then return 1; fi

  format_filename

  make_show_dir

  ((FailSafeState == 1)) && { if failsafe; then return 0; else return 1; fi }

  if ! anti_clobber; then return 1; fi

  #If this is a test file, then exit now.
  [[ "$RECORDING_PATH" = "$M2K_TEST_FILE" ]] && testfile_exit

  #If the show is generic programming, this is the best myth2kodi can do.
  [[ "$RECORDING_TYPE" = 'SH' ]] && msg_show_warning

  #Process the recording file.
  if [[ "$PROCESS_RECORDING_MODE" = 'MOVE' ]]; then
    #Move and rename the recording file, optionally adding a link.
    if move_mode_handling; then return 0; else return 1; fi
  elif [[ "$PROCESS_RECORDING_MODE" = 'LINK' ]]; then
    #Create a symbolic-link to the recording file.
    if link_mode_handling; then return 0; else return 1; fi
  elif [[ "$PROCESS_RECORDING_MODE" = 'HARDLINK' ]]; then
    #Create a hard-link to the recording file.
    if hardlink_mode_handling; then return 0; else return 1; fi
  elif [[ "$PROCESS_RECORDING_MODE" = 'COPY' ]]; then
    #Copy and rename the recording file.
    if copy_mode_handling; then return 0; else return 1; fi
  fi
  #THE END

  #Failed to capture the cause of an error...
  NOTIFY_MSG="myth2kodi operation failed See '$LOGFILE' for more information"
  EXIT_JOB_TYPE='GenericUnspecifiedError'
  return 1
} #main()

################################################################################
########################### END FUNCTION DEFINITIONS ###########################
################################################################################


######################### BEGIN MAIN PROGRAM ###################################

#Capture arguments that the script was called with.
M2KARG_COUNT="$#"
M2KARG1="$1"
M2KARG2="$2"
M2KARG3="$3"
M2KARG4="$4"
M2KARG5="$5"

#Make them read-only so we can't accidentally modify them.
declare -gr M2KARG_COUNT M2KARG1 M2KARG2 M2KARG3 M2KARG4 M2KARG5

#Run the main function
if ! main; then debug "Exited main() function with an error state."; fi

#Final messaging and clean-up, running any user specified post-processing jobs.
exit_job "$EXIT_JOB_TYPE"

err "The exit_job function must be broken for you to see this message..."
exit 4
